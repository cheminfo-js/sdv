{"version":3,"sources":["webpack:///sdv/webpack/universalModuleDefinition","webpack:///sdv/sdv.min.js","webpack:///sdv/webpack/bootstrap fce71ee088f33ca04419","webpack:///sdv/./src/index.js","webpack:///sdv/./~/extend/index.js","webpack:///sdv/./~/spectra-data/src/index.js","webpack:///sdv/./~/spectra-data/src/SD.js","webpack:///sdv/./~/ml-stat/array.js","webpack:///sdv/./~/jcampconverter/src/index.js","webpack:///sdv/./~/jcampconverter/src/parseXYData.js","webpack:///sdv/./~/spectra-data/src/JcampCreator.js","webpack:///sdv/./~/spectra-data/src/VectorEncoder.js","webpack:///sdv/./~/spectra-data/src/NMR.js","webpack:///sdv/./~/spectra-data/src/PeakPicking.js","webpack:///sdv/./~/spectra-data/src/JAnalyzer.js","webpack:///sdv/./~/ml-gsd/src/index.js","webpack:///sdv/./~/ml-gsd/src/optimize.js","webpack:///sdv/./~/ml-optimize-lorentzian/src/index.js","webpack:///sdv/./~/ml-curve-fitting/src/index.js","webpack:///sdv/./~/ml-curve-fitting/src/LM.js","webpack:///sdv/./~/ml-curve-fitting/~/ml-matrix/src/index.js","webpack:///sdv/./~/ml-curve-fitting/~/ml-matrix/src/matrix.js","webpack:///sdv/./~/ml-curve-fitting/~/ml-matrix/src/decompositions.js","webpack:///sdv/./~/ml-curve-fitting/~/ml-matrix/src/dc/svd.js","webpack:///sdv/./~/ml-curve-fitting/~/ml-matrix/src/dc/util.js","webpack:///sdv/./~/ml-curve-fitting/~/ml-matrix/src/dc/evd.js","webpack:///sdv/./~/ml-curve-fitting/~/ml-matrix/src/dc/lu.js","webpack:///sdv/./~/ml-curve-fitting/~/ml-matrix/src/dc/qr.js","webpack:///sdv/./~/ml-curve-fitting/~/ml-matrix/src/dc/cholesky.js","webpack:///sdv/./~/ml-curve-fitting/src/algebra.js","webpack:///sdv/./~/ml-optimize-lorentzian/~/ml-matrix/src/index.js","webpack:///sdv/./~/ml-optimize-lorentzian/~/ml-matrix/src/matrix.js","webpack:///sdv/./~/ml-optimize-lorentzian/~/ml-matrix/src/decompositions.js","webpack:///sdv/./~/ml-optimize-lorentzian/~/ml-matrix/src/dc/svd.js","webpack:///sdv/./~/ml-optimize-lorentzian/~/ml-matrix/src/dc/util.js","webpack:///sdv/./~/ml-optimize-lorentzian/~/ml-matrix/src/dc/evd.js","webpack:///sdv/./~/ml-optimize-lorentzian/~/ml-matrix/src/dc/lu.js","webpack:///sdv/./~/ml-optimize-lorentzian/~/ml-matrix/src/dc/qr.js","webpack:///sdv/./~/ml-optimize-lorentzian/~/ml-matrix/src/dc/cholesky.js","webpack:///sdv/./~/ml-gsd/src/gsd.js","webpack:///sdv/./~/ml-stat/index.js","webpack:///sdv/./~/ml-stat/matrix.js","webpack:///sdv/./~/ml-savitzky-golay-generalized/src/index.js","webpack:///sdv/./~/spectra-data/src/ImpurityRemover.js","webpack:///sdv/./~/ml-fft/src/index.js","webpack:///sdv/./~/ml-fft/src/FFTUtils.js","webpack:///sdv/./~/ml-fft/src/fftlib.js","webpack:///sdv/./~/spectra-data/src/filters/Filters.js","webpack:///sdv/./~/spectra-data/src/filters/fourierTransform.js","webpack:///sdv/./~/spectra-data/src/filters/zeroFilling.js","webpack:///sdv/./~/spectra-data/src/filters/apodization.js","webpack:///sdv/./~/spectra-data/src/filters/phaseCorrection.js","webpack:///sdv/./~/spectra-data/src/filters/digitalFilter.js","webpack:///sdv/./~/spectra-data/src/filters/rotate.js","webpack:///sdv/./~/spectra-data/src/NMR2D.js","webpack:///sdv/./~/spectra-data/src/PeakPicking2D.js","webpack:///sdv/./~/spectra-data/src/PeakOptimizer.js","webpack:///sdv/./~/spectra-data/src/SimpleClustering.js","webpack:///sdv/./~/spectra-data/src/AcsParser.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","annotations1D","signals","optionsG","options","extend","options1D","line","annotations","i","length","annotation","prediction","push","_highlight","type","position","x","to","y","from","label","text","Math","round","integral","size","anchor","color","labelColor","signal","delta","dy","strokeColor","strokeWidth","fillColor","info","annotations2D","signals2D","options2D","k","fromTo","dx","width","height","remark","SD","NMR","NMR2D","ACS","JAnalyzer","GUI","hasOwn","Object","prototype","hasOwnProperty","toStr","toString","isArray","arr","Array","isPlainObject","obj","hasOwnConstructor","hasIsPrototypeOf","constructor","key","name","src","copy","copyIsArray","clone","target","arguments","deep","sd","DATACLASS_XY","DATACLASS_PEAK","activeElement","StatArray","JcampConverter","JcampCreator","fromJcamp","jcamp","xy","keepSpectra","keepRecordsRegExp","spectrum","convert","setActiveElement","nactiveSpectrum","getActiveElement","getXUnits","getSpectrum","xUnit","setXUnits","units","getYUnits","yUnit","getSpectraVariable","dim","ntuples","getNbPoints","getSpectrumData","getFirstX","spectra","firstX","setFirstX","getLastX","lastX","setLastX","getFirstY","firstY","setFirstY","getLastY","lastY","setLastY","setDataClass","dataClass","isPeaktable","isXYdata","isDataClassPeak","isDataClassXY","setDataType","dataType","getDataType","data","getNbSubSpectra","getXData","getYData","getX","getY","getXYData","getTitle","title","setTitle","newTitle","getMinY","min","getMaxY","max","getMinMaxY","minMax","getNoiseLevel","mean","stddev","averageDeviations","abs","sort","getNMRPeakThreshold","getNucleus","arrayPointToUnits","doublePoint","unitsToArrayPoint","inValue","getDeltaX","midPoint","currentArrayPoint","upperLimit","lowerLimit","floor","setMinMax","factor","setMin","currentMin","setMax","YShift","value","shift","globalShift","fillWith","tmp","start","end","suppressZone","splice","simplePeakPicking","parameters","getMaxPeak","getSpectraDataY","index","getParamDouble","defvalue","getParamString","getParamInt","getParam","containsParam","getSpectraDataX","resetMinMax","putParam","getArea","i0","ie","area","getVector","nPoints","direction","reversed","winPoints","xwin","ywin","di","is2D","twoD","toJcamp","defaultOptions","encode","yFactor","keep","compareNumbers","a","b","sum","values","Infinity","l","arithmeticMean","geometricMean","mul","pow","logMean","lnsum","log","grandMean","means","samples","n","truncatedMean","percent","alreadySorted","undefined","slice","harmonicMean","RangeError","contraHarmonicMean","r1","r2","median","half","variance","unbiased","theMean","theVariance","standardDeviation","sqrt","standardError","quartiles","quart","q1","ceil","q2","q3","pooledStandardDeviation","pooledVariance","vari","mode","itemCount","itemArray","count","indexOf","maxValue","maxIndex","covariance","vector1","vector2","mean1","mean2","cov","skewness","s2","s3","dev","m2","m3","g","kurtosis","s4","m4","v","entropy","eps","weightedMean","weights","weightedStandardDeviation","weightedVariance","z","w","center","inPlace","result","standardize","standardDev","cumulativeSum","array","getConverter","convertToFloatArray","stringArray","floatArray","parseFloat","Spectrum","ldr","dataLabel","dataValue","ldrs","ii","endLine","infos","Date","now","profiling","logs","action","time","split","replace","substring","trim","toUpperCase","xIndex","yIndex","firstVariable","secondVariable","symbol","first","last","vardim","nbPoints","xFactor","datatable","deltaX","observeFrequency","xType","indirectFrequency","shiftOffsetNum","shiftOffsetVal","varname","ntuplesSeparator","vartype","varform","yType","page","pageValue","pageSymbol","pageSymbolIndex","unit","prepareSpectrum","match","fastParse","parseXYDataRegExp","fastParseXYData","parsePeakTable","isMSField","convertMSFieldToLabel","keys","newNtuples","j","add2D","isGCMS","newGCMS","newData","addNewGCMS","addGCMS","toLowerCase","GC_MS_FIELDS","gcms","times","series","dimension","existingGCMSFields","gc","ms","convertTo3DZ","noise","minZ","maxZ","ySize","xSize","xVector","minX","maxX","minY","maxY","zData","contourLines","generateContourLines","povarHeight0","povarHeight1","povarHeight2","povarHeight3","isOver0","isOver1","isOver2","isOver3","pAx","pAy","pBx","pBy","lineZValue","contourLevels","nbLevels","nbContourLevels","noiseMultiplier","nbSubSpectra","nbPovars","x0","xN","y0","yN","level","contourLevel","side","exp","lines","zValue","iSubSpectra","subSpectra","subSpectraAfter","povar","segments","currentData","currentPosition","currentX","currentY","ascii","charCodeAt","newLine","isDifference","isLastDifference","lastDifference","isDuplicate","inComment","currentValue","isNegative","skipFirstValue","decimalPosition","duplicate","ascii2","removeCommentRegExp","peakTableSplitRegExp","jj","input","useWorker","postToWorker","worker","createWorker","Promise","resolve","stamp","random","stamps","postMessage","JSON","stringify","workerURL","URL","createObjectURL","Blob","Worker","revokeObjectURL","addEventListener","event","parse","output","xyDataSplitRegExp","DEBUG","lastDif","firstPoint","expectedCurrentX","String","fromCharCode","dup","Encoder","Integer","MAX_VALUE","MIN_VALUE","CRLF","version","spectraData","encodeFormat","factorY","userDefinedParams","outString","scale","scaleX","ntuplesHead","simpleHead","variableX","variableY","variableZ","sub","nTuplesName","abscVar","mostCommon","defaultSub","isComplex","isNMR","getSolventName","freq1","freq2","observeFrequencyX","yUnits","point","tempString","pseudoDigits","SQZ_P","SQZ_N","DIF_P","DIF_N","DUP","MaxLinelength","intervalX","encoding","FIXencod","SQZencod","DIFencod","DIFDUPencod","CSVencod","PACencod","separator","outputData","TD","SQZDigit","mult","charCount","encodData","encodNumber","temp","diffData","numDiff","DIFDigit","DUPDigit","num","SQZdigit","charAt","Number","DIFFdigit","DUPdigit","PeakPicking","Filters","create","nucleus","addNoise","SNR","addSpectraDatas","spec2","factor1","factor2","autoscale","autoBaseline","fourierTransform","postFourierTransform","ph1corr","phaseCorrection","zeroFilling","nPointsX","nPointsY","haarWhittakerBaselineCorrection","waveletScale","whittakerLambda","whittakerBaselineCorrection","ranges","brukerFilter","digitalFilter","apodization","functionName","lineBroadening","echoAntiechoFilter","SNVFilter","powerFilter","power","console","warn","logarithmFilter","base","correlationFilter","func","phi0","phi1","automaticPhase","nmrPeakDetection","peakPicking","GSD","removeImpurities","impurities","maxJ","nH","clean","realTop","thresholdFactor","compile","integralFn","optimize","idPrefix","format","optionsEx","nHi","noiseLevel","gsdOptions","minMaxRatio","broadRatio","smoothY","nL","sgOptions","windowSize","polynomial","peakList","gsd","post","joinBroadPeaks","optimizePeaks","clearList","detectSignals","integralData","compilePattern","maskPattern","multiplicity","peaksO","peaks","peakR","intensity","mask","mask2","nbPeaks","peaks1","newSignals","updateIntegrals","delta1","signalID","nbAtoms","diaID","peak","kind","nmrJs","threshold","sampling","rowWise","ic","more","updateLimits","nbPeaks0","toRemove","sumIntegral","sumObserved","integralType","cs","frequency","signal1D","prevPeak","rangeX","spectrumIntegral","startX","stopX","pattern","observe","updateScore","candidates","maxIntensity","indexMin","score","thisJ1","thisJ2","thisJ3","thisJ4","gamma","pascalTriangle","patterns","symRatio","maxErrorIter1","maxErrorIter2","symRank","symmetrizeChoiseBest","asymmetric","peaksComp","P1","n2","maxFlagged","Jc","normalize","validPattern","getRanges","heights","getNextCombination","numbering","nFlagged","u","jSum","idealPattern","updateSignal","abstractPattern","tol","cont","newNmrJs","coupling","hsum","ok","lng","currentIndex","active","maxError","iteration","symRank1","symmetrize","tmpPeaks","tmpMask","symRank2","avg","ratio","avgWidth","left","right","middle","error","heightSum","diffL","diffR","chemicalShift","isNaN","symFactor","weight","newSumHeights","dxi","norm","norm2","sampleFunction","lastIndex","sampleX","sampleY","sign","mid","stop","fnType","groups","groupPeaks","group","limits","opts","optPeaks","Opt","optimizeGaussianSum","optimizeLorentzianSum","optPeak","optimizeSingleGaussian","optimizeSingleLorentzian","broadLines","maxI","soft","indexes","fitted","map","sumOfLorentzians","t","p2","cols","rows","Matrix","zeros","singleLorentzian","columns","singleGaussian","xy2","parseData","y_data","dot","consts","dt","p_init","p_min","p_max","p_fit","LM","math","nbSeries","SizeException","algebra","y_dat","dp","tensor_parameter","Npar","Npnt","p_old","y_old","X2","X2_old","J","length_t","length_y_dat","multiply","transpose","prnt","MaxIter","epsilon_1","epsilon_4","lambda_0","lambda_UP_fac","lambda_DN_fac","Update_Type","dp_array","idx","Nfit","weight_sq","ones","dotMultiply","lm_matx","JtWJ","JtWdy","Chi_sq","y_hat","lambda","diag","nu","h","solve","add","eye","hidx","p_try","delta_y","subtract","X2_try","JtWdy_th","alpha","inv","mat","rho","dX2","apply","lm_FD_J","ps","del","y1","column","dotDivide","lm_Broyden_J","h_t","div","Jt","Decompositions","DC","nRows","nColumns","matrix","newInstance","TypeError","defineProperty","writable","__proto__","Asplice","Aconcat","concat","from1DArray","newRows","newColumns","rowVector","columnVector","vector","empty","fill","rand","indices","stack","arg1","isMatrix","r","current","setRow","expand","expansion","checkMatrix","klass","get","checkRowIndex","checkColumnIndex","checkDimensions","otherMatrix","callback","to2DArray","to1DArray","isRowVector","isColumnVector","isVector","isSquare","isSymmetric","set","rowIndex","columnIndex","neg","mulS","addS","addM","subS","subM","mulM","divS","divM","getRow","getRowVector","removeRow","addRow","swapRows","row1","row2","getColumn","getColumnVector","setColumn","removeColumn","addColumn","swapColumns","column1","column2","row","checkRowVector","checkColumnVector","addRowVector","subRowVector","mulRowVector","divRowVector","addColumnVector","subColumnVector","mulColumnVector","divColumnVector","mulRow","mulColumn","minIndex","maxRow","maxRowIndex","minRow","minRowIndex","maxColumn","maxColumnIndex","minColumn","minColumnIndex","prod","other","mmul","Bcolj","Arowi","s","sortRows","compareFunction","sortColumns","subMatrix","startRow","endRow","startColumn","endColumn","newMatrix","subMatrixRow","X","subMatrixColumn","trace","inverse","leftHandSide","rightHandSide","LuDecomposition","QrDecomposition","SingularValueDecomposition","EigenvalueDecomposition","CholeskyDecomposition","SVD","EVD","LU","QR","CHO","wantu","wantv","computeLeftSingularVectors","computeRightSingularVectors","autoTranspose","swapped","aux","ks","f","sn","kase","sp","spm1","epm1","sk","ek","U","V","e","work","nct","nrt","hypotenuse","pp","iter","condition","rank","diagonal","leftSingularVectors","rightSingularVectors","diagonalMatrix","Y","scols","Ls","VL","vrows","urows","VLU","solveForDiagonal","vcols","ucols","Error","d","tred2","tql2","H","ort","orthes","hqr2","hh","dl1","c2","c3","el1","tst1","low","high","nn","ra","sa","vr","vi","notlast","cdivres","exshift","q","cdiv","xr","xi","yr","yi","realEigenvalues","imaginaryEigenvalues","eigenvectorMatrix","LUrowi","LUcolj","kmax","lu","pivotVector","pivotSign","isSingular","col","determinant","lowerTriangularFactor","upperTriangularFactor","pivotPermutationVector","qr","rdiag","nrm","Rdiag","isFullRank","orthogonalFactor","positiveDefinite","Lrowj","Lrowk","L","leftTriangularFactor","B","A","dotPow","noiseFactor","maxCriteria","realTopDetection","sgDefOptions","maxDx","minDx","yCorrection","SG","derivative","dY","ddY","maxDdy","minddY","intervalL","intervalR","lastMax","lastMin","broadMask","possible","distanceJ","minDistance","gettingCloser","lastK","beta","currentPoint","log10","l1","l2","N","sum1","sum2","medians","modes","skew","kurt","standardDeviations","standardErrors","sqrtN","scatter","divisor","correlation","scores","zScores","cor","resultRow","sourceRow","weightSum","arrayStat","weightedCovariance","s1","weightedScatter","SavitzkyGolay","isInteger","np","ans","fullWeights","hs","constantH","wg1","wg2","d1","d2","getHs","wg","GramPoly","Grampoly","GenFact","gf","Weight","checkImpurity","impurity","found","solvent","impuritiesList","shifts","proton","look4","FFTUtils","FFT","ifft2DArray","ft","ftRows","ftCols","tempTransform","nCols","init","tmpCols","re","im","iCol","iRow","bt","finalTransform","tmpRows","indexB","fft2DArray","iRow0","iRow1","iRow2","iRow3","fft1d","reconstructTwoRealFFT","realTransform1","realTransform2","rm","rp","ip","convolute2DI","ftSignal","ftFilter","convolute","kernel","ftSpectrum","ftFilterData","ir","release","date","_n","_bitrev","_cstb","core","_initArray","_makeBitReversalTable","_makeCosSinTable","fft","ifft1d","bt1d","fft2d","tre","tim","x1","x2","y2","ifft2d","ik","wr","wi","n4","Uint32Array","Float64Array","_paddingZero","n8","n2p4","sin","PI","dc","ds","apis","ifft","nSubSpectra","spectraType","fcor","updateSpectra","baseFrequency","NaN","spectralFrequency","spectralWidth","xMiddle","zeroFillingX","zeroFillingY","nbXPoints","cosThetaNew","sinThetaNew","reTmp","imTmp","reData","imData","cosTheta","cos","sinTheta","rotate","rotateX","next","nextIndex","toMove","lastFirstIndex","putInRange","PeakPicking2D","PeakOptimizer","isHomoNuclear","observeFrequencyY","getZUnits","getDeltaY","nmrPeakDetection2D","findPeaks2D","references","alignDimensions","shiftX","shiftY","lib","SimpleClustering","smallFilter","getLoGnStdDevNMR","isHomonuclear","nStdDev","convolutedSpectrum","convoluteWithLoG","peaksMC1","findPeaks2DLoG","peaksMax1","findPeaks2DMax","enhanceSymmetry","createSignals2D","inputSpectrum","bitmask","nbDetectedPoints","iStart","extractArea","rowI","colI","peakListMax","tmpIndex","peakPoints","scanBitmask","nValues","xAverage","yAverage","zSum","NEGATIVE_INFINITY","pt","minmax","newPeak","tolerance","bf1","bf2","connectivity","clusters","fullClusterGenerator","iCluster","nucleusX","nucleusY","resolutionX","resolutionY","peaks2D","minMax1","minMax2","sumZ","jPeak","diagonalError","toleranceX","toleranceY","properties","initializeProperties","hits","exist","checkCrossPeaks","completeMissingIfNeeded","toReturn","thisSignal","thisProp","addedPeaks","newSignal","tmpProp","diagX","diagY","updateProperties","cross","crossPeaksX","crossPeaksY","symmetricSearch","distanceTo","signalsProperties","toImage","ref","_alignSingleDimension","signal2D","conn","clusterList","available","remaining","cluster","nextAv","toInclude","formater","fromNMRSignal1D2ACS","acsString","parenthesis","spectro","rangeForMultiplet","ascending","formatAcs_default","decimalValue","decimalJ","appendSeparator","appendSpectroInformation","numberSmartPeakLabels","appendDelta","appendParenthesis","formatNucleus","toFixed","formatMF","nbDecimal","appendMultiplicity","appendIntegration","appendCoupling","appendAssignment","pubIntegration","appendParenthesisSeparator","pubAssignment","formatAssignment","assignment","pubMultiplicity","mf","fromACS2NMRSignal1D","SDAPI","AcsParserAsJSONString","toACS","toNMRSignal"],"mappings":"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","file":"sdv.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sdv\"] = factory();\n\telse\n\t\troot[\"sdv\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sdv\"] = factory();\n\telse\n\t\troot[\"sdv\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t * Created by acastillo on 5/25/16.\n\t */\n\tvar extend = __webpack_require__(1);\n\tvar SD = __webpack_require__(2);\n\t\n\texports.NMR = SD.NMR;\n\texports.NMR2D = SD.NMR2D;\n\texports.ACS = SD.ACS;\n\texports.JAnalyzer = SD.JAnalyzer;\n\t\n\tvar options1D = {type:\"rect\",line:0, labelColor:\"red\", strokeColor:\"red\", strokeWidth:\"1px\", fillColor:\"green\"};\n\tvar options2D = {type:\"rect\",labelColor:\"red\", strokeColor:\"red\", strokeWidth:\"1px\", fillColor:\"green\", width:\"6px\", height:\"6px\"};\n\t\n\tfunction annotations1D(signals, optionsG){\n\t    var options = extend({}, options1D, optionsG);\n\t    const line = options.line;\n\t    var annotations=[];\n\t    for (var i=0; i<signals.length; i++) {\n\t        var annotation={};\n\t        var prediction=signals[i];\n\t        annotations.push(annotation);\n\t\n\t        annotation._highlight=prediction._highlight;\n\t        annotation.type=options.type;\n\t        annotation.position=[{x:prediction.to, y:(line*15)+\"px\"},\n\t            {x:prediction.from, y:(line*15+10)+\"px\"}];\n\t\n\t        annotation.label={\n\t            text: Math.round(prediction.integral*10)/10.0,\n\t            size: \"11px\",\n\t            anchor: 'middle',\n\t            color:options.labelColor,\n\t            position: {x: prediction.signal[0].delta, y:(line*15)+\"px\", dy: \"5px\"}\n\t        };\n\t\n\t        annotation.strokeColor=options.strokeColor;\n\t        annotation.strokeWidth=options.strokeWidth;\n\t        annotation.fillColor=options.fillColor;\n\t        annotation.info=prediction;\n\t    }\n\t    return annotations;\n\t} \n\t\n\tfunction annotations2D(signals2D, optionsG){\n\t    var options = extend({}, options2D, optionsG);\n\t    var annotations=[];\n\t    for(var k=signals2D.length-1;k>=0;k--){\n\t        var signal = signals2D[k];\n\t        var annotation={};\n\t        annotation.type=options.type;\n\t        annotation._highlight=signal._highlight;//[\"cosy\"+k];\n\t        annotation.position = [{x:signal.fromTo[0].from-0.01, y:signal.fromTo[1].from-0.01, dx:options.width, dy:options.height},\n\t            {x:signal.fromTo[0].to+0.01,y:signal.fromTo[1].to+0.01}];\n\t        annotation.fillColor=options.fillColor;\n\t        annotation.label={text:signal.remark,\n\t            \"position\": {\n\t                \"x\": signal.signal[0].delta[0],\n\t                \"y\": signal.signal[0].delta[1]-0.025}\n\t        };\n\t        if(signal.integral==1)\n\t            annotation.strokeColor=options.strokeColor;\n\t        else\n\t            annotation.strokeColor=\"rgb(0,128,0)\";\n\t\n\t        annotation.strokeWidth=options.strokeWidth;\n\t        annotation.width=options.width;\n\t        annotation.height=options.height;\n\t        annotation.info=signal;\n\t        annotations.push(annotation);\n\t    }\n\t    return annotations;\n\t}\n\t\n\texports.GUI = {annotations2D:annotations2D, annotations1D: annotations1D};\n\t\n\t\n\t\n\t\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar hasOwn = Object.prototype.hasOwnProperty;\n\tvar toStr = Object.prototype.toString;\n\t\n\tvar isArray = function isArray(arr) {\n\t\tif (typeof Array.isArray === 'function') {\n\t\t\treturn Array.isArray(arr);\n\t\t}\n\t\n\t\treturn toStr.call(arr) === '[object Array]';\n\t};\n\t\n\tvar isPlainObject = function isPlainObject(obj) {\n\t\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\t\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t\t// Not own constructor property must be Object\n\t\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\t// Own properties are enumerated firstly, so to speed up,\n\t\t// if last one is own, then all properties are own.\n\t\tvar key;\n\t\tfor (key in obj) {/**/}\n\t\n\t\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n\t};\n\t\n\tmodule.exports = function extend() {\n\t\tvar options, name, src, copy, copyIsArray, clone,\n\t\t\ttarget = arguments[0],\n\t\t\ti = 1,\n\t\t\tlength = arguments.length,\n\t\t\tdeep = false;\n\t\n\t\t// Handle a deep copy situation\n\t\tif (typeof target === 'boolean') {\n\t\t\tdeep = target;\n\t\t\ttarget = arguments[1] || {};\n\t\t\t// skip the boolean and the target\n\t\t\ti = 2;\n\t\t} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {\n\t\t\ttarget = {};\n\t\t}\n\t\n\t\tfor (; i < length; ++i) {\n\t\t\toptions = arguments[i];\n\t\t\t// Only deal with non-null/undefined values\n\t\t\tif (options != null) {\n\t\t\t\t// Extend the base object\n\t\t\t\tfor (name in options) {\n\t\t\t\t\tsrc = target[name];\n\t\t\t\t\tcopy = options[name];\n\t\n\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\tif (target !== copy) {\n\t\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\t\ttarget[name] = extend(deep, clone, copy);\n\t\n\t\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Return the modified object\n\t\treturn target;\n\t};\n\t\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\texports.SD = __webpack_require__(3);\n\texports.NMR = __webpack_require__(9);\n\texports.NMR2D = __webpack_require__(51);\n\texports.ACS = __webpack_require__(55);\n\texports.JAnalyzer = __webpack_require__(11);\n\t//exports.SD2 = require('/SD2');\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// small note on the best way to define array\n\t// http://jsperf.com/lp-array-and-loops/2\n\t\n\tvar StatArray = __webpack_require__(4);\n\tvar JcampConverter = __webpack_require__(5);\n\tvar JcampCreator = __webpack_require__(7);\n\tvar extend = __webpack_require__(1);\n\t\n\t/**\n\t * Construct the object from the given sd object(output of the jcampconverter or brukerconverter filter)\n\t * @param sd\n\t * @constructor\n\t */\n\tfunction SD(sd) {\n\t    this.DATACLASS_XY=1;\n\t    this.DATACLASS_PEAK=2;\n\t\n\t    this.sd=sd;\n\t    this.activeElement=0;\n\t}\n\t\n\t/**\n\t * @function fromJcamp(jcamp,options)\n\t * Construct the object from the given jcamp.\n\t * @param jcamp\n\t * @param options\n\t * @option xy\n\t * @option keepSpectra\n\t * @option keepRecordsRegExp\n\t * @returns {SD}\n\t */\n\tSD.fromJcamp = function(jcamp, options) {\n\t    options = options || {xy:true,keepSpectra:true,keepRecordsRegExp:/^.+$/};\n\t    var spectrum= JcampConverter.convert(jcamp,options);\n\t    return new SD(spectrum);\n\t}\n\t\n\t\n\t/**\n\t * @function setActiveElement(nactiveSpectrum);\n\t * This function sets the nactiveSpectrum sub-spectrum as active\n\t * @param index of the sub-spectrum to set as active\n\t */\n\tSD.prototype.setActiveElement = function(nactiveSpectrum){\n\t    this.activeElement=nactiveSpectrum;\n\t}\n\t\n\t/**\n\t * @function getActiveElement();\n\t * This function returns the index of the active sub-spectrum.\n\t * @returns {number|*}\n\t */\n\tSD.prototype.getActiveElement = function(){\n\t    return this.activeElement;\n\t}\n\t\n\t/**\n\t * @function getXUnits()\n\t * This function returns the units of the independent dimension.\n\t * @returns {xUnit|*|M.xUnit}\n\t */\n\tSD.prototype.getXUnits = function(){\n\t    return this.getSpectrum().xUnit;\n\t}\n\t\n\t/**\n\t * @function setXUnits()\n\t * This function returns the units of the independent dimension.\n\t * @returns {xUnit|*|M.xUnit}\n\t */\n\tSD.prototype.setXUnits = function(units){\n\t    this.getSpectrum().xUnit=units;\n\t}\n\t\n\t/**\n\t * @function getYUnits()\n\t * * This function returns the units of the dependent variable.\n\t * @returns {yUnit|*|M.yUnit}\n\t */\n\tSD.prototype.getYUnits = function(){\n\t    return this.getSpectrum().yUnit;\n\t}\n\t\n\t/**\n\t * @function getSpectraVariable()\n\t * This function returns the information about the dimensions\n\t * @returns {*}\n\t */\n\tSD.prototype.getSpectraVariable = function(dim){\n\t    return this.sd.ntuples[dim];\n\t}\n\t\n\t/**\n\t * @function getNbPoints()\n\t * Return the number of points in the current spectrum\n\t * @param i sub-spectrum\n\t * @returns {*}\n\t */\n\tSD.prototype.getNbPoints=function(i){\n\t    return this.getSpectrumData(i).y.length;\n\t}\n\t\n\t/**\n\t * @function getFirstX()\n\t * Return the first value of the direct dimension\n\t * @param i sub-spectrum\n\t * @returns {number}\n\t */\n\tSD.prototype.getFirstX=function(i) {\n\t    i=i||this.activeElement;\n\t    return this.sd.spectra[i].firstX;\n\t}\n\t\n\t/**\n\t * @function setFirstX()\n\t * Set the firstX for this spectrum. You have to force and update of the xAxis after!!!\n\t * @param x\n\t * @param i sub-spectrum\n\t */\n\tSD.prototype.setFirstX=function(x, i) {\n\t    i=i||this.activeElement;\n\t    this.sd.spectra[i].firstX=x;\n\t}\n\t\n\t/**\n\t * @function getLastX()\n\t * Return the last value of the direct dimension\n\t * @param i sub-spectrum\n\t * @returns {number}\n\t */\n\tSD.prototype.getLastX=function(i) {\n\t    i=i||this.activeElement;\n\t    return this.sd.spectra[i].lastX;\n\t}\n\t\n\t/**\n\t * @function setLastX()\n\t * Set the last value of the direct dimension. You have to force and update of the xAxis after!!!\n\t * @param x\n\t * @param i sub-spectrum\n\t */\n\tSD.prototype.setLastX=function(x, i) {\n\t    i=i||this.activeElement;\n\t    this.sd.spectra[i].lastX=x;\n\t}\n\t\n\t/**\n\t */\n\t/**\n\t * Return the first value of the direct dimension\n\t * @param i sub-spectrum\n\t * @returns {number}\n\t */\n\tSD.prototype.getFirstY=function(i) {\n\t    i=i||this.activeElement;\n\t    return this.sd.spectra[i].firstY;\n\t}\n\t\n\t/**\n\t * @function setFirstY()\n\t * Set the first value of the indirect dimension. Only valid for 2D spectra.\n\t * @param y\n\t * @param i sub-spectrum\n\t */\n\tSD.prototype.setFirstY=function(y, i) {\n\t    i=i||this.activeElement;\n\t    this.sd.spectra[i].firstY = y;\n\t}\n\t\n\t/**\n\t * @function getLastY\n\t * Return the first value of the indirect dimension. Only valid for 2D spectra.\n\t * @returns {number}\n\t */\n\tSD.prototype.getLastY = function(i){\n\t    i=i||this.activeElement;\n\t    return this.sd.spectra[i].lastY;\n\t}\n\t\n\t/**\n\t * @function setLastY()\n\t * Return the first value of the indirect dimension\n\t * @param y\n\t * @param i sub-spectrum\n\t */\n\tSD.prototype.setLastY = function(y, i){\n\t    i=i||this.activeElement;\n\t    this.sd.spectra[i].lastY = y;\n\t}\n\t\n\t/**\n\t * @function setDataClass()\n\t * Set the spectrum data_class. It could be DATACLASS_PEAK=1 or DATACLASS_XY=2\n\t * @param dataClass\n\t */\n\tSD.prototype.setDataClass = function(dataClass){\n\t    if(dataClass==this.DATACLASS_PEAK) {\n\t        this.getSpectrum().isPeaktable = true;\n\t        this.getSpectrum().isXYdata = false;\n\t    }\n\t    if(dataClass==this.DATACLASS_XY){\n\t        this.getSpectrum().isXYdata = true;\n\t        this.getSpectrum().isPeaktable = false;\n\t    }\n\t}\n\t\n\t/**\n\t * @function isDataClassPeak();\n\t * Is this a PEAKTABLE spectrum?\n\t * @returns {*}\n\t */\n\tSD.prototype.isDataClassPeak = function(){\n\t    if(this.getSpectrum().isPeaktable)\n\t        return  this.getSpectrum().isPeaktable;\n\t    return false;\n\t}\n\t\n\t/**\n\t * @function isDataClassXY();\n\t * Is this a XY spectrum?\n\t * @returns {*}\n\t */\n\tSD.prototype.isDataClassXY = function(){\n\t    if(this.getSpectrum().isXYdata)\n\t        return  this.getSpectrum().isXYdata;\n\t    return false\n\t}\n\t\n\t/**\n\t * @function setDataType()\n\t * Set the data type for this spectrum. It could be one of the following:\n\t [\"INFRARED\"||\"IR\",\"IV\",\"NDNMRSPEC\",\"NDNMRFID\",\"NMRSPEC\",\"NMRFID\",\"HPLC\",\"MASS\"\n\t * \"UV\", \"RAMAN\" \"GC\"|| \"GASCHROMATOGRAPH\",\"CD\"|| \"DICHRO\",\"XY\",\"DEC\"]\n\t * @param dataType\n\t */\n\tSD.prototype.setDataType = function(dataType){\n\t    this.getSpectrum().dataType=dataType;\n\t}\n\t\n\t/**\n\t * @function getDataType()\n\t * Return the dataType(see: setDataType )\n\t * @returns {string|string|*|string}\n\t */\n\tSD.prototype.getDataType = function(){\n\t    return this.getSpectrum().dataType;\n\t}\n\t\n\t/**\n\t * @function getSpectrumData()\n\t * Return the i-th sub-spectrum data in the current spectrum\n\t * @param i\n\t * @returns {this.sd.spectra[i].data[0]}\n\t */\n\tSD.prototype.getSpectrumData=function(i) {\n\t    i=i||this.activeElement;\n\t    return this.sd.spectra[i].data[0];\n\t}\n\t\n\t/**\n\t * @function getSpectrum()\n\t * Return the i-th sub-spectra in the current spectrum\n\t * @param i\n\t * @returns {this.sd.spectra[i]}\n\t */\n\tSD.prototype.getSpectrum=function(i) {\n\t    i=i||this.activeElement;\n\t    return this.sd.spectra[i];\n\t}\n\t\n\t/**\n\t * @function getNbSubSpectra()\n\t * Return the amount of sub-spectra in this object\n\t * @returns {*}\n\t */\n\tSD.prototype.getNbSubSpectra=function(){\n\t    return this.sd.spectra.length;\n\t}\n\t\n\t/**\n\t * @function getXData()\n\t *  Returns an array containing the x values of the spectrum\n\t * @param i sub-spectrum Default:activeSpectrum\n\t * @returns {Array}\n\t */\n\tSD.prototype.getXData=function(i){\n\t    return this.getSpectrumData(i).x;\n\t}\n\t\n\t/**\n\t * @function getYData()\n\t * This function returns a double array containing the values with the intensities for the current sub-spectrum.\n\t * @param i sub-spectrum Default:activeSpectrum\n\t * @returns {Array}\n\t */\n\tSD.prototype.getYData=function(i){\n\t    return this.getSpectrumData(i).y;\n\t}\n\t\n\t/**\n\t * @function getX()\n\t * Returns the x value at the specified index for the active sub-spectrum.\n\t * @param i array index between 0 and spectrum.getNbPoints()-1\n\t * @returns {number}\n\t */\n\tSD.prototype.getX=function(i){\n\t    return this.getXData()[i];\n\t}\n\t\n\t/**\n\t * @function getY()\n\t * Returns the y value at the specified index for the active sub-spectrum.\n\t * @param i array index between 0 and spectrum.getNbPoints()-1\n\t * @returns {number}\n\t */\n\tSD.prototype.getY=function(i){\n\t    return this.getYData()[i];\n\t}\n\t\n\t/**\n\t * @function getXYData();\n\t * Returns a double[2][nbPoints] where the first row contains the x values and the second row the y values.\n\t * @param i sub-spectrum Default:activeSpectrum\n\t * @returns {*[]}\n\t */\n\tSD.prototype.getXYData=function(i){\n\t    return [this.getXData(i),this.getYData(i)];\n\t}\n\t\n\t/**\n\t * @function getTitle\n\t * Return the title of the current spectrum.\n\t * @param i sub-spectrum Default:activeSpectrum\n\t * @returns {*}\n\t */\n\tSD.prototype.getTitle=function(i) {\n\t    return this.getSpectrum(i).title;\n\t}\n\t\n\t/**\n\t * @function setTitle(newTitle);\n\t * Set the title of this spectrum.\n\t * @param newTitle The new title\n\t * @param i sub-spectrum Default:activeSpectrum\n\t */\n\tSD.prototype.setTitle=function(newTitle,i) {\n\t    this.getSpectrum(i).title=newTitle;\n\t}\n\t\n\t/**\n\t * @function getMinY(i)\n\t * This function returns the minimal value of Y\n\t * @param i sub-spectrum Default:activeSpectrum\n\t * @returns {number}\n\t */\n\tSD.prototype.getMinY=function(i) {\n\t    return  StatArray.min(this.getYData(i));\n\t}\n\t\n\t/**\n\t * @function getMaxY(i)\n\t * This function returns the maximal value of Y\n\t * @param i sub-spectrum Default:activeSpectrum\n\t * @returns {number}\n\t */\n\tSD.prototype.getMaxY=function(i) {\n\t    return  StatArray.max(this.getYData(i));\n\t}\n\t\n\t/**\n\t * @function getMinMax(i)\n\t * Return the min and max value of Y\n\t * @param i sub-spectrum Default:activeSpectrum\n\t * @returns {{min, max}|*}\n\t */\n\tSD.prototype.getMinMaxY=function(i) {\n\t    return  StatArray.minMax(this.getYData(i));\n\t}\n\t\n\t\n\t/**\n\t * @function getNoiseLevel()\n\t * Get the noise threshold level of the current spectrum. It uses median instead of the mean\n\t * @returns {number}\n\t */\n\tSD.prototype.getNoiseLevel=function(){\n\t    var mean = 0,stddev=0;\n\t    var y = this.getYData();\n\t    var length = this.getNbPoints(),i=0;\n\t    for(i = 0; i < length; i++){\n\t        mean+=y[i];\n\t    }\n\t    mean/=this.getNbPoints();\n\t    var averageDeviations = new Array(length);\n\t    for (i = 0; i < length; i++)\n\t        averageDeviations[i] = Math.abs(y[i] - mean);\n\t    averageDeviations.sort();\n\t    if (length % 2 == 1) {\n\t        stddev = averageDeviations[(length-1)/2] / 0.6745;\n\t    } else {\n\t        stddev = 0.5*(averageDeviations[length/2]+averageDeviations[length/2-1]) / 0.6745;\n\t    }\n\t\n\t    return stddev*this.getNMRPeakThreshold(this.getNucleus(1));\n\t}\n\t\n\t/**\n\t * @function arrayPointToUnits(doublePoint)\n\t * Return the xValue for the given index.\n\t * @param doublePoint\n\t * @returns {number}\n\t */\n\tSD.prototype.arrayPointToUnits=function(doublePoint){\n\t    return (this.getFirstX() - (doublePoint* (this.getFirstX() - this.getLastX()) / (this.getNbPoints()-1)));\n\t}\n\t\n\t/**\n\t * @function unitsToArrayPoint(inValue)\n\t * Returns the index-value for the data array corresponding to a X-value in\n\t * units for the element of spectraData to which it is linked (spectraNb).\n\t * This method makes use of spectraData.getFirstX(), spectraData.getLastX()\n\t * and spectraData.getNbPoints() to derive the return value if it of data class XY\n\t * It performs a binary search if the spectrum is a peak table\n\t * @param inValue\n\t *            (value in Units to be converted)\n\t * @return {number} An integer representing the index value of the inValue\n\t */\n\tSD.prototype.unitsToArrayPoint=function(inValue){\n\t    if (this.isDataClassXY()) {\n\t        return Math.round((this.getFirstX() - inValue) * (-1.0 / this.getDeltaX()));\n\t    } else if (this.isDataClassPeak())\n\t    {\n\t        var currentArrayPoint = 0,upperLimit=this.getNbPoints()-1, lowerLimit=0, midPoint;\n\t        //If inverted scale\n\t        if(this.getFirstX()>this.getLastX()){\n\t            upperLimit=0;\n\t            lowerLimit=this.getNbPoints()-1;\n\t\n\t            if(inValue>this.getFirstX())\n\t                return this.getNbPoints();\n\t            if(inValue<this.getLastX())\n\t                return -1;\n\t        }\n\t        else{\n\t            if(inValue<this.getFirstX())\n\t                return -1;\n\t            if(inValue>this.getLastX())\n\t                return this.getNbPoints();\n\t        }\n\t\n\t        while (Math.abs(upperLimit-lowerLimit) > 1)\n\t        {\n\t            midPoint=Math.round(Math.floor((upperLimit+lowerLimit)/2));\n\t            //x=this.getX(midPoint);\n\t            if(this.getX(midPoint)==inValue)\n\t                return midPoint;\n\t            if(this.getX(midPoint)>inValue)\n\t                upperLimit=midPoint;\n\t            else\n\t                lowerLimit=midPoint;\n\t        }\n\t        currentArrayPoint=lowerLimit;\n\t        if(Math.abs(this.getX(lowerLimit)-inValue)>Math.abs(this.getX(upperLimit)-inValue))\n\t            currentArrayPoint=upperLimit;\n\t        return currentArrayPoint;\n\t    } else {\n\t        return 0;\n\t    }\n\t}\n\t\n\t/**\n\t * @function getDeltaX()\n\t * Returns the separation between 2 consecutive points in the spectrum domain\n\t * @returns {number}\n\t */\n\tSD.prototype.getDeltaX=function(){\n\t    return (this.getLastX()-this.getFirstX()) / (this.getNbPoints()-1);\n\t}\n\t\n\t/**\n\t * @function setMinMax(min,max)\n\t * This function scales the values of Y between the min and max parameters\n\t * @param min   Minimum desired value for Y\n\t * @param max   Maximum desired value for Y\n\t */\n\tSD.prototype.setMinMax=function(min,max) {\n\t    var y = this.getYData();\n\t    var minMax = StatArray.minMax(y);\n\t    var factor = (max - min)/(minMax.max-minMax.min);\n\t    for(var i=0;i< y.length;i++){\n\t        y[i]=(y[i]-minMax.min)*factor+min;\n\t    }\n\t}\n\t\n\t/**\n\t * @function setMin(min)\n\t * This function scales the values of Y to fit the min parameter\n\t * @param min   Minimum desired value for Y\n\t */\n\tSD.prototype.setMin=function(min) {\n\t    var y = this.getYData();\n\t    var currentMin = StatArray.min(y);\n\t    var factor = min/currentMin;\n\t    for(var i=0;i< y.length;i++){\n\t        y[i]*=factor;\n\t    }\n\t}\n\t\n\t/**\n\t * @function setMax(max)\n\t * This function scales the values of Y to fit the max parameter\n\t * @param max   Maximum desired value for Y\n\t */\n\tSD.prototype.setMax=function(max) {\n\t    var y = this.getYData();\n\t    var currentMin = StatArray.max(y);\n\t    var factor = max/currentMin;\n\t    for(var i=0;i< y.length;i++){\n\t        y[i]*=factor;\n\t    }\n\t}\n\t\n\t/**\n\t * @function YShift(value)\n\t * This function shifts the values of Y\n\t * @param value Distance of the shift\n\t */\n\tSD.prototype.YShift=function(value) {\n\t    var y = this.getSpectrumData().y;\n\t    var length = this.getNbPoints(),i=0;\n\t    for(i=0;i<length;i++){\n\t        y[i]+=value;\n\t    }\n\t    this.getSpectrum().firstY+=value;\n\t    this.getSpectrum().lastY+=value;\n\t}\n\t\n\t/**\n\t * @function shift(globalShift)\n\t * This function shift the given spectraData. After this function is applied, all the peaks in the\n\t * spectraData will be found at xi+globalShift\n\t * @param globalShift\n\t */\n\tSD.prototype.shift=function(globalShift) {\n\t    for(var i=0;i<this.getNbSubSpectra();i++){\n\t        this.setActiveElement(i);\n\t        var x = this.getSpectrumData().x;\n\t        var length = this.getNbPoints(),i=0;\n\t        for(i=0;i<length;i++){\n\t            x[i]+=globalShift;\n\t        }\n\t\n\t        this.getSpectrum().firstX+=globalShift;\n\t        this.getSpectrum().lastX+=globalShift;\n\t    }\n\t\n\t}\n\t\n\t/**\n\t * @function fillWith(from, to, value)\n\t * This function fills a zone of the spectrum with the given value.\n\t * @param from\n\t * @param to\n\t * @param fillWith\n\t */\n\tSD.prototype.fillWith=function(from, to, value) {\n\t    var tmp, start, end, x, y;\n\t    if(from > to) {\n\t        var tmp = from;\n\t        from = to;\n\t        to = tmp;\n\t    }\n\t\n\t    for(var i=0;i<this.getNbSubSpectra();i++){\n\t        this.setActiveElement(i);\n\t        x = this.getXData();\n\t        y = this.getYData();\n\t        start = this.unitsToArrayPoint(from);\n\t        end = this.unitsToArrayPoint(to);\n\t        if(start > end){\n\t            tmp = start;\n\t            start = end;\n\t            end = tmp;\n\t        }\n\t        if(start<0)\n\t            start=0;\n\t        if(end>=this.getNbPoints)\n\t            end=this.getNbPoints-1;\n\t        for(i=start;i<=end;i++){\n\t                y[i]=value;\n\t        }\n\t    }\n\t}\n\t\n\t/**\n\t * @function suppressZone(from, to)\n\t * This function suppress a zone from the given spectraData within the given x range.\n\t * Returns a spectraData of type PEAKDATA without peaks in the given region\n\t * @param from\n\t * @param to\n\t */\n\tSD.prototype.suppressZone=function(from, to) {\n\t    var tmp, start, end, x, y;\n\t    if(from > to) {\n\t        var tmp = from;\n\t        from = to;\n\t        to = tmp;\n\t    }\n\t\n\t    for(var i=0;i<this.getNbSubSpectra();i++){\n\t        this.setActiveElement(i);\n\t        x = this.getXData();\n\t        y = this.getYData();\n\t        start = this.unitsToArrayPoint(from);\n\t        end = this.unitsToArrayPoint(to);\n\t        if(start > end){\n\t            tmp = start;\n\t            start = end;\n\t            end = tmp;\n\t        }\n\t        if(start<0)\n\t            start=0;\n\t        if(end>=this.getNbPoints)\n\t            end=this.getNbPoints-1;\n\t        for(i=end;i>=start;i--){\n\t            y.splice(i,1);\n\t            x.splice(i,1);\n\t        }\n\t    }\n\t    this.setDataClass(this.DATACLASS_PEAK);\n\t}\n\t\n\t\n\t/**\n\t * @function peakPicking(parameters)\n\t * This function performs a simple peak detection in a spectraData. The parameters that can be specified are:\n\t * Returns a two dimensional array of double specifying [x,y] of the detected peaks.\n\t * @option from:    Lower limit.\n\t * @option to:      Upper limit.\n\t * @option threshold: The minimum intensity to consider a peak as a signal, expressed as a percentage of the highest peak.\n\t * @option stdev: Number of standard deviation of the noise for the threshold calculation if a threshold is not specified.\n\t * @option resolution: The maximum resolution of the spectrum for considering peaks.\n\t * @option yInverted: Is it a Y inverted spectrum?(like an IR spectrum)\n\t * @option smooth: A function for smoothing the spectraData before the detection. If your are dealing with\n\t * experimental spectra, smoothing will make the algorithm less prune to false positives.\n\t */\n\tSD.prototype.simplePeakPicking=function(parameters) {\n\t    //@TODO implements this filter\n\t}\n\t\n\t/**\n\t * @function getMaxPeak()\n\t * Get the maximum peak\n\t * @returns {[x, y]}\n\t */\n\tSD.prototype.getMaxPeak = function(){\n\t    var y = this.getSpectraDataY();\n\t    var max=y[0], index=0;\n\t    for(var i=0;i< y.length;i++){\n\t        if(max<y[i]){\n\t            max = y[i];\n\t            index=i;\n\t        }\n\t    }\n\t    return [this.getX(index),max];\n\t}\n\t\n\t/**\n\t * @function getParamDouble(name, defvalue);\n\t * Get the value of the parameter\n\t * @param  name The parameter name\n\t * @param  defvalue The default value\n\t * @returns {number}\n\t */\n\tSD.prototype.getParamDouble = function(name, defvalue){\n\t    var value = this.sd.info[name];\n\t    if(!value)\n\t        value = defvalue;\n\t    return value;\n\t}\n\t\n\t/**\n\t * @function getParamString(name, defvalue);\n\t * Get the value of the parameter\n\t * @param  name The parameter name\n\t * @param  defvalue The default value\n\t * @returns {string}\n\t */\n\tSD.prototype.getParamString = function(name, defvalue){\n\t    var value = this.sd.info[name];\n\t    if(!value)\n\t        value = defvalue;\n\t    return value+\"\";\n\t}\n\t\n\t/**\n\t * @function getParamInt(name, defvalue);\n\t * Get the value of the parameter\n\t * @param  name The parameter name\n\t * @param  defvalue The default value\n\t * @returns {number}\n\t */\n\tSD.prototype.getParamInt = function(name, defvalue){\n\t    var value = this.sd.info[name];\n\t    if(!value)\n\t        value = defvalue;\n\t    return value;\n\t}\n\t\n\t/**\n\t * @function getParam(name, defvalue);\n\t * Get the value of the parameter\n\t * @param  name The parameter name\n\t * @param  defvalue The default value\n\t * @returns {*}\n\t */\n\tSD.prototype.getParam = function(name, defvalue){\n\t    var value = this.sd.info[name];\n\t    if(!value)\n\t        value = defvalue;\n\t    return value;\n\t}\n\t\n\t/**\n\t * @function containsParam(name)\n\t *True if the spectrum.info contains the given parameter\n\t * @param name\n\t * @returns {boolean}\n\t */\n\tSD.prototype.containsParam = function(name){\n\t    if(this.sd.info[name]){\n\t        return true;\n\t    }\n\t    return false;\n\t}\n\t\n\t/**\n\t * @function getSpectraDataY()\n\t * Return the y elements of the current spectrum. Same as getYData. Kept for backward compatibility.\n\t * @returns {Array}\n\t */\n\tSD.prototype.getSpectraDataY = function(){\n\t    return this.getYData();\n\t}\n\t\n\t/**\n\t * @function getSpectraDataX()\n\t * Return the x elements of the current spectrum. Same as getXData. Kept for backward compatibility.\n\t * @returns {Array}\n\t */\n\tSD.prototype.getSpectraDataX = function(){\n\t    return this.getXData();\n\t}\n\t\n\t/**\n\t * @function resetMinMax()\n\t * Update min max values of X and Yaxis.\n\t */\n\tSD.prototype.resetMinMax = function(){\n\t    //TODO Impelement this function\n\t}\n\t\n\t/**\n\t * @function putParam(name, value)\n\t * Set a new parameter to this spectrum\n\t * @param name\n\t * @param value\n\t */\n\tSD.prototype.putParam = function(name, value){\n\t    this.sd.info[name]=value;\n\t}\n\t\n\t/**\n\t * @function getArea(from, to)\n\t * This function returns the area under the spectrum in the given window\n\t * @param from in spectrum units\n\t * @param to in spectrum units\n\t * @returns {number}\n\t */\n\tSD.prototype.getArea = function(from, to){\n\t    var i0 = this.unitsToArrayPoint(from);\n\t    var ie = this.unitsToArrayPoint(to);\n\t    var area = 0;\n\t    if(i0>ie){\n\t        var tmp = i0;\n\t        i0 = ie;\n\t        ie = tmp;\n\t    }\n\t    i0=i0<0?0:i0;\n\t    ie=ie>=this.getNbPoints()?this.getNbPoints()-1:ie;\n\t    for(var i=i0;i<ie;i++){\n\t        area+= this.getY(i);\n\t    }\n\t    return area*Math.abs(this.getDeltaX());\n\t},\n\t\n\t/**\n\t * @function getVector(from, to, nPoints)\n\t * Returns a equally spaced vector within the given window.\n\t * @param from in spectrum units\n\t * @param to in spectrum units\n\t * @param nPoints number of points to return(!!!sometimes it is not possible to return exactly the required nbPoints)\n\t * @returns [x,y]\n\t */\n\tSD.prototype.getVector = function(from, to, nPoints){\n\t    var x = this.getSpectraDataX();\n\t    var y = this.getSpectraDataY();\n\t    var result = [];\n\t    var start = 0, end = x.length- 1,direction=1;\n\t    var reversed = false;\n\t\n\t    if(x[0]>x[1]){\n\t        direction = -1;\n\t        start= x.length-1;\n\t        end = 0;\n\t    }\n\t\n\t    if(from > to){\n\t        var tmp = from;\n\t        from = to;\n\t        to = tmp;\n\t        reversed = true;\n\t    }\n\t    //console.log(x[end]+\" \"+from+\" \"+x[start]+\" \"+to);\n\t    if(x[start]>to||x[end]<from){\n\t        //console.log(\"ssss\");\n\t        return [];\n\t    }\n\t\n\t    while(x[start]<from){start+=direction;}\n\t    while(x[end]>to){end-=direction;}\n\t\n\t    var winPoints = Math.abs(end-start)+1;\n\t    if(!nPoints){\n\t        nPoints = winPoints;\n\t    }\n\t    var xwin = new Array(nPoints);\n\t    var ywin = new Array(nPoints);\n\t    var index = 0;\n\t\n\t    if(direction==-1)\n\t        index=nPoints-1;\n\t\n\t    var di = winPoints/nPoints;\n\t    var i=start-direction;\n\t    for(var k=0;k<nPoints;k++) {\n\t        i += Math.round(di * direction);\n\t        //console.log(i+\" \"+y[i]);\n\t        xwin[index] = x[i];\n\t        ywin[index] = y[i];\n\t        index += direction;\n\t    }\n\t    return [xwin,ywin];\n\t}\n\t\n\t/**\n\t * @function is2D()\n\t * Is it a 2D spectrum?\n\t * @returns {boolean}\n\t */\n\tSD.prototype.is2D = function(){\n\t    if(typeof this.sd.twoD == \"undefined\")\n\t        return false;\n\t    return this.sd.twoD;\n\t}\n\t\n\t/**\n\t * @function toJcamp(options)\n\t * This function creates a String that represents the given spectraData in the format JCAM-DX 5.0\n\t * The X,Y data can be compressed using one of the methods described in:\n\t * \"JCAMP-DX. A STANDARD FORMAT FOR THE EXCHANGE OF ION MOBILITY SPECTROMETRY DATA\",\n\t *  http://www.iupac.org/publications/pac/pdf/2001/pdf/7311x1765.pdf\n\t * @option encode: ['FIX','SQZ','DIF','DIFDUP','CVS','PAC'] (Default: 'DIFDUP')\n\t * @option yfactor: The YFACTOR. It allows to compress the data by removing digits from the ordinate. (Default: 1)\n\t * @option type: [\"NTUPLES\", \"SIMPLE\"] (Default: \"SIMPLE\")\n\t * @option keep: A set of user defined parameters of the given SpectraData to be stored in the jcamp.\n\t * @returns a string containing the jcamp-DX file\n\t * @example SD.toJcamp(spectraData,{encode:'DIFDUP',yfactor:0.01,type:\"SIMPLE\",keep:['#batchID','#url']});\n\t */\n\tSD.prototype.toJcamp=function(options) {\n\t    var defaultOptions = {\"encode\":\"DIFDUP\",\"yFactor\":1,\"type\":\"SIMPLE\",\"keep\":[]};\n\t    options = extend({}, defaultOptions, options);\n\t    return JcampCreator.convert(this, options.encode, options.yFactor, options.type, options.keep);\n\t}\n\t\n\t\n\tmodule.exports = SD;\n\t\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction compareNumbers(a, b) {\n\t    return a - b;\n\t}\n\t\n\t/**\n\t * Computes the sum of the given values\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.sum = function sum(values) {\n\t    var sum = 0;\n\t    for (var i = 0; i < values.length; i++) {\n\t        sum += values[i];\n\t    }\n\t    return sum;\n\t};\n\t\n\t/**\n\t * Computes the maximum of the given values\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.max = function max(values) {\n\t    var max = -Infinity;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        if (values[i] > max) max = values[i];\n\t    }\n\t    return max;\n\t};\n\t\n\t/**\n\t * Computes the minimum of the given values\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.min = function min(values) {\n\t    var min = Infinity;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        if (values[i] < min) min = values[i];\n\t    }\n\t    return min;\n\t};\n\t\n\t/**\n\t * Computes the min and max of the given values\n\t * @param {Array} values\n\t * @returns {{min: number, max: number}}\n\t */\n\texports.minMax = function minMax(values) {\n\t    var min = Infinity;\n\t    var max = -Infinity;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        if (values[i] < min) min = values[i];\n\t        if (values[i] > max) max = values[i];\n\t    }\n\t    return {\n\t        min: min,\n\t        max: max\n\t    };\n\t};\n\t\n\t/**\n\t * Computes the arithmetic mean of the given values\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.arithmeticMean = function arithmeticMean(values) {\n\t    var sum = 0;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        sum += values[i];\n\t    }\n\t    return sum / l;\n\t};\n\t\n\t/**\n\t * {@link arithmeticMean}\n\t */\n\texports.mean = exports.arithmeticMean;\n\t\n\t/**\n\t * Computes the geometric mean of the given values\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.geometricMean = function geometricMean(values) {\n\t    var mul = 1;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        mul *= values[i];\n\t    }\n\t    return Math.pow(mul, 1 / l);\n\t};\n\t\n\t/**\n\t * Computes the mean of the log of the given values\n\t * If the return value is exponentiated, it gives the same result as the\n\t * geometric mean.\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.logMean = function logMean(values) {\n\t    var lnsum = 0;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        lnsum += Math.log(values[i]);\n\t    }\n\t    return lnsum / l;\n\t};\n\t\n\t/**\n\t * Computes the weighted grand mean for a list of means and sample sizes\n\t * @param {Array} means - Mean values for each set of samples\n\t * @param {Array} samples - Number of original values for each set of samples\n\t * @returns {number}\n\t */\n\texports.grandMean = function grandMean(means, samples) {\n\t    var sum = 0;\n\t    var n = 0;\n\t    var l = means.length;\n\t    for (var i = 0; i < l; i++) {\n\t        sum += samples[i] * means[i];\n\t        n += samples[i];\n\t    }\n\t    return sum / n;\n\t};\n\t\n\t/**\n\t * Computes the truncated mean of the given values using a given percentage\n\t * @param {Array} values\n\t * @param {number} percent - The percentage of values to keep (range: [0,1])\n\t * @param {boolean} [alreadySorted=false]\n\t * @returns {number}\n\t */\n\texports.truncatedMean = function truncatedMean(values, percent, alreadySorted) {\n\t    if (alreadySorted === undefined) alreadySorted = false;\n\t    if (!alreadySorted) {\n\t        values = values.slice().sort(compareNumbers);\n\t    }\n\t    var l = values.length;\n\t    var k = Math.floor(l * percent);\n\t    var sum = 0;\n\t    for (var i = k; i < (l - k); i++) {\n\t        sum += values[i];\n\t    }\n\t    return sum / (l - 2 * k);\n\t};\n\t\n\t/**\n\t * Computes the harmonic mean of the given values\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.harmonicMean = function harmonicMean(values) {\n\t    var sum = 0;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        if (values[i] === 0) {\n\t            throw new RangeError('value at index ' + i + 'is zero');\n\t        }\n\t        sum += 1 / values[i];\n\t    }\n\t    return l / sum;\n\t};\n\t\n\t/**\n\t * Computes the contraharmonic mean of the given values\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.contraHarmonicMean = function contraHarmonicMean(values) {\n\t    var r1 = 0;\n\t    var r2 = 0;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        r1 += values[i] * values[i];\n\t        r2 += values[i];\n\t    }\n\t    if (r2 < 0) {\n\t        throw new RangeError('sum of values is negative');\n\t    }\n\t    return r1 / r2;\n\t};\n\t\n\t/**\n\t * Computes the median of the given values\n\t * @param {Array} values\n\t * @param {boolean} [alreadySorted=false]\n\t * @returns {number}\n\t */\n\texports.median = function median(values, alreadySorted) {\n\t    if (alreadySorted === undefined) alreadySorted = false;\n\t    if (!alreadySorted) {\n\t        values = values.slice().sort(compareNumbers);\n\t    }\n\t    var l = values.length;\n\t    var half = Math.floor(l / 2);\n\t    if (l % 2 === 0) {\n\t        return (values[half - 1] + values[half]) * 0.5;\n\t    } else {\n\t        return values[half];\n\t    }\n\t};\n\t\n\t/**\n\t * Computes the variance of the given values\n\t * @param {Array} values\n\t * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n\t * @returns {number}\n\t */\n\texports.variance = function variance(values, unbiased) {\n\t    if (unbiased === undefined) unbiased = true;\n\t    var theMean = exports.mean(values);\n\t    var theVariance = 0;\n\t    var l = values.length;\n\t\n\t    for (var i = 0; i < l; i++) {\n\t        var x = values[i] - theMean;\n\t        theVariance += x * x;\n\t    }\n\t\n\t    if (unbiased) {\n\t        return theVariance / (l - 1);\n\t    } else {\n\t        return theVariance / l;\n\t    }\n\t};\n\t\n\t/**\n\t * Computes the standard deviation of the given values\n\t * @param {Array} values\n\t * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n\t * @returns {number}\n\t */\n\texports.standardDeviation = function standardDeviation(values, unbiased) {\n\t    return Math.sqrt(exports.variance(values, unbiased));\n\t};\n\t\n\texports.standardError = function standardError(values) {\n\t    return exports.standardDeviation(values) / Math.sqrt(values.length);\n\t};\n\t\n\texports.quartiles = function quartiles(values, alreadySorted) {\n\t    if (typeof(alreadySorted) === 'undefined') alreadySorted = false;\n\t    if (!alreadySorted) {\n\t        values = values.slice();\n\t        values.sort(compareNumbers);\n\t    }\n\t\n\t    var quart = values.length / 4;\n\t    var q1 = values[Math.ceil(quart) - 1];\n\t    var q2 = exports.median(values, true);\n\t    var q3 = values[Math.ceil(quart * 3) - 1];\n\t\n\t    return {q1: q1, q2: q2, q3: q3};\n\t};\n\t\n\texports.pooledStandardDeviation = function pooledStandardDeviation(samples, unbiased) {\n\t    return Math.sqrt(exports.pooledVariance(samples, unbiased));\n\t};\n\t\n\texports.pooledVariance = function pooledVariance(samples, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') unbiased = true;\n\t    var sum = 0;\n\t    var length = 0, l = samples.length;\n\t    for (var i = 0; i < l; i++) {\n\t        var values = samples[i];\n\t        var vari = exports.variance(values);\n\t\n\t        sum += (values.length - 1) * vari;\n\t\n\t        if (unbiased)\n\t            length += values.length - 1;\n\t        else\n\t            length += values.length;\n\t    }\n\t    return sum / length;\n\t};\n\t\n\texports.mode = function mode(values) {\n\t    var l = values.length,\n\t        itemCount = new Array(l),\n\t        i;\n\t    for (i = 0; i < l; i++) {\n\t        itemCount[i] = 0;\n\t    }\n\t    var itemArray = new Array(l);\n\t    var count = 0;\n\t\n\t    for (i = 0; i < l; i++) {\n\t        var index = itemArray.indexOf(values[i]);\n\t        if (index >= 0)\n\t            itemCount[index]++;\n\t        else {\n\t            itemArray[count] = values[i];\n\t            itemCount[count] = 1;\n\t            count++;\n\t        }\n\t    }\n\t\n\t    var maxValue = 0, maxIndex = 0;\n\t    for (i = 0; i < count; i++) {\n\t        if (itemCount[i] > maxValue) {\n\t            maxValue = itemCount[i];\n\t            maxIndex = i;\n\t        }\n\t    }\n\t\n\t    return itemArray[maxIndex];\n\t};\n\t\n\texports.covariance = function covariance(vector1, vector2, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') unbiased = true;\n\t    var mean1 = exports.mean(vector1);\n\t    var mean2 = exports.mean(vector2);\n\t\n\t    if (vector1.length !== vector2.length)\n\t        throw \"Vectors do not have the same dimensions\";\n\t\n\t    var cov = 0, l = vector1.length;\n\t    for (var i = 0; i < l; i++) {\n\t        var x = vector1[i] - mean1;\n\t        var y = vector2[i] - mean2;\n\t        cov += x * y;\n\t    }\n\t\n\t    if (unbiased)\n\t        return cov / (l - 1);\n\t    else\n\t        return cov / l;\n\t};\n\t\n\texports.skewness = function skewness(values, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') unbiased = true;\n\t    var theMean = exports.mean(values);\n\t\n\t    var s2 = 0, s3 = 0, l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        var dev = values[i] - theMean;\n\t        s2 += dev * dev;\n\t        s3 += dev * dev * dev;\n\t    }\n\t    var m2 = s2 / l;\n\t    var m3 = s3 / l;\n\t\n\t    var g = m3 / (Math.pow(m2, 3 / 2.0));\n\t    if (unbiased) {\n\t        var a = Math.sqrt(l * (l - 1));\n\t        var b = l - 2;\n\t        return (a / b) * g;\n\t    }\n\t    else {\n\t        return g;\n\t    }\n\t};\n\t\n\texports.kurtosis = function kurtosis(values, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') unbiased = true;\n\t    var theMean = exports.mean(values);\n\t    var n = values.length, s2 = 0, s4 = 0;\n\t\n\t    for (var i = 0; i < n; i++) {\n\t        var dev = values[i] - theMean;\n\t        s2 += dev * dev;\n\t        s4 += dev * dev * dev * dev;\n\t    }\n\t    var m2 = s2 / n;\n\t    var m4 = s4 / n;\n\t\n\t    if (unbiased) {\n\t        var v = s2 / (n - 1);\n\t        var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n\t        var b = s4 / (v * v);\n\t        var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n\t\n\t        return a * b - 3 * c;\n\t    }\n\t    else {\n\t        return m4 / (m2 * m2) - 3;\n\t    }\n\t};\n\t\n\texports.entropy = function entropy(values, eps) {\n\t    if (typeof(eps) === 'undefined') eps = 0;\n\t    var sum = 0, l = values.length;\n\t    for (var i = 0; i < l; i++)\n\t        sum += values[i] * Math.log(values[i] + eps);\n\t    return -sum;\n\t};\n\t\n\texports.weightedMean = function weightedMean(values, weights) {\n\t    var sum = 0, l = values.length;\n\t    for (var i = 0; i < l; i++)\n\t        sum += values[i] * weights[i];\n\t    return sum;\n\t};\n\t\n\texports.weightedStandardDeviation = function weightedStandardDeviation(values, weights) {\n\t    return Math.sqrt(exports.weightedVariance(values, weights));\n\t};\n\t\n\texports.weightedVariance = function weightedVariance(values, weights) {\n\t    var theMean = exports.weightedMean(values, weights);\n\t    var vari = 0, l = values.length;\n\t    var a = 0, b = 0;\n\t\n\t    for (var i = 0; i < l; i++) {\n\t        var z = values[i] - theMean;\n\t        var w = weights[i];\n\t\n\t        vari += w * (z * z);\n\t        b += w;\n\t        a += w * w;\n\t    }\n\t\n\t    return vari * (b / (b * b - a));\n\t};\n\t\n\texports.center = function center(values, inPlace) {\n\t    if (typeof(inPlace) === 'undefined') inPlace = false;\n\t\n\t    var result = values;\n\t    if (!inPlace)\n\t        result = values.slice();\n\t\n\t    var theMean = exports.mean(result), l = result.length;\n\t    for (var i = 0; i < l; i++)\n\t        result[i] -= theMean;\n\t};\n\t\n\texports.standardize = function standardize(values, standardDev, inPlace) {\n\t    if (typeof(standardDev) === 'undefined') standardDev = exports.standardDeviation(values);\n\t    if (typeof(inPlace) === 'undefined') inPlace = false;\n\t    var l = values.length;\n\t    var result = inPlace ? values : new Array(l);\n\t    for (var i = 0; i < l; i++)\n\t        result[i] = values[i] / standardDev;\n\t    return result;\n\t};\n\t\n\texports.cumulativeSum = function cumulativeSum(array) {\n\t    var l = array.length;\n\t    var result = new Array(l);\n\t    result[0] = array[0];\n\t    for (var i = 1; i < l; i++)\n\t        result[i] = result[i - 1] + array[i];\n\t    return result;\n\t};\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar parseXYDataRegExp = __webpack_require__(6);\n\t\n\t\n\tfunction getConverter() {\n\t\n\t    // the following RegExp can only be used for XYdata, some peakTables have values with a \"E-5\" ...\n\t    var ntuplesSeparator = /[, \\t]{1,}/;\n\t\n\t    var GC_MS_FIELDS = ['TIC', '.RIC', 'SCANNUMBER'];\n\t\n\t    function convertToFloatArray(stringArray) {\n\t        var l = stringArray.length;\n\t        var floatArray = new Array(l);\n\t        for (var i = 0; i < l; i++) {\n\t            floatArray[i] = parseFloat(stringArray[i]);\n\t        }\n\t        return floatArray;\n\t    }\n\t    \n\t    function Spectrum() {\n\t        \n\t    }\n\t\n\t    /*\n\t     options.keepSpectra: keep the original spectra for a 2D\n\t     options.xy: true // create x / y array instead of a 1D array\n\t     options.keepRecordsRegExp: which fields do we keep\n\t     */\n\t\n\t    function convert(jcamp, options) {\n\t        options = options || {};\n\t\n\t        var keepRecordsRegExp = /^$/;\n\t        if (options.keepRecordsRegExp) keepRecordsRegExp = options.keepRecordsRegExp;\n\t\n\t        var start = Date.now();\n\t\n\t        var ntuples = {},\n\t            ldr,\n\t            dataLabel,\n\t            dataValue,\n\t            ldrs,\n\t            i, ii, position, endLine, infos;\n\t\n\t        var result = {};\n\t        result.profiling = [];\n\t        result.logs = [];\n\t        var spectra = [];\n\t        result.spectra = spectra;\n\t        result.info = {};\n\t        var spectrum = new Spectrum();\n\t\n\t        if (!(typeof jcamp === 'string')) return result;\n\t        // console.time('start');\n\t\n\t        if (result.profiling) result.profiling.push({\n\t            action: 'Before split to LDRS',\n\t            time: Date.now() - start\n\t        });\n\t\n\t        ldrs = jcamp.split(/[\\r\\n]+##/);\n\t\n\t        if (result.profiling) result.profiling.push({\n\t            action: 'Split to LDRS',\n\t            time: Date.now() - start\n\t        });\n\t\n\t        if (ldrs[0]) ldrs[0] = ldrs[0].replace(/^[\\r\\n ]*##/, '');\n\t\n\t        for (i = 0, ii = ldrs.length; i < ii; i++) {\n\t            ldr = ldrs[i];\n\t            // This is a new LDR\n\t            position = ldr.indexOf('=');\n\t            if (position > 0) {\n\t                dataLabel = ldr.substring(0, position);\n\t                dataValue = ldr.substring(position + 1).trim();\n\t            } else {\n\t                dataLabel = ldr;\n\t                dataValue = '';\n\t            }\n\t            dataLabel = dataLabel.replace(/[_ -]/g, '').toUpperCase();\n\t\n\t            if (dataLabel === 'DATATABLE') {\n\t                endLine = dataValue.indexOf('\\n');\n\t                if (endLine === -1) endLine = dataValue.indexOf('\\r');\n\t                if (endLine > 0) {\n\t                    var xIndex = -1;\n\t                    var yIndex = -1;\n\t                    // ##DATA TABLE= (X++(I..I)), XYDATA\n\t                    // We need to find the variables\n\t\n\t                    infos = dataValue.substring(0, endLine).split(/[ ,;\\t]+/);\n\t                    if (infos[0].indexOf('++') > 0) {\n\t                        var firstVariable = infos[0].replace(/.*\\(([a-zA-Z0-9]+)\\+\\+.*/, '$1');\n\t                        var secondVariable = infos[0].replace(/.*\\.\\.([a-zA-Z0-9]+).*/, '$1');\n\t                        xIndex = ntuples.symbol.indexOf(firstVariable);\n\t                        yIndex = ntuples.symbol.indexOf(secondVariable);\n\t                    }\n\t\n\t                    if (xIndex === -1) xIndex = 0;\n\t                    if (yIndex === -1) yIndex = 0;\n\t\n\t                    if (ntuples.first) {\n\t                        if (ntuples.first.length > xIndex) spectrum.firstX = ntuples.first[xIndex];\n\t                        if (ntuples.first.length > yIndex) spectrum.firstY = ntuples.first[yIndex];\n\t                    }\n\t                    if (ntuples.last) {\n\t                        if (ntuples.last.length > xIndex) spectrum.lastX = ntuples.last[xIndex];\n\t                        if (ntuples.last.length > yIndex) spectrum.lastY = ntuples.last[yIndex];\n\t                    }\n\t                    if (ntuples.vardim && ntuples.vardim.length > xIndex) {\n\t                        spectrum.nbPoints = ntuples.vardim[xIndex];\n\t                    }\n\t                    if (ntuples.factor) {\n\t                        if (ntuples.factor.length > xIndex) spectrum.xFactor = ntuples.factor[xIndex];\n\t                        if (ntuples.factor.length > yIndex) spectrum.yFactor = ntuples.factor[yIndex];\n\t                    }\n\t                    if (ntuples.units) {\n\t                        if (ntuples.units.length > xIndex) spectrum.xUnit = ntuples.units[xIndex];\n\t                        if (ntuples.units.length > yIndex) spectrum.yUnit = ntuples.units[yIndex];\n\t                    }\n\t                    spectrum.datatable = infos[0];\n\t                    if (infos[1] && infos[1].indexOf('PEAKS') > -1) {\n\t                        dataLabel = 'PEAKTABLE';\n\t                    } else if (infos[1] && (infos[1].indexOf('XYDATA') || infos[0].indexOf('++') > 0)) {\n\t                        dataLabel = 'XYDATA';\n\t                        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n\t                    }\n\t                }\n\t            }\n\t\n\t\n\t            if (dataLabel === 'TITLE') {\n\t                spectrum.title = dataValue;\n\t            } else if (dataLabel === 'DATATYPE') {\n\t                spectrum.dataType = dataValue;\n\t                if (dataValue.indexOf('nD') > -1) {\n\t                    result.twoD = true;\n\t                }\n\t            } else if (dataLabel === 'NTUPLES') {\n\t                if (dataValue.indexOf('nD') > -1) {\n\t                    result.twoD = true;\n\t                }\n\t            } else if (dataLabel === 'XUNITS') {\n\t                spectrum.xUnit = dataValue;\n\t            } else if (dataLabel === 'YUNITS') {\n\t                spectrum.yUnit = dataValue;\n\t            } else if (dataLabel === 'FIRSTX') {\n\t                spectrum.firstX = parseFloat(dataValue);\n\t            } else if (dataLabel === 'LASTX') {\n\t                spectrum.lastX = parseFloat(dataValue);\n\t            } else if (dataLabel === 'FIRSTY') {\n\t                spectrum.firstY = parseFloat(dataValue);\n\t            } else if (dataLabel === 'LASTY') {\n\t                spectrum.lastY = parseFloat(dataValue);\n\t            } else if (dataLabel === 'NPOINTS') {\n\t                spectrum.nbPoints = parseFloat(dataValue);\n\t            } else if (dataLabel === 'XFACTOR') {\n\t                spectrum.xFactor = parseFloat(dataValue);\n\t            } else if (dataLabel === 'YFACTOR') {\n\t                spectrum.yFactor = parseFloat(dataValue);\n\t            } else if (dataLabel === 'DELTAX') {\n\t                spectrum.deltaX = parseFloat(dataValue);\n\t            } else if (dataLabel === '.OBSERVEFREQUENCY' || dataLabel === '$SFO1') {\n\t                if (!spectrum.observeFrequency) spectrum.observeFrequency = parseFloat(dataValue);\n\t            } else if (dataLabel === '.OBSERVENUCLEUS') {\n\t                if (!spectrum.xType) result.xType = dataValue.replace(/[^a-zA-Z0-9]/g, '');\n\t            } else if (dataLabel === '$SFO2') {\n\t                if (!result.indirectFrequency) result.indirectFrequency = parseFloat(dataValue);\n\t\n\t            } else if (dataLabel === '$OFFSET') {   // OFFSET for Bruker spectra\n\t                result.shiftOffsetNum = 0;\n\t                if (!result.shiftOffsetVal)  result.shiftOffsetVal = parseFloat(dataValue);\n\t            } else if (dataLabel === '$REFERENCEPOINT') {   // OFFSET for Varian spectra\n\t\n\t\n\t                // if we activate this part it does not work for ACD specmanager\n\t                //         } else if (dataLabel=='.SHIFTREFERENCE') {   // OFFSET FOR Bruker Spectra\n\t                //                 var parts = dataValue.split(/ *, */);\n\t                //                 result.shiftOffsetNum = parseInt(parts[2].trim());\n\t                //                 result.shiftOffsetVal = parseFloat(parts[3].trim());\n\t            } else if (dataLabel === 'VARNAME') {\n\t                ntuples.varname = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'SYMBOL') {\n\t                ntuples.symbol = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'VARTYPE') {\n\t                ntuples.vartype = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'VARFORM') {\n\t                ntuples.varform = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'VARDIM') {\n\t                ntuples.vardim = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'UNITS') {\n\t                ntuples.units = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'FACTOR') {\n\t                ntuples.factor = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'FIRST') {\n\t                ntuples.first = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'LAST') {\n\t                ntuples.last = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'MIN') {\n\t                ntuples.min = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'MAX') {\n\t                ntuples.max = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === '.NUCLEUS') {\n\t                if (result.twoD) {\n\t                    result.yType = dataValue.split(ntuplesSeparator)[0];\n\t                }\n\t            } else if (dataLabel === 'PAGE') {\n\t                spectrum.page = dataValue.trim();\n\t                spectrum.pageValue = parseFloat(dataValue.replace(/^.*=/, ''));\n\t                spectrum.pageSymbol = spectrum.page.replace(/=.*/, '');\n\t                var pageSymbolIndex = ntuples.symbol.indexOf(spectrum.pageSymbol);\n\t                var unit = '';\n\t                if (ntuples.units && ntuples.units[pageSymbolIndex]) {\n\t                    unit = ntuples.units[pageSymbolIndex];\n\t                }\n\t                if (result.indirectFrequency && unit !== 'PPM') {\n\t                    spectrum.pageValue /= result.indirectFrequency;\n\t                }\n\t            } else if (dataLabel === 'RETENTIONTIME') {\n\t                spectrum.pageValue = parseFloat(dataValue);\n\t            } else if (dataLabel === 'XYDATA') {\n\t                prepareSpectrum(result, spectrum);\n\t                // well apparently we should still consider it is a PEAK TABLE if there are no '++' after\n\t                if (dataValue.match(/.*\\+\\+.*/)) {\n\t                    if (options.fastParse === false) {\n\t                        parseXYDataRegExp(spectrum, dataValue, result);\n\t                    } else {\n\t                        if (!spectrum.deltaX) {\n\t                            spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n\t                        }\n\t                        fastParseXYData(spectrum, dataValue, result);\n\t                    }\n\t                } else {\n\t                    parsePeakTable(spectrum, dataValue, result);\n\t                }\n\t                spectra.push(spectrum);\n\t                spectrum = new Spectrum();\n\t            } else if (dataLabel === 'PEAKTABLE') {\n\t                prepareSpectrum(result, spectrum);\n\t                parsePeakTable(spectrum, dataValue, result);\n\t                spectra.push(spectrum);\n\t                spectrum = new Spectrum();\n\t            } else if (isMSField(dataLabel)) {\n\t                spectrum[convertMSFieldToLabel(dataLabel)] = dataValue;\n\t            }\n\t            if (dataLabel.match(keepRecordsRegExp)) {\n\t                result.info[dataLabel] = dataValue.trim();\n\t            }\n\t        }\n\t\n\t        if (result.profiling) result.profiling.push({\n\t            action: 'Finished parsing',\n\t            time: Date.now() - start\n\t        });\n\t\n\t        if (Object.keys(ntuples).length > 0) {\n\t            var newNtuples = [];\n\t            var keys = Object.keys(ntuples);\n\t            for (var i = 0; i < keys.length; i++) {\n\t                var key = keys[i];\n\t                var values = ntuples[key];\n\t                for (var j = 0; j < values.length; j++) {\n\t                    if (!newNtuples[j]) newNtuples[j] = {};\n\t                    newNtuples[j][key] = values[j];\n\t                }\n\t            }\n\t            result.ntuples = newNtuples;\n\t        }\n\t\n\t        if (result.twoD) {\n\t            add2D(result, options);\n\t            if (result.profiling) result.profiling.push({\n\t                action: 'Finished countour plot calculation',\n\t                time: Date.now() - start\n\t            });\n\t            if (!options.keepSpectra) {\n\t                delete result.spectra;\n\t            }\n\t        }\n\t\n\t        var isGCMS = (spectra.length > 1 && (!spectra[0].dataType || spectra[0].dataType.match(/.*mass.*/i)));\n\t        if (isGCMS && options.newGCMS) {\n\t            options.xy = true;\n\t        }\n\t\n\t        if (options.xy) { // the spectraData should not be a oneD array but an object with x and y\n\t            if (spectra.length > 0) {\n\t                for (var i = 0; i < spectra.length; i++) {\n\t                    var spectrum = spectra[i];\n\t                    if (spectrum.data.length > 0) {\n\t                        for (var j = 0; j < spectrum.data.length; j++) {\n\t                            var data = spectrum.data[j];\n\t                            var newData = {\n\t                                x: new Array(data.length / 2),\n\t                                y: new Array(data.length / 2)\n\t                            };\n\t                            for (var k = 0; k < data.length; k = k + 2) {\n\t                                newData.x[k / 2] = data[k];\n\t                                newData.y[k / 2] = data[k + 1];\n\t                            }\n\t                            spectrum.data[j] = newData;\n\t                        }\n\t\n\t                    }\n\t\n\t                }\n\t            }\n\t        }\n\t\n\t        // maybe it is a GC (HPLC) / MS. In this case we add a new format\n\t        if (isGCMS) {\n\t            if (options.newGCMS) {\n\t                addNewGCMS(result);\n\t            } else {\n\t                addGCMS(result);\n\t            }\n\t            if (result.profiling) result.profiling.push({\n\t                action: 'Finished GCMS calculation',\n\t                time: Date.now() - start\n\t            });\n\t        }\n\t\n\t        if (result.profiling) {\n\t            result.profiling.push({\n\t                action: 'Total time',\n\t                time: Date.now() - start\n\t            });\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t\n\t    function convertMSFieldToLabel(value) {\n\t        return value.toLowerCase().replace(/[^a-z0-9]/g, '');\n\t    }\n\t\n\t    function isMSField(dataLabel) {\n\t        return GC_MS_FIELDS.indexOf(dataLabel) !== -1;\n\t    }\n\t\n\t    function addNewGCMS(result) {\n\t        var spectra = result.spectra;\n\t        var length = spectra.length;\n\t        var gcms = {\n\t            times: new Array(length),\n\t            series: [{\n\t                name: 'ms',\n\t                dimension: 2,\n\t                data: new Array(length)\n\t            }]\n\t        };\n\t\n\t        var i;\n\t        var existingGCMSFields = [];\n\t        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n\t            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n\t            if (spectra[0][label]) {\n\t                existingGCMSFields.push(label);\n\t                gcms.series.push({\n\t                    name: label,\n\t                    dimension: 1,\n\t                    data: new Array(length)\n\t                });\n\t            }\n\t        }\n\t\n\t        for (i = 0; i < length; i++) {\n\t            var spectrum = spectra[i];\n\t            gcms.times[i] = spectrum.pageValue;\n\t            for (var j = 0; j < existingGCMSFields.length; j++) {\n\t                gcms.series[j + 1].data[i] = parseFloat(spectrum[existingGCMSFields[j]]);\n\t            }\n\t            if (spectrum.data) {\n\t                gcms.series[0].data[i] = [spectrum.data[0].x, spectrum.data[0].y];\n\t            }\n\t\n\t        }\n\t        result.gcms = gcms;\n\t    }\n\t\n\t    function addGCMS(result) {\n\t        var spectra = result.spectra;\n\t        var existingGCMSFields = [];\n\t        var i;\n\t        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n\t            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n\t            if (spectra[0][label]) {\n\t                existingGCMSFields.push(label);\n\t            }\n\t        }\n\t        if (existingGCMSFields.length === 0) return;\n\t        var gcms = {};\n\t        gcms.gc = {};\n\t        gcms.ms = [];\n\t        for (i = 0; i < existingGCMSFields.length; i++) {\n\t            gcms.gc[existingGCMSFields[i]] = [];\n\t        }\n\t        for (i = 0; i < spectra.length; i++) {\n\t            var spectrum = spectra[i];\n\t            for (var j = 0; j < existingGCMSFields.length; j++) {\n\t                gcms.gc[existingGCMSFields[j]].push(spectrum.pageValue);\n\t                gcms.gc[existingGCMSFields[j]].push(parseFloat(spectrum[existingGCMSFields[j]]));\n\t            }\n\t            if (spectrum.data) gcms.ms[i] = spectrum.data[0];\n\t\n\t        }\n\t        result.gcms = gcms;\n\t    }\n\t\n\t    function prepareSpectrum(result, spectrum) {\n\t        if (!spectrum.xFactor) spectrum.xFactor = 1;\n\t        if (!spectrum.yFactor) spectrum.yFactor = 1;\n\t        if (spectrum.observeFrequency) {\n\t            if (spectrum.xUnit && spectrum.xUnit.toUpperCase() === 'HZ') {\n\t                spectrum.xUnit = 'PPM';\n\t                spectrum.xFactor = spectrum.xFactor / spectrum.observeFrequency;\n\t                spectrum.firstX = spectrum.firstX / spectrum.observeFrequency;\n\t                spectrum.lastX = spectrum.lastX / spectrum.observeFrequency;\n\t                spectrum.deltaX = spectrum.deltaX / spectrum.observeFrequency;\n\t            }\n\t        }\n\t        if (result.shiftOffsetVal) {\n\t            var shift = spectrum.firstX - result.shiftOffsetVal;\n\t            spectrum.firstX = spectrum.firstX - shift;\n\t            spectrum.lastX = spectrum.lastX - shift;\n\t        }\n\t    }\n\t\n\t\n\t    function convertTo3DZ(spectra) {\n\t        var noise = 0;\n\t        var minZ = spectra[0].data[0][0];\n\t        var maxZ = minZ;\n\t        var ySize = spectra.length;\n\t        var xSize = spectra[0].data[0].length / 2;\n\t        var z = new Array(ySize);\n\t        for (var i = 0; i < ySize; i++) {\n\t            z[i] = new Array(xSize);\n\t            var xVector = spectra[i].data[0];\n\t            for (var j = 0; j < xSize; j++) {\n\t                var value = xVector[j * 2 + 1];\n\t                z[i][j] = value;\n\t                if (value < minZ) minZ = value;\n\t                if (value > maxZ) maxZ = value;\n\t                if (i !== 0 && j !== 0) {\n\t                    noise += Math.abs(value - z[i][j - 1]) + Math.abs(value - z[i - 1][j]);\n\t                }\n\t            }\n\t        }\n\t        return {\n\t            z: z,\n\t            minX: spectra[0].data[0][0],\n\t            maxX: spectra[0].data[0][spectra[0].data[0].length - 2], // has to be -2 because it is a 1D array [x,y,x,y,...]\n\t            minY: spectra[0].pageValue,\n\t            maxY: spectra[ySize - 1].pageValue,\n\t            minZ: minZ,\n\t            maxZ: maxZ,\n\t            noise: noise / ((ySize - 1) * (xSize - 1) * 2)\n\t        };\n\t\n\t    }\n\t\n\t    function add2D(result, options) {\n\t        var zData = convertTo3DZ(result.spectra);\n\t        result.contourLines = generateContourLines(zData, options);\n\t        delete zData.z;\n\t        result.minMax = zData;\n\t    }\n\t\n\t\n\t    function generateContourLines(zData, options) {\n\t        var noise = zData.noise;\n\t        var z = zData.z;\n\t        var contourLevels = [];\n\t        var nbLevels = options.nbContourLevels || 7;\n\t        var noiseMultiplier = options.noiseMultiplier === undefined ? 5 : options.noiseMultiplier;\n\t        var povarHeight0, povarHeight1, povarHeight2, povarHeight3;\n\t        var isOver0, isOver1, isOver2, isOver3;\n\t        var nbSubSpectra = z.length;\n\t        var nbPovars = z[0].length;\n\t        var pAx, pAy, pBx, pBy;\n\t\n\t        var x0 = zData.minX;\n\t        var xN = zData.maxX;\n\t        var dx = (xN - x0) / (nbPovars - 1);\n\t        var y0 = zData.minY;\n\t        var yN = zData.maxY;\n\t        var dy = (yN - y0) / (nbSubSpectra - 1);\n\t        var minZ = zData.minZ;\n\t        var maxZ = zData.maxZ;\n\t\n\t        //System.out.prvarln('y0 '+y0+' yN '+yN);\n\t        // -------------------------\n\t        // Povars attribution\n\t        //\n\t        // 0----1\n\t        // |  / |\n\t        // | /  |\n\t        // 2----3\n\t        //\n\t        // ---------------------d------\n\t\n\t        var lineZValue;\n\t        for (var level = 0; level < nbLevels * 2; level++) { // multiply by 2 for positif and negatif\n\t            var contourLevel = {};\n\t            contourLevels[level] = contourLevel;\n\t            var side = level % 2;\n\t            var factor = (maxZ - noiseMultiplier * noise) * Math.exp((level >> 1) - nbLevels);\n\t            if (side === 0) {\n\t                lineZValue = factor + noiseMultiplier * noise;\n\t            } else {\n\t                lineZValue = -factor - noiseMultiplier * noise;\n\t            }\n\t            var lines = [];\n\t            contourLevel.zValue = lineZValue;\n\t            contourLevel.lines = lines;\n\t\n\t            if (lineZValue <= minZ || lineZValue >= maxZ) continue;\n\t\n\t            for (var iSubSpectra = 0; iSubSpectra < nbSubSpectra - 1; iSubSpectra++) {\n\t                var subSpectra = z[iSubSpectra];\n\t                var subSpectraAfter = z[iSubSpectra + 1];\n\t                for (var povar = 0; povar < nbPovars - 1; povar++) {\n\t                    povarHeight0 = subSpectra[povar];\n\t                    povarHeight1 = subSpectra[povar + 1];\n\t                    povarHeight2 = subSpectraAfter[povar];\n\t                    povarHeight3 = subSpectraAfter[povar + 1];\n\t\n\t                    isOver0 = (povarHeight0 > lineZValue);\n\t                    isOver1 = (povarHeight1 > lineZValue);\n\t                    isOver2 = (povarHeight2 > lineZValue);\n\t                    isOver3 = (povarHeight3 > lineZValue);\n\t\n\t                    // Example povar0 is over the plane and povar1 and\n\t                    // povar2 are below, we find the varersections and add\n\t                    // the segment\n\t                    if (isOver0 !== isOver1 && isOver0 !== isOver2) {\n\t                        pAx = povar + (lineZValue - povarHeight0) / (povarHeight1 - povarHeight0);\n\t                        pAy = iSubSpectra;\n\t                        pBx = povar;\n\t                        pBy = iSubSpectra + (lineZValue - povarHeight0) / (povarHeight2 - povarHeight0);\n\t                        lines.push(pAx * dx + x0);\n\t                        lines.push(pAy * dy + y0);\n\t                        lines.push(pBx * dx + x0);\n\t                        lines.push(pBy * dy + y0);\n\t                    }\n\t                    // remove push does not help !!!!\n\t                    if (isOver3 !== isOver1 && isOver3 !== isOver2) {\n\t                        pAx = povar + 1;\n\t                        pAy = iSubSpectra + 1 - (lineZValue - povarHeight3) / (povarHeight1 - povarHeight3);\n\t                        pBx = povar + 1 - (lineZValue - povarHeight3) / (povarHeight2 - povarHeight3);\n\t                        pBy = iSubSpectra + 1;\n\t                        lines.push(pAx * dx + x0);\n\t                        lines.push(pAy * dy + y0);\n\t                        lines.push(pBx * dx + x0);\n\t                        lines.push(pBy * dy + y0);\n\t                    }\n\t                    // test around the diagonal\n\t                    if (isOver1 !== isOver2) {\n\t                        pAx = (povar + 1 - (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) * dx + x0;\n\t                        pAy = (iSubSpectra + (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) * dy + y0;\n\t                        if (isOver1 !== isOver0) {\n\t                            pBx = povar + 1 - (lineZValue - povarHeight1) / (povarHeight0 - povarHeight1);\n\t                            pBy = iSubSpectra;\n\t                            lines.push(pAx);\n\t                            lines.push(pAy);\n\t                            lines.push(pBx * dx + x0);\n\t                            lines.push(pBy * dy + y0);\n\t                        }\n\t                        if (isOver2 !== isOver0) {\n\t                            pBx = povar;\n\t                            pBy = iSubSpectra + 1 - (lineZValue - povarHeight2) / (povarHeight0 - povarHeight2);\n\t                            lines.push(pAx);\n\t                            lines.push(pAy);\n\t                            lines.push(pBx * dx + x0);\n\t                            lines.push(pBy * dy + y0);\n\t                        }\n\t                        if (isOver1 !== isOver3) {\n\t                            pBx = povar + 1;\n\t                            pBy = iSubSpectra + (lineZValue - povarHeight1) / (povarHeight3 - povarHeight1);\n\t                            lines.push(pAx);\n\t                            lines.push(pAy);\n\t                            lines.push(pBx * dx + x0);\n\t                            lines.push(pBy * dy + y0);\n\t                        }\n\t                        if (isOver2 !== isOver3) {\n\t                            pBx = povar + (lineZValue - povarHeight2) / (povarHeight3 - povarHeight2);\n\t                            pBy = iSubSpectra + 1;\n\t                            lines.push(pAx);\n\t                            lines.push(pAy);\n\t                            lines.push(pBx * dx + x0);\n\t                            lines.push(pBy * dy + y0);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        return {\n\t            minX: zData.minX,\n\t            maxX: zData.maxX,\n\t            minY: zData.minY,\n\t            maxY: zData.maxY,\n\t            segments: contourLevels\n\t        };\n\t    }\n\t\n\t    function fastParseXYData(spectrum, value) {\n\t        // TODO need to deal with result\n\t        //  console.log(value);\n\t        // we check if deltaX is defined otherwise we calculate it\n\t\n\t        var yFactor = spectrum.yFactor;\n\t        var deltaX = spectrum.deltaX;\n\t\n\t\n\t        spectrum.isXYdata = true;\n\t        // TODO to be improved using 2 array {x:[], y:[]}\n\t        var currentData = [];\n\t        var currentPosition = 0;\n\t        spectrum.data = [currentData];\n\t\n\t\n\t        var currentX = spectrum.firstX;\n\t        var currentY = spectrum.firstY;\n\t\n\t        // we skip the first line\n\t        //\n\t        var endLine = false;\n\t        for (var i = 0; i < value.length; i++) {\n\t            var ascii = value.charCodeAt(i);\n\t            if (ascii === 13 || ascii === 10) {\n\t                endLine = true;\n\t            } else {\n\t                if (endLine) break;\n\t            }\n\t        }\n\t\n\t        // we proceed taking the i after the first line\n\t        var newLine = true;\n\t        var isDifference = false;\n\t        var isLastDifference = false;\n\t        var lastDifference = 0;\n\t        var isDuplicate = false;\n\t        var inComment = false;\n\t        var currentValue = 0;\n\t        var isNegative = false;\n\t        var inValue = false;\n\t        var skipFirstValue = false;\n\t        var decimalPosition = 0;\n\t        var ascii;\n\t        for (; i <= value.length; i++) {\n\t            if (i === value.length) ascii = 13;\n\t            else ascii = value.charCodeAt(i);\n\t            if (inComment) {\n\t                // we should ignore the text if we are after $$\n\t                if (ascii === 13 || ascii === 10) {\n\t                    newLine = true;\n\t                    inComment = false;\n\t                }\n\t            } else {\n\t                // when is it a new value ?\n\t                // when it is not a digit, . or comma\n\t                // it is a number that is either new or we continue\n\t                if (ascii <= 57 && ascii >= 48) { // a number\n\t                    inValue = true;\n\t                    if (decimalPosition > 0) {\n\t                        currentValue += (ascii - 48) / Math.pow(10, decimalPosition++);\n\t                    } else {\n\t                        currentValue *= 10;\n\t                        currentValue += ascii - 48;\n\t                    }\n\t                } else if (ascii === 44 || ascii === 46) { // a \",\" or \".\"\n\t                    inValue = true;\n\t                    decimalPosition++;\n\t                } else {\n\t                    if (inValue) {\n\t                        // need to process the previous value\n\t                        if (newLine) {\n\t                            newLine = false; // we don't check the X value\n\t                            // console.log(\"NEW LINE\",isDifference, lastDifference);\n\t                            // if new line and lastDifference, the first value is just a check !\n\t                            // that we don't check ...\n\t                            if (isLastDifference) skipFirstValue = true;\n\t                        } else {\n\t                            // need to deal with duplicate and differences\n\t                            if (skipFirstValue) {\n\t                                skipFirstValue = false;\n\t                            } else {\n\t                                if (isDifference) {\n\t                                    if (currentValue === 0) lastDifference = 0;\n\t                                    else lastDifference = isNegative ? -currentValue : currentValue;\n\t                                    isLastDifference = true;\n\t                                    isDifference = false;\n\t                                }\n\t                                var duplicate = isDuplicate ? currentValue - 1 : 1;\n\t                                for (var j = 0; j < duplicate; j++) {\n\t                                    if (isLastDifference) {\n\t                                        currentY += lastDifference;\n\t                                    } else {\n\t                                        if (currentValue === 0) currentY = 0;\n\t                                        else currentY = isNegative ? -currentValue : currentValue;\n\t                                    }\n\t\n\t                                    //  console.log(\"Separator\",isNegative ?\n\t                                    //          -currentValue : currentValue,\n\t                                    //      \"isDiff\", isDifference, \"isDup\", isDuplicate,\n\t                                    //      \"lastDif\", lastDifference, \"dup:\", duplicate, \"y\", currentY);\n\t\n\t                                    // push is slightly slower ... (we loose 10%)\n\t                                    currentData[currentPosition++] = currentX;\n\t                                    currentData[currentPosition++] = currentY * yFactor;\n\t                                    currentX += deltaX;\n\t                                }\n\t                            }\n\t                        }\n\t                        isNegative = false;\n\t                        currentValue = 0;\n\t                        decimalPosition = 0;\n\t                        inValue = false;\n\t                        isDuplicate = false;\n\t                    }\n\t\n\t                    // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n\t                    if ((ascii < 74) && (ascii > 63)) {\n\t                        inValue = true;\n\t                        isLastDifference = false;\n\t                        currentValue = ascii - 64;\n\t                    } else\n\t                    // negative SQZ digits a b c d e f g h i (ascii 97-105)\n\t                    if ((ascii > 96) && (ascii < 106)) {\n\t                        inValue = true;\n\t                        isLastDifference = false;\n\t                        currentValue = ascii - 96;\n\t                        isNegative = true;\n\t                    } else\n\t                    // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n\t                    if (ascii === 115) {\n\t                        inValue = true;\n\t                        isDuplicate = true;\n\t                        currentValue = 9;\n\t                    } else if ((ascii > 82) && (ascii < 91)) {\n\t                        inValue = true;\n\t                        isDuplicate = true;\n\t                        currentValue = ascii - 82;\n\t                    } else\n\t                    // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n\t                    if ((ascii > 73) && (ascii < 83)) {\n\t                        inValue = true;\n\t                        isDifference = true;\n\t                        currentValue = ascii - 73;\n\t                    } else\n\t                    // negative DIF digits j k l m n o p q r (ascii 106-114)\n\t                    if ((ascii > 105) && (ascii < 115)) {\n\t                        inValue = true;\n\t                        isDifference = true;\n\t                        currentValue = ascii - 105;\n\t                        isNegative = true;\n\t                    } else\n\t                    // $ sign, we need to check the next one\n\t                    if (ascii === 36 && value.charCodeAt(i + 1) === 36) {\n\t                        inValue = true;\n\t                        inComment = true;\n\t                    } else\n\t                    // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n\t                    if (ascii === 37) {\n\t                        inValue = true;\n\t                        isDifference = true;\n\t                        currentValue = 0;\n\t                        isNegative = false;\n\t                    } else if (ascii === 45) { // a \"-\"\n\t                        // check if after there is a number, decimal or comma\n\t                        var ascii2 = value.charCodeAt(i + 1);\n\t                        if ((ascii2 >= 48 && ascii2 <= 57) || ascii2 === 44 || ascii2 === 46) {\n\t                            inValue = true;\n\t                            isLastDifference = false;\n\t                            isNegative = true;\n\t                        }\n\t                    } else if (ascii === 13 || ascii === 10) {\n\t                        newLine = true;\n\t                        inComment = false;\n\t                    }\n\t                    // and now analyse the details ... space or tabulation\n\t                    // if \"+\" we just don't care\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    function parsePeakTable(spectrum, value, result) {\n\t        var removeCommentRegExp = /\\$\\$.*/;\n\t        var peakTableSplitRegExp = /[,\\t ]+/;\n\t\n\t        spectrum.isPeaktable = true;\n\t        var i, ii, j, jj, values;\n\t        var currentData = [];\n\t        spectrum.data = [currentData];\n\t\n\t        // counts for around 20% of the time\n\t        var lines = value.split(/,? *,?[;\\r\\n]+ */);\n\t\n\t        var k = 0;\n\t        for (i = 1, ii = lines.length; i < ii; i++) {\n\t            values = lines[i].trim().replace(removeCommentRegExp, '').split(peakTableSplitRegExp);\n\t            if (values.length % 2 === 0) {\n\t                for (j = 0, jj = values.length; j < jj; j = j + 2) {\n\t                    // takes around 40% of the time to add and parse the 2 values nearly exclusively because of parseFloat\n\t                    currentData[k++] = (parseFloat(values[j]) * spectrum.xFactor);\n\t                    currentData[k++] = (parseFloat(values[j + 1]) * spectrum.yFactor);\n\t                }\n\t            } else {\n\t                result.logs.push('Format error: ' + values);\n\t            }\n\t        }\n\t    }\n\t\n\t\n\t    return convert;\n\t\n\t}\n\t\n\tvar convert = getConverter();\n\t\n\tfunction JcampConverter(input, options, useWorker) {\n\t    if (typeof options === 'boolean') {\n\t        useWorker = options;\n\t        options = {};\n\t    }\n\t    if (useWorker) {\n\t        return postToWorker(input, options);\n\t    } else {\n\t        return convert(input, options);\n\t    }\n\t}\n\t\n\tvar stamps = {},\n\t    worker;\n\t\n\tfunction postToWorker(input, options) {\n\t    if (!worker) {\n\t        createWorker();\n\t    }\n\t    return new Promise(function (resolve) {\n\t        var stamp = Date.now() + '' + Math.random();\n\t        stamps[stamp] = resolve;\n\t        worker.postMessage(JSON.stringify({\n\t            stamp: stamp,\n\t            input: input,\n\t            options: options\n\t        }));\n\t    });\n\t}\n\t\n\tfunction createWorker() {\n\t    var workerURL = URL.createObjectURL(new Blob([\n\t        'var getConverter =' + getConverter.toString() + ';var convert = getConverter(); onmessage = function (event) { var data = JSON.parse(event.data); postMessage(JSON.stringify({stamp: data.stamp, output: convert(data.input, data.options)})); };'\n\t    ], {type: 'application/javascript'}));\n\t    worker = new Worker(workerURL);\n\t    URL.revokeObjectURL(workerURL);\n\t    worker.addEventListener('message', function (event) {\n\t        var data = JSON.parse(event.data);\n\t        var stamp = data.stamp;\n\t        if (stamps[stamp]) {\n\t            stamps[stamp](data.output);\n\t        }\n\t    });\n\t}\n\t\n\tmodule.exports = {\n\t    convert: JcampConverter\n\t};\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t\n\tvar xyDataSplitRegExp = /[,\\t \\+-]*(?=[^\\d,\\t \\.])|[ \\t]+(?=[\\d+\\.-])/;\n\tvar removeCommentRegExp = /\\$\\$.*/;\n\tvar DEBUG=false;\n\t\n\tmodule.exports=function(spectrum, value, result) {\n\t    // we check if deltaX is defined otherwise we calculate it\n\t    if (!spectrum.deltaX) {\n\t        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n\t    }\n\t\n\t    spectrum.isXYdata=true;\n\t\n\t    var currentData = [];\n\t    var currentPosition=0;\n\t    spectrum.data = [currentData];\n\t\n\t    var currentX = spectrum.firstX;\n\t    var currentY = spectrum.firstY;\n\t    var lines = value.split(/[\\r\\n]+/);\n\t    var lastDif, values, ascii, expectedY;\n\t    values = [];\n\t    for (var i = 1, ii = lines.length; i < ii; i++) {\n\t        //var previousValues=JSON.parse(JSON.stringify(values));\n\t        values = lines[i].trim().replace(removeCommentRegExp, '').split(xyDataSplitRegExp);\n\t        if (values.length > 0) {\n\t            if (DEBUG) {\n\t                if (!spectrum.firstPoint) {\n\t                    spectrum.firstPoint = +values[0];\n\t                }\n\t                var expectedCurrentX = (values[0] - spectrum.firstPoint) * spectrum.xFactor + spectrum.firstX;\n\t                if ((lastDif || lastDif === 0)) {\n\t                    expectedCurrentX += spectrum.deltaX;\n\t                }\n\t                result.logs.push('Checking X value: currentX: ' + currentX + ' - expectedCurrentX: ' + expectedCurrentX);\n\t            }\n\t            for (var j = 1, jj = values.length; j < jj; j++) {\n\t                if (j === 1 && (lastDif || lastDif === 0)) {\n\t                    lastDif = null; // at the beginning of each line there should be the full value X / Y so the diff is always undefined\n\t                    // we could check if we have the expected Y value\n\t                    ascii = values[j].charCodeAt(0);\n\t\n\t                    if (false) { // this code is just to check the jcamp DIFDUP and the next line repeat of Y value\n\t                        // + - . 0 1 2 3 4 5 6 7 8 9\n\t                        if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n\t                            expectedY = +values[j];\n\t                        } else\n\t                        // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n\t                        if ((ascii > 63) && (ascii < 74)) {\n\t                            expectedY = +(String.fromCharCode(ascii - 16) + values[j].substring(1));\n\t                        } else\n\t                        // negative SQZ digits a b c d e f g h i (ascii 97-105)\n\t                        if ((ascii > 96) && (ascii < 106)) {\n\t                            expectedY = -(String.fromCharCode(ascii - 48) + values[j].substring(1));\n\t                        }\n\t                        if (expectedY !== currentY) {\n\t                            result.logs.push('Y value check error: Found: ' + expectedY + ' - Current: ' + currentY);\n\t                            result.logs.push('Previous values: ' + previousValues.length);\n\t                            result.logs.push(previousValues);\n\t                        }\n\t                    }\n\t                } else {\n\t                    if (values[j].length > 0) {\n\t                        ascii = values[j].charCodeAt(0);\n\t                        // + - . 0 1 2 3 4 5 6 7 8 9\n\t                        if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n\t                            lastDif = null;\n\t                            currentY = +values[j];\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else\n\t                        // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n\t                        if ((ascii > 63) && (ascii < 74)) {\n\t                            lastDif = null;\n\t                            currentY = +(String.fromCharCode(ascii - 16) + values[j].substring(1));\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++] = currentX;\n\t                            currentData[currentPosition++] = currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else\n\t                        // negative SQZ digits a b c d e f g h i (ascii 97-105)\n\t                        if ((ascii > 96) && (ascii < 106)) {\n\t                            lastDif = null;\n\t                            // we can multiply the string by 1 because if may not contain decimal (is this correct ????)\n\t                            currentY = -(String.fromCharCode(ascii - 48) + values[j].substring(1))*1;\n\t                            //currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else\n\t\n\t\n\t\n\t                        // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n\t                        if (((ascii > 82) && (ascii < 91)) || (ascii === 115)) {\n\t                            var dup = (String.fromCharCode(ascii - 34) + values[j].substring(1)) - 1;\n\t                            if (ascii === 115) {\n\t                                dup = ('9' + values[j].substring(1)) - 1;\n\t                            }\n\t                            for (var l = 0; l < dup; l++) {\n\t                                if (lastDif) {\n\t                                    currentY = currentY + lastDif;\n\t                                }\n\t                                // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                                currentData[currentPosition++]=currentX;\n\t                                currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                                currentX += spectrum.deltaX;\n\t                            }\n\t                        } else\n\t                        // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n\t                        if (ascii === 37) {\n\t                            lastDif = +('0' + values[j].substring(1));\n\t                            currentY += lastDif;\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else if ((ascii > 73) && (ascii < 83)) {\n\t                            lastDif = (String.fromCharCode(ascii - 25) + values[j].substring(1))*1;\n\t                            currentY += lastDif;\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else\n\t                        // negative DIF digits j k l m n o p q r (ascii 106-114)\n\t                        if ((ascii > 105) && (ascii < 115)) {\n\t                            lastDif = -(String.fromCharCode(ascii - 57) + values[j].substring(1))*1;\n\t                            currentY += lastDif;\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Created by acastillo on 3/2/16.\n\t */\n\t/**\n\t * This class converts a SpectraData object into a String that can be stored as a jcamp file.\n\t * The string reflects the current state of the object and not the raw data from where this\n\t * spectrum was initially loaded.\n\t * @author acastillo\n\t *\n\t */\n\t\n\tvar Encoder = __webpack_require__(8);\n\t\n\tvar JcampCreator = (function(){\n\t\n\t    const Integer = {MAX_VALUE:2e31-1,MIN_VALUE:-2e31};\n\t    const CRLF = \"\\r\\n\";\n\t    const version = \"Cheminfo tools, March 2016\"\n\t\n\t    /**\n\t     * This function creates a String that represents the given spectraData, in the format JCAM-DX 5.0\n\t     * The X,Y data can be compressed using one of the methods described in:\n\t     * \"JCAMP-DX. A STANDARD FORMAT FOR THE EXCHANGE OF ION MOBILITY SPECTROMETRY DATA\",\n\t     *  http://www.iupac.org/publications/pac/pdf/2001/pdf/7311x1765.pdf\n\t     * @param spectraData\n\t     * @param encodeFormat: ('FIX','SQZ','DIF','DIFDUP','CVS','PAC')\n\t     * @return\n\t     */\n\t    var convert = function(spectraData, encodeFormat, factorY, type, userDefinedParams){\n\t        encodeFormat = encodeFormat.toUpperCase().trim();\n\t\n\t        if(type===null||type.length==0)\n\t            type=\"SIMPLE\";\n\t\n\t        var outString = \"\";\n\t        spectraData.setActiveElement(0);\n\t\n\t        var scale=factorY/spectraData.getParamDouble(\"YFACTOR\", 1);\n\t        if(spectraData.getMaxY()*scale>=Integer.MAX_VALUE/2){\n\t            scale=Integer.MAX_VALUE/(spectraData.getMaxY()*2);\n\t        }\n\t        if(Math.abs(spectraData.getMaxY()-spectraData.getMinY())*scale<16)\n\t            scale=16/(Math.abs(spectraData.getMaxY()-spectraData.getMinY()));\n\t\n\t        var scaleX=Math.abs(1.0/spectraData.getDeltaX());\n\t\n\t        outString+=(\"##TITLE= \" + spectraData.getTitle() + CRLF);\n\t        outString+=(\"##JCAMP-DX= 5.00\\t$$\"+version+ CRLF);\n\t        outString+=(\"##OWNER= \" + spectraData.getParamString(\"##OWNER=\", \"\")+ CRLF);\n\t        outString+=(\"##DATA TYPE= \" +spectraData.getDataType()+ CRLF);\n\t\n\t        if(type==\"NTUPLES\") {\n\t            outString+=ntuplesHead(spectraData, scale, scaleX, encodeFormat, userDefinedParams);\n\t        }\n\t\n\t        if(type==\"SIMPLE\"){\n\t            outString+=simpleHead(spectraData, scale, scaleX, encodeFormat, userDefinedParams);\n\t        }\n\t        return outString;\n\t    }\n\t\n\t    var ntuplesHead = function(spectraData, scale, scaleX, encodeFormat, userDefinedParams){\n\t        var outString=\"\";\n\t        var variableX = spectraData.getSpectraVariable(0);\n\t        var variableY = spectraData.getSpectraVariable(1);\n\t        var variableZ = spectraData.getSpectraVariable(2);\n\t\n\t        outString+=\"##DATA CLASS= NTUPLES\" + CRLF;\n\t        outString+=\"##NUM DIM= 2\" + CRLF;\n\t        var nTuplesName=spectraData.getDataType().trim();\n\t        // we set the VarName parameter to the most common ones.\n\t        // These tables contain the number of occurences of each one\n\t        var abscVar = {};\n\t        var sub;\n\t        for ( sub = 0; sub < spectraData.getNbSubSpectra(); sub++) {\n\t            spectraData.setActiveElement(sub);\n\t            if (abscVar[spectraData.getXUnits()]) {\n\t                abscVar[spectraData.getXUnits()].value++;\n\t            } else {\n\t                abscVar[spectraData.getXUnits()]={value:1, index:sub};\n\t            }\n\t        }\n\t\n\t        var keys = Object.keys(abscVar);\n\t        var mostCommon =keys[0], defaultSub = 0;\n\t\n\t        for(sub=1;sub<keys.length;sub++){\n\t            if(abscVar[keys[sub]].value>abscVar[mostCommon].value){\n\t                mostCommon = keys[sub];\n\t                defaultSub=abscVar[keys[sub]].index;\n\t            }\n\t        }\n\t        var isComplex=false;\n\t        spectraData.setActiveElement(defaultSub);\n\t        var isNMR = spectraData.getDataType().indexOf(\"NMR\")>=0;\n\t        //If it is a NMR spectrum\n\t        if(isNMR){\n\t            outString+=(\"##.OBSERVE FREQUENCY= \" + spectraData.getParamDouble(\"observefrequency\", 0) + CRLF);\n\t            outString+=(\"##.OBSERVE NUCLEUS= ^\" + spectraData.getNucleus()+ CRLF);\n\t            outString+=(\"##$DECIM= \" + (spectraData.getParamDouble(\"$DECIM\",0))+ CRLF);\n\t            outString+=(\"##$DSPFVS= \" + (spectraData.getParamDouble(\"$DSPFVS\",0))+ CRLF);\n\t            outString+=(\"##$FCOR= \" + (Math.floor(spectraData.getParamDouble(\"$FCOR\",0)))+ CRLF);\n\t            if(spectraData.containsParam(\"$SW_h\"))\n\t                outString+=(\"##$SW_h= \" + (spectraData.getParamDouble(\"$SW_h\",0))+ CRLF);\n\t            else\n\t            if(spectraData.containsParam(\"$SW_p\"))\n\t                outString+=(\"##$SW_p= \" + (spectraData.getParamDouble(\"$SW_p\",0))+ CRLF);\n\t            outString+=(\"##$SW= \" + (spectraData.getParamDouble(\"$SW\",0))+ CRLF);\n\t            outString+=(\"##$TD= \" + (Math.floor(spectraData.getParamDouble(\"$TD\",0)))+ CRLF);\n\t            outString+=(\"##$BF1= \" + (spectraData.getParamDouble(\"$BF1\",0))+ CRLF);\n\t            outString+=(\"##$GRPDLY= \" + (spectraData.getParamDouble(\"$GRPDLY\",0))+ CRLF);\n\t            outString+=(\"##.DIGITISER RES= \" + (spectraData.getParamInt(\".DIGITISER RES\",0))+ CRLF);\n\t            outString+=(\"##.PULSE SEQUENCE= \" + (spectraData.getParamString(\".PULSE SEQUENCE\", \"\"))+ CRLF);\n\t            outString+=(\"##.SOLVENT NAME= \" + (spectraData.getSolventName())+ CRLF);\n\t            outString+=(\"##$NUC1= <\" +spectraData.getNucleus()+\">\"+ CRLF);\n\t            if(spectraData.containsParam(\"2D_X_FREQUENCY\"))\n\t                outString+=(\"##$SFO1= \" + (spectraData.getParamDouble(\"2D_X_FREQUENCY\",0))+ CRLF);\n\t            else\n\t                outString+=(\"##$SFO1= \" + (spectraData.getParamDouble(\"$SFO1\",0))+ CRLF);\n\t\n\t            if(spectraData.containsParam(\"2D_X_OFFSET\"))\n\t                outString+=(\"##$OFFSET= \" +spectraData.getParamDouble(\"2D_X_OFFSET\", 0)+ CRLF);\n\t\n\t            if(spectraData.is2D()){\n\t                outString+=(\"$$Parameters for 2D NMR Spectrum\"+ CRLF);\n\t                outString+=(\"##$NUC1= <\" +spectraData.getNucleus(2)+\">\"+ CRLF);\n\t                if(spectraData.containsParam(\"2D_Y_FREQUENCY\")){\n\t                    outString+=(\"##$SFO1= \" + spectraData.getParamDouble(\"2D_Y_FREQUENCY\", 0)+ CRLF);\n\t                    outString+=(\"##$SFO2= \" + spectraData.getParamDouble(\"2D_Y_FREQUENCY\", 0)+ CRLF);\n\t                    outString+=(\"##$BF2= \" +spectraData.getParamDouble(\"2D_Y_FREQUENCY\", 0)+ CRLF);\n\t                }\n\t                if(spectraData.containsParam(\"2D_Y_OFFSET\"))\n\t                    outString+=(\"##$OFFSET= \" +spectraData.getParamDouble(\"2D_Y_OFFSET\", 0)+ CRLF);\n\t\n\t                outString+=(\"$$End of Parameters for 2D NMR Spectrum\"+ CRLF);\n\t            }\n\t        }\n\t        outString+=(\"##NTUPLES=\\t\" + nTuplesName + CRLF);\n\t        var freq1 = 1,freq2=1;//spectraData.getParamDouble(\"2D_Y_FREQUENCY\", 0);\n\t        if(!spectraData.is2D()&&spectraData.getNbSubSpectra()>1&& isNMR)\n\t            isComplex=true;\n\t        if(isComplex){\n\t            outString+=(\"##VAR_NAME=\\t\" + spectraData.getXUnits() + \",\\t\"+ nTuplesName.substring(4) +\"/REAL,\\t\"+ nTuplesName.substring(4) +\"/IMAG\"+CRLF);\n\t            outString+=(\"##SYMBOL=\\tX,\\tR,\\tI\" + CRLF);\n\t            outString+=(\"##VAR_TYPE=\\tINDEPENDENT,\\tDEPENDENT,\\tDEPENDENT\" + CRLF);\n\t            if(encodeFormat!=\"CSV\"||encodeFormat!=\"PAC\")\n\t                outString+=(\"##VAR_FORM=\\tAFFN,\\tASDF,\\tASDF\" + CRLF);\n\t            else\n\t                outString+=(\"##VAR_FORM=\\tAFFN,\\tAFFN,\\tAFFN\" + CRLF);\n\t            outString+=(\"##VAR_DIM=\\t\" + spectraData.getNbPoints() + \",\\t\" + spectraData.getNbPoints()+\",\\t\" + spectraData.getNbPoints()+CRLF);\n\t            outString+=(\"##UNITS=\\tHZ\"+ \",\\t\"+ spectraData.getYUnits() +\",\\t\"+ variableZ.units + CRLF);\n\t            outString+=(\"##FACTOR=\\t\" + 1.0/scaleX + \",\\t\"+1.0/scale+\",\\t\"+1.0/scale+ CRLF);\n\t\n\t            if(spectraData.getXUnits()==\"PPM\")\n\t                freq1 = spectraData.observeFrequencyX();\n\t\n\t            outString+=(\"##FIRST=\\t\" + spectraData.getFirstX()*freq1 + \",\\t\"+spectraData.getY(0)+\",\\t0\" + CRLF);\n\t            outString+=(\"##LAST=\\t\" + spectraData.getLastX()*freq1 + \",\\t\"+spectraData.getLastY()+\",\\t0\" + CRLF);\n\t        }\n\t        else{\n\t            freq1 = 1;\n\t            if(spectraData.is2D()) {\n\t                outString += (\"##VAR_NAME=\\tFREQUENCY1,\\tFREQUENCY2,\\tSPECTRUM\" + CRLF);\n\t                outString += (\"##SYMBOL=\\tF1,\\tF2,\\tY\" + CRLF);\n\t                outString += (\"##.NUCLEUS=\\t\" + spectraData.getNucleus(2) + \",\\t\" + spectraData.getNucleus(1) + CRLF);\n\t                outString += (\"##VAR_TYPE=\\tINDEPENDENT,\\tINDEPENDENT,\\tDEPENDENT\" + CRLF);\n\t                if (encodeFormat != \"CSV\" || encodeFormat != \"PAC\")\n\t                    outString += (\"##VAR_FORM=\\tAFFN,\\tAFFN,\\tASDF\" + CRLF);\n\t                else\n\t                    outString+=(\"##VAR_FORM=\\tAFFN,\\tAFFN,\\tASDF\" + CRLF);\n\t                outString+=(\"##VAR_DIM=\\t\" + spectraData.getNbSubSpectra() + \",\\t\" + spectraData.getNbPoints()+ \",\\t\" + spectraData.getNbPoints() + CRLF);\n\t                //We had to change this, for Mestre compatibility\n\t                //outString+=(\"##UNITS=\\tHZ,\\t\"+ spectraData.getXUnits() + \",\\t\" + spectraData.getYUnits()+CRLF);\n\t                outString+=(\"##UNITS=\\tHZ,\\tHZ,\\t\" + spectraData.getYUnits()+CRLF);\n\t                if(spectraData.getXUnits()==\"PPM\")\n\t                    freq1 = spectraData.getParamDouble(\"2D_Y_FREQUENCY\", 1);\n\t                if(spectraData.getYUnits()==\"PPM\"){\n\t                    freq2 = spectraData.getParamDouble(\"2D_X_FREQUENCY\", 1);\n\t                }\n\t                outString+=(\"##FACTOR=\\t1,\\t\"+freq2/scaleX + \",\\t\"+1.0/scale+ CRLF);\n\t                outString+=(\"##FIRST=\\t\"+spectraData.getParamDouble(\"firstY\", 0)*freq1+\",\\t\"+ spectraData.getFirstX()*freq2 + \",\\t\"+spectraData.getY(0) + CRLF);\n\t                outString+=(\"##LAST=\\t\" +spectraData.getParamDouble(\"lastY\", 0)*freq1+\",\\t\"+ spectraData.getLastX() *freq2\n\t                + \",\\t\"+ spectraData.getY(spectraData.getNbPoints()-1)+ CRLF);\n\t            }else{\n\t                outString+=(\"##VAR_NAME=\\t\" + variableX.varname + \",\\t\"+ variableY.varname + \",\\t\"+ variableX.varname + CRLF);\n\t                outString+=(\"##SYMBOL=\\t\" + variableX.symbol + \",\\t\"+ variableY.symbol + \",\\t\"+ variableZ.symbol + CRLF);\n\t                outString+=(\"##VAR_TYPE=\\t\" + variableX.vartype + \",\\t\"+ variableY.vartype + \",\\t\"+ variableZ.vartype + CRLF);\n\t                if(encodeFormat!=\"CSV\"||encodeFormat!=\"PAC\")\n\t                    outString+=(\"##VAR_FORM=\\tAFFN,\\tASDF,\\tASDF\" + CRLF);\n\t                else\n\t                    outString+=(\"##VAR_FORM=\\tAFFN,\\tAFFN,\\tAFFN\" + CRLF);\n\t                outString+=(\"##VAR_DIM=\\t\" + variableX.vardim + \",\\t\"+ variableY.vardim + \",\\t\"+ variableZ.vardim + CRLF);\n\t                outString+=(\"##UNITS=\\tHZ\" + \",\\t\"+ spectraData.getYUnits() + \",\\t\"+ variableZ.units + CRLF);\n\t                if(spectraData.getXUnits()==\"PPM\")\n\t                    freq1 = spectraData.observeFrequencyX();\n\t                outString+=(\"##FACTOR=\\t\" + 1.0/scaleX + \",\\t\"+1.0/scale + CRLF);\n\t                outString+=(\"##FIRST=\\t\" + variableX.first*freq1 + \",\\t\"+ variableY.first + \",\\t\"+ variableZ.first + CRLF);\n\t                outString+=(\"##LAST=\\t\" + variableX.last*freq1 + \",\\t\"+ variableY.last + \",\\t\"+ variableZ.last + CRLF);\n\t\n\t            }\n\t        }\n\t\n\t        //Set the user defined parameters\n\t        if(userDefinedParams!=null){\n\t            for(var i=userDefinedParams.length-1;i>=0;i--){\n\t                if(spectraData.containsParam(userDefinedParams[i])){\n\t                    outString+=(\"##\"+userDefinedParams[i]+\"= \"\n\t                    + spectraData.getParam(userDefinedParams[i], \"\")+ CRLF);\n\t                }\n\t            }\n\t        }\n\t        //Ordinate of the second dimension in case of 2D NMR spectra\n\t        var yUnits = 0, lastY = 0, dy = 0;\n\t\n\t        if(spectraData.is2D()&& isNMR){\n\t            yUnits = spectraData.getParamDouble(\"firstY\", 0)*freq1;\n\t            lastY = spectraData.getParamDouble(\"lastY\", 0)*freq1;\n\t            dy = (lastY-yUnits)/(spectraData.getNbSubSpectra()-1);\n\t        }\n\t\n\t        for ( sub = 0; sub < spectraData.getNbSubSpectra(); sub++) {\n\t            spectraData.setActiveElement(sub);\n\t            outString+=(\"##PAGE= \" + spectraData.page + CRLF);\n\t            yUnits+=dy;\n\t\n\t            if(spectraData.is2D()&&isNMR)\n\t                outString+=(\"##FIRST=\\t\"+spectraData.getParamDouble(\"firstY\", 0)*freq1+\",\\t\"\n\t                + spectraData.getFirstX()*freq2 + \",\\t\"+spectraData.getY(0) + CRLF);\n\t\n\t\n\t            outString+=(\"##DATA TABLE= \");\n\t            if (spectraData.isDataClassPeak()) {\n\t                outString+=(\"(XY..XY), PEAKS\" + CRLF);\n\t                for (var point = 0; point < spectraData.getNbPoints(); point++)\n\t                    outString+=(spectraData.getX(point) + \", \" + spectraData.getY(point)+ CRLF);\n\t\n\t            } else if (spectraData.isDataClassXY()) {\n\t                if(isNMR){\n\t                    if(spectraData.is2D()){\n\t                        outString+=(\"(F2++(Y..Y)), PROFILE\" + CRLF);\n\t                    }\n\t                    else{\n\t                        if(sub%2==0)\n\t                            outString+=(\"(X++(R..R)), XYDATA\" + CRLF);\n\t                        else\n\t                            outString+=(\"(X++(I..I)), XYDATA\" + CRLF);\n\t                    }\n\t                }\n\t                else\n\t                    outString+=(\"(X++(Y..Y)), XYDATA\" + CRLF);\n\t\n\t                var tempString = \"\";\n\t                var data = new Array(spectraData.getNbPoints());\n\t                for (var point = data.length-1; point >=0; point--) {\n\t                    data[point]=Math.round((spectraData.getY(point)*scale));\n\t                }\n\t\n\t                tempString+=Encoder.encode(data,\n\t                    spectraData.getFirstX()*scaleX,spectraData.getDeltaX()*scaleX,encodeFormat);\n\t\n\t                outString+=(tempString+CRLF);\n\t            }\n\t        }\n\t        outString+=(\"##END NTUPLES= \" + nTuplesName + CRLF);\n\t        outString+=(\"##END= \");\n\t\n\t        spectraData.setActiveElement(0);\n\t\n\t        return outString;\n\t    }\n\t\n\t    var simpleHead = function(spectraData, scale, scaleX, encodeFormat, userDefinedParams){\n\t        var variableX = spectraData.getSpectraVariable(0);\n\t        var variableY = spectraData.getSpectraVariable(1);\n\t        var outString=\"\";\n\t        if(spectraData.isDataClassPeak())\n\t            outString+=(\"##DATA CLASS= PEAK TABLE\"+ CRLF);\n\t        if(spectraData.isDataClassXY())\n\t            outString+=(\"##DATA CLASS= XYDATA\"+ CRLF);\n\t\n\t        spectraData.setActiveElement(0);\n\t        //If it is a NMR spectrum\n\t        if(spectraData.getDataType().indexOf(\"NMR\")>=0){\n\t            outString+=(\"##.OBSERVE FREQUENCY= \" + spectraData.getParamDouble(\"observefrequency\", 0) + CRLF);\n\t            outString+=(\"##.OBSERVE NUCLEUS= ^\" + spectraData.getNucleus()+ CRLF);\n\t            outString+=(\"##$DECIM= \" + (Math.round(spectraData.getParamDouble(\"$DECIM\",0)))+ CRLF);\n\t            outString+=(\"##$DSPFVS= \" + (Math.round(spectraData.getParamDouble(\"$DSPFVS\",0)))+ CRLF);\n\t            outString+=(\"##$FCOR= \" + (Math.round(spectraData.getParamDouble(\"$FCOR\",0)))+ CRLF);\n\t            outString+=(\"##$SW_h= \" + (spectraData.getParamDouble(\"$SW_h\",0))+ CRLF);\n\t            outString+=(\"##$SW= \" + (spectraData.getParamDouble(\"$SW\",0))+ CRLF);\n\t            outString+=(\"##$TD= \" + (Math.round(spectraData.getParamDouble(\"$TD\",0)))+ CRLF);\n\t            outString+=(\"##$GRPDLY= \" + (spectraData.getParamDouble(\"$GRPDLY\",0))+ CRLF);\n\t            outString+=(\"##$BF1= \" + (spectraData.getParamDouble(\"$BF1\",0))+ CRLF);\n\t            outString+=(\"##$SFO1= \" + (spectraData.getParamDouble(\"$SFO1\",0))+ CRLF);\n\t            outString+=(\"##$NUC1= <\" +spectraData.getNucleus()+\">\"+ CRLF);\n\t            outString+=(\"##.SOLVENT NAME= \" + (spectraData.getSolventName())+ CRLF);\n\t\n\t        }\n\t        outString+=(\"##XUNITS=\\t\" + spectraData.getXUnits() + CRLF);\n\t        outString+=(\"##YUNITS=\\t\" + spectraData.getYUnits() + CRLF);\n\t        outString+=(\"##NPOINTS=\\t\" + spectraData.getNbPoints() + CRLF);\n\t        outString+=(\"##FIRSTX=\\t\" + spectraData.getFirstX() + CRLF);\n\t        outString+=(\"##LASTX=\\t\" + spectraData.getLastX() + CRLF);\n\t        outString+=(\"##FIRSTY=\\t\" + spectraData.getFirstY() + CRLF);\n\t        outString+=(\"##LASTY=\\t\" + spectraData.getLastY() + CRLF);\n\t        if (spectraData.isDataClassPeak()) {\n\t            outString+=(\"##XFACTOR=1\"+ CRLF);\n\t            outString+=(\"##YFACTOR=1\"+ CRLF);\n\t        } else if (spectraData.isDataClassXY()) {\n\t            outString+=(\"##XFACTOR= \"+ 1.0/scaleX+ CRLF);\n\t            outString+=(\"##YFACTOR= \"+1.0/scale + CRLF);\n\t        }\n\t        outString+=(\"##MAXY= \"+ spectraData.getMaxY()+ CRLF);\n\t        outString+=(\"##MINY= \"+ spectraData.getMinY()+ CRLF);\n\t\n\t        //Set the user defined parameters\n\t        if(userDefinedParams!=null){\n\t            for(var i=userDefinedParams.length-1;i>=0;i--){\n\t                if(spectraData.containsParam(userDefinedParams[i])){\n\t                    outString+=(\"##\"+userDefinedParams[i]+\"= \"\n\t                    + spectraData.getParam(userDefinedParams[i], \"\")+ CRLF);\n\t                }\n\t            }\n\t        }\n\t\n\t\n\t        if (spectraData.isDataClassPeak()) {\n\t            outString+=(\"##PEAK TABLE= (XY..XY)\" + CRLF);\n\t            for (var point = 0; point < spectraData.getNbPoints(); point++)\n\t                outString+=(spectraData.getX(point) + \", \" + spectraData.getY(point)+ CRLF);\n\t            outString+=(\"##END \");\n\t\n\t        } else if (spectraData.isDataClassXY()) {\n\t            outString+=(\"##DELTAX= \"+spectraData.getDeltaX()+CRLF);\n\t            outString+=(\"##XYDATA=(X++(Y..Y))\" + CRLF);\n\t            var tempString = \"\";\n\t            var data = new Array(spectraData.getNbPoints());\n\t            for (var point = data.length-1; point >=0; point--) {\n\t                data[point]=Math.round(spectraData.getY(point)*scale);\n\t            }\n\t\n\t            tempString+=Encoder.encode(data, spectraData.getFirstX()*scaleX,spectraData.getDeltaX()*scaleX, encodeFormat);\n\t\n\t            outString+=(tempString+CRLF);\n\t            outString+=(\"##END= \");\n\t        }\n\t\n\t        spectraData.setActiveElement(0);\n\t        return outString;\n\t    }\n\t\n\t    return {\"convert\":convert};\n\t})();\n\t\n\tmodule.exports = JcampCreator;\n\t\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t/**\n\t * class encodes a integer vector as a String in order to store it in a text file.\n\t * The algorithms used to encode the data are describe in:\n\t *            http://www.iupac.org/publications/pac/pdf/2001/pdf/7311x1765.pdf\n\t * Created by acastillo on 3/2/16.\n\t */\n\tvar Encoder = (function(){\n\t    var newLine=\"\\r\\n\";\n\t\n\t    var pseudoDigits=[['0','1','2','3','4','5','6','7','8','9'],\n\t                  ['@','A','B','C','D','E','F','G','H','I'],\n\t                  ['@','a','b','c','d','e','f','g','h','i'],\n\t                  ['%','J','K','L','M','N','O','P','Q','R'],\n\t                  ['%','j','k','l','m','n','o','p','q','r'],\n\t                  [' ','S','T','U','V','W','X','Y','Z','s']];\n\t\n\t    var SQZ_P= 1, SQZ_N= 2, DIF_P=3, DIF_N=4, DUP=5, MaxLinelength=100;\n\t\n\t    /**\n\t     * This function encodes the given vector. The encoding format is specified by the\n\t     * encoding option\n\t     * @param data\n\t     * @param firstX\n\t     * @param intervalX\n\t     * @param encoding: ('FIX','SQZ','DIF','DIFDUP','CVS','PAC') Default 'DIFDUP'\n\t     * @returns {String}\n\t     */\n\t    var encode = function(data, firstX, intervalX, encoding){\n\t        if(encoding==(\"FIX\"))\n\t            return FIXencod(data, firstX,intervalX);\n\t        if(encoding==(\"SQZ\"))\n\t            return SQZencod(data, firstX,intervalX);\n\t        if(encoding==(\"DIF\"))\n\t            return DIFencod(data, firstX,intervalX);\n\t        if(encoding==(\"DIFDUP\"))\n\t            return DIFDUPencod(data, firstX,intervalX);\n\t        if(encoding==(\"CSV\"))\n\t            return CSVencod(data, firstX,intervalX);\n\t        if(encoding==(\"PAC\"))\n\t            return PACencod(data, firstX,intervalX);\n\t        //Default\n\t        return DIFencod(data, firstX,intervalX);\n\t    }\n\t\n\t    /**\n\t     * No data compression used. The data is separated by a comma(',').\n\t     * @param data\n\t     * @return\n\t     */\n\t    var CSVencod =  function(data, firstX, intervalX){\n\t        return FIXencod(data, firstX, intervalX, \",\");\n\t    };\n\t\n\t    /**\n\t     * No data compression used. The data is separated by the specified separator.\n\t     * @param data\n\t     * @param separator, The separator character\n\t     * @return\n\t     */\n\t    var FIXencod =  function(data, firstX, intervalX, separator){\n\t        if(!separator)\n\t            separator = \" \";\n\t        var outputData = \"\";\n\t        var j=0, TD = data.length, i;\n\t        while(j<TD-7){\n\t            outputData+=Math.ceil(firstX+j*intervalX);\n\t            for(i = 0;i<8;i++)\n\t                outputData+=separator+data[j++];\n\t            outputData+=newLine;\n\t        }\n\t        if(j<TD){\n\t            //We add last numbers\n\t            outputData+=Math.ceil(firstX+j*intervalX);\n\t            for(i=j;i<TD;i++)\n\t                outputData+=separator + data[i];\n\t        }\n\t        return outputData;\n\t    };\n\t    /**\n\t     * No data compression used. The data is separated by the sign of the number.\n\t     * @param data\n\t     * @return\n\t     */\n\t    var PACencod = function(data, firstX, intervalX){\n\t        var outputData = \"\";\n\t        var j=0, TD = data.length, i;\n\t\n\t        while(j<TD-7){\n\t            outputData+=Math.ceil(firstX+j*intervalX);\n\t            for(i = 0;i<8;i++){\n\t                if(data[j]<0)\n\t                    outputData+=\"-\"+data[j++];\n\t                else\n\t                    outputData+=\"+\"+data[j++];\n\t            }\n\t            outputData+=newLine;\n\t        }\n\t        if(j<TD){\n\t            //We add last numbers\n\t            outputData+=Math.ceil(firstX+j*intervalX);\n\t            for(i=j;i<TD;i++){\n\t                if(data[i]<0)\n\t                    outputData+=\"-\"+data[i];\n\t                else\n\t                    outputData+=\"+\"+data[i];\n\t            }\n\t        }\n\t        return outputData;\n\t    };\n\t    /**\n\t     * Data compression is possible using the squeezed form (SQZ) in which the delimiter, the leading digit,\n\t     * and sign are replaced by a pseudo-digit from Table 1. For example, the Y-values 30, 32 would be\n\t     * represented as C0C2.\n\t     * @param data\n\t     * @return String\n\t     */\n\t    var SQZencod = function(data, firstX, intervalX){\n\t        var outputData = \"\";\n\t        //String outputData = new String();\n\t        var j=0, TD = data.length, i;\n\t\n\t        while(j<TD-10){\n\t            outputData+=Math.ceil(firstX+j*intervalX);\n\t            for(i = 0;i<10;i++)\n\t                outputData+=SQZDigit(data[j++].toString());\n\t            outputData+=newLine;\n\t        }\n\t        if(j<TD){\n\t            //We add last numbers\n\t            outputData+=Math.ceil(firstX+j*intervalX);\n\t            for(i = j;i<TD;i++)\n\t                outputData+=SQZDigit(data[i].toString());\n\t        }\n\t\n\t        return outputData;\n\t    };\n\t\n\t    /**\n\t     * Duplicate suppression encoding\n\t     * @param data\n\t     * @return\n\t     */\n\t    var DIFDUPencod = function(data, firstX, intervalX){\n\t        var mult=0, index=0, charCount= 0, i;\n\t        //We built a string where we store the encoded data.\n\t        var encodData = \"\",encodNumber = \"\",temp = \"\";\n\t\n\t        //We calculate the differences vector\n\t        var diffData = new Array(data.length-1);\n\t        for(i=0;i<diffData.length;i++){\n\t            diffData[i]= data[i+1]-data[i];\n\t        }\n\t\n\t        //We simulate a line carry\n\t        var numDiff = diffData.length;\n\t        while(index<numDiff){\n\t            if(charCount==0){//Start line\n\t                encodNumber = Math.ceil(firstX+index*intervalX)+SQZDigit(data[index].toString())+DIFDigit(diffData[index].toString());\n\t                encodData+=encodNumber;\n\t                charCount+=encodNumber.length;\n\t            }\n\t            else{\n\t                //Try to insert next difference\n\t                if(diffData[index-1]==diffData[index]){\n\t                    mult++;\n\t                }\n\t                else{\n\t                    if(mult>0){//Now we know that it can be in line\n\t                        mult++;\n\t                        encodNumber=DUPDigit(mult.toString());\n\t                        encodData+=encodNumber;\n\t                        charCount+=encodNumber.length;\n\t                        mult=0;\n\t                        index--;\n\t                    }\n\t                    else{\n\t                        //Mirar si cabe, en caso contrario iniciar una nueva linea\n\t                        encodNumber=DIFDigit(diffData[index].toString());\n\t                        if(encodNumber.length+charCount<MaxLinelength){\n\t                            encodData+=encodNumber;\n\t                            charCount+=encodNumber.length;\n\t                        }\n\t                        else{//Iniciar nueva linea\n\t                            encodData+=newLine;\n\t                            temp=Math.ceil(firstX+index*intervalX)+SQZDigit(data[index].toString())+encodNumber;\n\t                            encodData+=temp;//Each line start with first index number.\n\t                            charCount=temp.length;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            index++;\n\t        }\n\t        if(mult>0)\n\t            encodData+=DUPDigit((mult+1).toString());\n\t        //We insert the last data from fid. It is done to control of data\n\t        //The last line start with the number of datas in the fid.\n\t        encodData+=newLine+Math.ceil(firstX+index*intervalX)+SQZDigit(data[index].toString());\n\t\n\t        return encodData;\n\t    };\n\t\n\t    /**\n\t     * Differential encoding\n\t     * @param data\n\t     * @return\n\t     */\n\t    var DIFencod = function(data, firstX, intervalX){\n\t        var index=0, charCount= 0,i;\n\t\n\t        var encodData = \"\";\n\t        //String encodData = new String();\n\t        var encodNumber = \"\", temp = \"\";\n\t\n\t        //We calculate the differences vector\n\t        var diffData = new Array(data.length-1);\n\t        for(i=0;i<diffData.length;i++){\n\t            diffData[i]= data[i+1]-data[i];\n\t        }\n\t\n\t        index=0;\n\t        var numDiff = diffData.length;\n\t        while(index<numDiff){\n\t            if(charCount==0){//Iniciar linea\n\t                //We convert the first number.\n\t                encodNumber = Math.ceil(firstX+index*intervalX)+SQZDigit(data[index].toString())+DIFDigit(diffData[index].toString());\n\t                encodData+=encodNumber;\n\t                charCount+=encodNumber.length;\n\t            }\n\t            else{\n\t                //Mirar si cabe, en caso contrario iniciar una nueva linea\n\t                encodNumber=DIFDigit(diffData[index].toString());\n\t                if(encodNumber.length+charCount<MaxLinelength){\n\t                    encodData+=encodNumber;\n\t                    charCount+=encodNumber.length;\n\t                }\n\t                else{//Iniciar nueva linea\n\t                    encodData+=newLine;\n\t                    temp=Math.ceil(firstX+index*intervalX)+SQZDigit(data[index].toString())+encodNumber;\n\t                    encodData+=temp;//Each line start with first index number.\n\t                    charCount=temp.length;\n\t                }\n\t            }\n\t            index++;\n\t        }\n\t        //We insert the last number from data. It is done to control of data\n\t        encodData+=newLine+Math.ceil(firstX+index*intervalX)+SQZDigit(data[index].toString());\n\t\n\t        return encodData;\n\t    };\n\t\n\t    /**\n\t     * Convert number to the ZQZ format, using pseudo digits.\n\t     * @param num\n\t     * @return\n\t     */\n\t    var SQZDigit = function(num){\n\t        //console.log(num+\" \"+num.length);\n\t        var SQZdigit = \"\";\n\t        if(num.charAt(0)=='-'){\n\t            SQZdigit+=pseudoDigits[SQZ_N][Number(num.charAt(1))];\n\t            if(num.length>2)\n\t                SQZdigit+=num.substring(2);\n\t        }\n\t        else{\n\t            SQZdigit+=pseudoDigits[SQZ_P][Number(num.charAt(0))];\n\t            if(num.length>1)\n\t                SQZdigit+=num.substring(1);\n\t        }\n\t\n\t        return SQZdigit;\n\t    };\n\t    /**\n\t     * Convert number to the DIF format, using pseudo digits.\n\t     * @param num\n\t     * @return\n\t     */\n\t    var DIFDigit = function(num){\n\t        var DIFFdigit = \"\";\n\t\n\t        if(num.charAt(0)=='-'){\n\t            DIFFdigit+=pseudoDigits[DIF_N][Number(num.charAt(1))];\n\t            if(num.length>2)\n\t                DIFFdigit+=num.substring(2);\n\t\n\t        }\n\t        else{\n\t            DIFFdigit+=pseudoDigits[DIF_P][Number(num.charAt(0))];\n\t            if(num.length>1)\n\t                DIFFdigit+=num.substring(1);\n\t\n\t        }\n\t\n\t        return DIFFdigit;\n\t    };\n\t    /**\n\t     * Convert number to the DUP format, using pseudo digits.\n\t     * @param num\n\t     * @return\n\t     */\n\t    var DUPDigit = function(num){\n\t        var DUPdigit = \"\";\n\t        DUPdigit+=pseudoDigits[DUP][Number(num.charAt(0))];\n\t        if(num.length>1)\n\t            DUPdigit+=num.substring(1);\n\t\n\t        return DUPdigit;\n\t    }\n\t\n\t    return {\n\t        encode:encode,\n\t        FIXencod:FIXencod,\n\t        CSVencod:CSVencod,\n\t        PACencod:PACencod,\n\t        SQZencod:SQZencod,\n\t        DIFDUPencod:DIFDUPencod,\n\t        DIFencod:DIFDUPencod\n\t    };\n\t\n\t})();\n\t\n\tmodule.exports = Encoder;\n\t\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar SD = __webpack_require__(3);\n\tvar PeakPicking = __webpack_require__(10);\n\tvar JcampConverter=__webpack_require__(5);\n\tvar fft = __webpack_require__(41);\n\tvar Filters = __webpack_require__(44);\n\t\n\t/**\n\t * Construct the object from the given sd object(output of the jcampconverter or brukerconverter filter)\n\t * @param sd\n\t * @constructor\n\t */\n\tfunction NMR(sd) {\n\t    SD.call(this, sd); // Héritage\n\t}\n\t\n\tNMR.prototype = Object.create(SD.prototype);\n\tNMR.prototype.constructor = NMR;\n\t\n\t/**\n\t * @function fromJcamp(jcamp,options)\n\t * Construct the object from the given jcamp.\n\t * @param jcamp\n\t * @param options\n\t * @option xy\n\t * @option keepSpectra\n\t * @option keepRecordsRegExp\n\t * @returns {NMR}\n\t */\n\tNMR.fromJcamp = function(jcamp,options) {\n\t    options = options || {xy:true,keepSpectra:true,keepRecordsRegExp:/^.+$/};\n\t    var spectrum= JcampConverter.convert(jcamp,options);\n\t    return new NMR(spectrum);\n\t}\n\t\n\t/**\n\t * @function getNucleus(dim)\n\t * Returns the observed nucleus. A dimension parameter is accepted for compatibility with 2DNMR\n\t * @param dim\n\t * @returns {*}\n\t */\n\tNMR.prototype.getNucleus=function(dim){\n\t    if(!dim||dim==0||dim==1)\n\t        return this.sd.xType;\n\t    else{\n\t        return \"\";\n\t    }\n\t}\n\t\n\t/**\n\t * @function getSolventName()\n\t * Returns the solvent name.\n\t * @returns {string|XML}\n\t */\n\tNMR.prototype.getSolventName=function(){\n\t    return (this.sd.info[\".SOLVENTNAME\"]||this.sd.info[\"$SOLVENT\"]||\"\").replace(\"<\",\"\").replace(\">\",\"\");\n\t}\n\t\n\t/**\n\t * @function observeFrequencyX()\n\t * Returns the observe frequency in the direct dimension\n\t * @returns {number}\n\t */\n\tNMR.prototype.observeFrequencyX=function(){\n\t    return this.sd.spectra[0].observeFrequency;\n\t}\n\t\n\t/**\n\t * @function getNMRPeakThreshold(nucleus)\n\t * Returns the noise factor depending on the nucleus.\n\t * @param nucleus\n\t * @returns {number}\n\t */\n\tNMR.prototype.getNMRPeakThreshold=function(nucleus) {\n\t    if (nucleus == \"1H\")\n\t        return 3.0;\n\t    if (nucleus ==\"13C\")\n\t        return 5.0;\n\t    return 1.0;\n\t}\n\t\n\t\n\t    \n\t/**\n\t * @function addNoise(SNR)\n\t * This function adds white noise to the the given spectraData. The intensity of the noise is \n\t * calculated from the given signal to noise ratio.\n\t * @param SNR Signal to noise ratio\n\t * @returns this object\n\t */\n\t NMR.prototype.addNoise=function(SNR) {\n\t     //@TODO Implement addNoise filter\n\t}\n\t\n\t\n\t/**\n\t * @function addSpectraDatas(spec2,factor1,factor2,autoscale )   \n\t *  This filter performs a linear combination of two spectraDatas.\n\t * A=spec1\n\t * B=spec2\n\t * After to apply this filter you will get:\n\t *      A=A*factor1+B*factor2\n\t * if autoscale is set to 'true' then you will obtain:\n\t *  A=A*factor1+B*k*factor2\n\t * Where the k is a factor such that the maximum peak in A is equal to the maximum peak in spectraData2 \n\t * @param spec2 spectraData2\n\t * @param factor1 linear factor for spec1\n\t * @param factor2 linear factor for spec2\n\t * @param autoscale Auto-adjust scales before combine the spectraDatas\n\t * @returns this object\n\t * @example spec1 = addSpectraDatas(spec1,spec2,1,-1, false) This subtract spec2 from spec1\n\t*/\n\tNMR.prototype.addSpectraDatas=function(spec2,factor1,factor2,autoscale ) {\n\t    //@TODO Implement addSpectraDatas filter\n\t\n\t}\n\t\n\t/**\n\t * @function autoBaseline()\n\t * Automatically corrects the base line of a given spectraData. After this process the spectraData\n\t * should have meaningful integrals.\n\t * @returns this object\n\t */\n\tNMR.prototype.autoBaseline=function( ) {\n\t    //@TODO Implement autoBaseline filter\n\t}\n\t\n\t/**\n\t * @function fourierTransform()\n\t * Fourier transforms the given spectraData (Note. no 2D handling yet) this spectraData have to be of type NMR_FID or 2DNMR_FID\n\t * @returns this object\n\t */\n\tNMR.prototype.fourierTransform=function( ) {\n\t    return Filters.fourierTransform(this);\n\t}\n\t\n\t/**\n\t * @function postFourierTransform(ph1corr)\n\t * This filter makes an phase 1 correction that corrects the problem of the spectra that has been obtained \n\t * on spectrometers using the Bruker digital filters. This method is used in cases when the BrukerSpectra \n\t * filter could not find the correct number of points to perform a circular shift.\n\t * The actual problem is that not all of the spectra has the necessary parameters for use only one method for \n\t * correcting the problem of the Bruker digital filters.\n\t * @param spectraData A fourier transformed spectraData.\n\t * @param ph1corr Phase 1 correction value in radians.\n\t * @returns this object\n\t */\n\tNMR.prototype.postFourierTransform=function(ph1corr) {\n\t    return Filters.phaseCorrection(0,ph1corr);\n\t}\n\t\n\t/**\n\t * @function zeroFilling(nPointsX [,nPointsY])\n\t * This function increase the size of the spectrum, filling the new positions with zero values. Doing it one \n\t * could increase artificially the spectral resolution.\n\t * @param nPointsX Number of new zero points in the direct dimension\n\t * @param nPointsY Number of new zero points in the indirect dimension\n\t * @returns this object\n\t */\n\tNMR.prototype.zeroFilling=function(nPointsX, nPointsY) {\n\t    return Filters.zeroFilling(this,nPointsX, nPointsY);\n\t}\n\t\n\t/**\n\t * @function  haarWhittakerBaselineCorrection(waveletScale,whittakerLambda)\n\t * Applies a baseline correction as described in J Magn Resonance 183 (2006) 145-151 10.1016/j.jmr.2006.07.013\n\t * The needed parameters are the wavelet scale and the lambda used in the whittaker smoother.\n\t * @param waveletScale To be described\n\t * @param whittakerLambda To be described\n\t * @returns this object\n\t */\n\tNMR.prototype.haarWhittakerBaselineCorrection=function(waveletScale,whittakerLambda) {\n\t    //@TODO Implement haarWhittakerBaselineCorrection filter\n\t}\n\t\n\t/**\n\t * @function whittakerBaselineCorrection(whittakerLambda,ranges)\n\t * Applies a baseline correction as described in J Magn Resonance 183 (2006) 145-151 10.1016/j.jmr.2006.07.013\n\t * The needed parameters are the Wavelet scale and the lambda used in the Whittaker smoother.\n\t * @param waveletScale To be described\n\t * @param whittakerLambda To be described\n\t * @param ranges A string containing the ranges of no signal.\n\t * @returns this object\n\t */\n\tNMR.prototype.whittakerBaselineCorrection=function(whittakerLambda,ranges) {\n\t    //@TODO Implement whittakerBaselineCorrection filter\n\t}\n\t\n\t/**\n\t * @function brukerFilter()\n\t * This filter applies a circular shift(phase 1 correction in the time domain) to an NMR FID spectrum that \n\t * have been obtained on spectrometers using the Bruker digital filters. The amount of shift depends on the \n\t * parameters DECIM and DSPFVS. This spectraData have to be of type NMR_FID\n\t * @returns this object\n\t */\n\tNMR.prototype.brukerFilter=function() {\n\t    return Filters.digitalFilter(this, {\"brukerFilter\":true});\n\t}\n\t\n\t/**\n\t * @function digitalFilter(options)\n\t * This filter applies a circular shift(phase 1 correction in the time domain) to an NMR FID spectrum that\n\t * have been obtained on spectrometers using the Bruker digital filters. The amount of shift depends on the\n\t * parameters DECIM and DSPFVS. This spectraData have to be of type NMR_FID\n\t * @option nbPoints: The number of points to shift. Positive values will shift the values to the rigth\n\t * and negative values will do to the left.\n\t * @option brukerSpectra\n\t * @returns this object\n\t */\n\tNMR.prototype.digitalFilter=function(options) {\n\t    return Filters.digitalFilter(this, options);\n\t}\n\t\n\t/**\n\t * @function apodization(functionName, lineBroadening)\n\t * Apodization of a spectraData object.\n\t * @param spectraData An spectraData of type NMR_FID\n\t * @param functionName Valid values for functionsName are\n\t *  Exponential, exp\n\t *  Hamming, hamming\n\t *  Gaussian, gauss\n\t *  TRAF, traf\n\t *  Sine Bell, sb\n\t *  Sine Bell Squared, sb2\n\t * @param lineBroadening The parameter LB should either be a line broadening factor in Hz \n\t * or alternatively an angle given by degrees for sine bell functions and the like.\n\t * @returns this object\n\t * @example SD.apodization(\"exp\", lineBroadening)\n\t */\n\tNMR.prototype.apodization=function(functionName, lineBroadening) {\n\t    return Filters.apodization(this,{\"functionName\":functionName,\n\t                            \"lineBroadening\":lineBroadening});\n\t\n\t}\n\t\n\t/**\n\t * @function echoAntiechoFilter();\n\t * That decodes an Echo-Antiecho 2D spectrum.\n\t * @returns this object\n\t */\n\tNMR.prototype.echoAntiechoFilter=function() {\n\t    //@TODO Implement echoAntiechoFilter filter\n\t}\n\t\n\t/**\n\t * @function SNVFilter()\n\t * This function apply a Standard Normal Variate Transformation over the given spectraData. Mainly used for IR spectra.\n\t * @returns this object\n\t */\n\tNMR.prototype.SNVFilter=function() {\n\t    //@TODO Implement SNVFilter\n\t}\n\t\n\t/**\n\t * @function powerFilter(power)\n\t * This function applies a power to all the Y values.<br>If the power is less than 1 and the spectrum has negative values, it will be shifted so that the lowest value is zero \n\t * @param   power   The power to apply\n\t * @returns this object\n\t */\n\tNMR.prototype.powerFilter=function(power) {\n\t    var minY=this.getMinY();\n\t    if(power<1 && minY<0){\n\t        this.YShift(-1*minY);\n\t        console.warn(\"SD.powerFilter: The spectrum had negative values and was automatically shifted before applying the function.\");\n\t    }\n\t    //@TODO Implement powerFilter\n\t}\n\t\n\t/**\n\t * @function logarithmFilter(base)\n\t * This function applies a log to all the Y values.<br>If the spectrum has negative or zero values, it will be shifted so that the lowest value is 1 \n\t * @param   base    The base to use\n\t * @returns this object\n\t */\n\tNMR.prototype.logarithmFilter=function(base) {\n\t    var minY=this.getMinY();\n\t    if(minY<=0){\n\t        this.YShift((-1*minY)+1);\n\t        console.warn(\"SD.logarithmFilter: The spectrum had negative values and was automatically shifted before applying the function.\");\n\t    }\n\t   //@TODO Implement logarithmFilter filter\n\t}\n\t\n\t\n\t/**\n\t * @function correlationFilter(func) \n\t * This function correlates the given spectraData with the given vector func. The correlation\n\t * operation (*) is defined as:\n\t * \n\t *                    __ inf\n\t *  c(x)=f(x)(*)g(x)= \\        f(x)*g(x+i)\n\t *                   ./    \n\t *                    -- i=-inf\n\t * @param func A double array containing the function to correlates the spectraData\n\t * @returns this object\n\t * @example var smoothedSP = SD.correlationFilter(spectraData,[1,1]) returns a smoothed version of the\n\t * given spectraData. \n\t */\n\tNMR.prototype.correlationFilter=function(func) {\n\t    //@TODO Implement correlationFilter filter\n\t}\n\t\n\t/**\n\t * @function  phaseCorrection(phi0, phi1)\n\t * Applies the phase correction (phi0,phi1) to a Fourier transformed spectraData. The angles must be given in radians.\n\t * @param phi0 Zero order phase correction\n\t * @param phi1 One order phase correction\n\t * @returns this object\n\t*/\n\tNMR.prototype.phaseCorrection=function(phi0, phi1) {\n\t    return Filters.phaseCorrection(this, phi0, phi1);\n\t}\n\t\n\t/**\n\t * @function automaticPhase() \n\t * This function determines automatically the correct parameters phi0 and phi1 for a phaseCorrection\n\t * function and applies it.\n\t * @returns this object\n\t */ \n\tNMR.prototype.automaticPhase=function() {\n\t    //@TODO Implement automaticPhase filter\n\t}\n\t\n\t\n\t/**\n\t * @function nmrPeakDetection(parameters);\n\t * This function process the given spectraData and tries to determine the NMR signals. Returns an NMRSignal1D array containing all the detected 1D-NMR Signals\n\t * @param parameters A JSONObject containing the optional parameters:\n\t * @option fromX:   Lower limit.\n\t * @option toX:     Upper limit.\n\t * @option threshold: The minimum intensity to consider a peak as a signal, expressed as a percentage of the highest peak. \n\t * @option stdev: Number of standard deviation of the noise for the threshold calculation if a threshold is not specified.\n\t * @returns {*}\n\t */\n\tNMR.prototype.nmrPeakDetection=function(parameters) {\n\t    return PeakPicking.peakPicking(this, parameters);\n\t}\n\t\n\t\n\t\n\tmodule.exports = NMR;\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Implementation of the peak pickig method described by Cobas in:\n\t * A new approach to improving automated analysis of proton NMR spectra\n\t * through Global Spectral Deconvolution (GSD)\n\t * http://www.spectroscopyeurope.com/images/stories/ColumnPDFs/TD_23_1.pdf\n\t */\n\tvar JAnalyzer = __webpack_require__(11);\n\t/*var LM = require('ml-curve-fitting');\n\tvar Matrix = LM.Matrix;\n\tvar math = Matrix.algebra;*/\n\tvar GSD = __webpack_require__(12);\n\tvar extend = __webpack_require__(1);\n\tvar removeImpurities = __webpack_require__(40);\n\t\n\tvar PeakPicking={\n\t    impurities:[],\n\t    maxJ:20,\n\t    defaultOptions:{nH:99,\n\t        clean:true,\n\t        realTop:false,\n\t        thresholdFactor:1,\n\t        compile:true,\n\t        integralFn:0,\n\t        optimize:true,\n\t        idPrefix:\"\",\n\t        format:\"old\"\n\t    },\n\t\n\t    peakPicking:function(spectrum, optionsEx){\n\t        var options = extend({}, this.defaultOptions, optionsEx);\n\t        var i, j, nHi, sum;\n\t\n\t        var noiseLevel = Math.abs(spectrum.getNoiseLevel())*(options.thresholdFactor);\n\t\n\t        //console.log(\"noiseLevel \"+noiseLevel);\n\t        var gsdOptions = extend({},\n\t            {noiseLevel: noiseLevel,\n\t                minMaxRatio:0.01,\n\t                broadRatio:0.0025,\n\t                smoothY:true,\n\t                nL:4,\n\t                sgOptions:{windowSize: 9, polynomial: 3}\n\t            },\n\t            options.gsdOptions);\n\t\n\t        var data = spectrum.getXYData();\n\t        var peakList = GSD.gsd(data[0],data[1], gsdOptions);\n\t        var peakList = GSD.post.joinBroadPeaks(peakList,{width:0.25});\n\t        if(options.optimize)\n\t            peakList = GSD.post.optimizePeaks(peakList,data[0],data[1],gsdOptions.nL,\"lorentzian\");\n\t\n\t        peakList = this.clearList(peakList, noiseLevel);\n\t        var signals = this.detectSignals(peakList, spectrum, options.nH, options.integralFn);\n\t        //console.log(JSON.stringify(signals));\n\t        //Remove all the signals with small integral\n\t        if(options.clean||false){\n\t            for(var i=signals.length-1;i>=0;i--){\n\t                if(signals[i].integralData.value<0.5) {\n\t                    signals.splice(i, 1);\n\t                }\n\t            }\n\t        }\n\t        if(options.compile||false){\n\t            for(i=0;i<signals.length;i++){\n\t                //console.log(\"Sum \"+signals[i].integralData.value);\n\t                JAnalyzer.compilePattern(signals[i]);\n\t                //console.log(signals[i])\n\t                if(signals[i].maskPattern&&signals[i].multiplicity!=\"m\"\n\t                    && signals[i].multiplicity!=\"\"){\n\t                    //Create a new signal with the removed peaks\n\t                    nHi = 0;\n\t                    sum=0;\n\t                    var peaksO = [];\n\t                    for(j=signals[i].maskPattern.length-1;j>=0;j--){\n\t                        sum+=this.area(signals[i].peaks[j]);\n\t\n\t                        if(signals[i].maskPattern[j]===false) {\n\t                            var peakR = signals[i].peaks.splice(j,1)[0];\n\t                            peaksO.push({x:peakR.x, y:peakR.intensity, width:peakR.width});\n\t                            //peaksO.push(peakR);\n\t                            signals[i].mask.splice(j,1);\n\t                            signals[i].mask2.splice(j,1);\n\t                            signals[i].maskPattern.splice(j,1);\n\t                            signals[i].nbPeaks--;\n\t                            nHi+=this.area(peakR);\n\t                        }\n\t                    }\n\t                    if(peaksO.length>0){\n\t                        nHi=nHi*signals[i].integralData.value/sum;\n\t                        signals[i].integralData.value-=nHi;\n\t                        var peaks1 = [];\n\t                        for(var j=peaksO.length-1;j>=0;j--)\n\t                            peaks1.push(peaksO[j]);\n\t                        var newSignals = this.detectSignals(peaks1, spectrum, nHi, options.integralFn);\n\t\n\t                        for(j=0;j<newSignals.length;j++)\n\t                            signals.push(newSignals[j]);\n\t                    }\n\t                }\n\t            }\n\t            //console.log(signals);\n\t            this.updateIntegrals(signals, options.nH);\n\t        }\n\t        signals.sort(function(a,b){\n\t            return b.delta1- a.delta1\n\t        });\n\t        //Remove all the signals with small integral\n\t        if(options.clean||false){\n\t            for(var i=signals.length-1;i>=0;i--){\n\t                //console.log(signals[i]);\n\t                if(signals[i].integralData.value<0.5) {\n\t                    signals.splice(i, 1);\n\t                }\n\t            }\n\t        }\n\t\n\t        for(var i=0;i<signals.length;i++){\n\t            if(options.idPrefix&&options.idPrefix.length>0)\n\t                signals[i].signalID = options.idPrefix+\"_\"+(i+1);\n\t            else\n\t                signals[i].signalID = (i+1)+\"\";\n\t            signals[i]._highlight=[signals[i].signalID];\n\t        }\n\t\n\t        removeImpurities(signals, spectrum.getSolventName(),options.nH);\n\t\n\t        if(options.format===\"new\"){\n\t            var newSignals = new Array(signals.length);\n\t            for(var i=0;i<signals.length;i++){\n\t                var signal = signals[i];\n\t                newSignals[i] = {\n\t                    from : signal.integralData.from,\n\t                    to : signal.integralData.to,\n\t                    integral : signal.integralData.value,\n\t                    signal:[{\n\t                        delta:signal.delta1,\n\t                        nbAtoms:0,\n\t                        diaID:[],\n\t                        multiplicity:signal.multiplicity,\n\t                        peak:signal.peaks,\n\t                        kind:\"\",\n\t                        remark:\"\"\n\t                    }],\n\t                    signalID:signal.signalID,\n\t                    _highlight:signal._highlight\n\t\n\t                };\n\t                if(signal.nmrJs){\n\t                    newSignals[i].signal[0].j = signal.nmrJs;\n\t                }\n\t            }\n\t            signals = newSignals;\n\t        }\n\t\n\t        return signals;\n\t\n\t\n\t        /*var frequency = spectrum.observeFrequencyX();//getParamDouble(\"$BF1\",400);\n\t        var imp = this.labelPeaks(peakList, solvent, frequency);\n\t        return [peakList,imp];\n\t        */\n\t        //return createSignals(peakList,nH);\n\t    },\n\t\n\t    clearList:function(peakList, threshold){\n\t        for(var i=peakList.length-1;i>=0;i--){\n\t            if(Math.abs(peakList[i].y)<threshold){\n\t                peakList.splice(i,1);\n\t            }\n\t        }\n\t        return peakList;\n\t    },\n\t\n\t\n\t    /**\n\t     * This method implements a non linear sampling of the spectrum. The point close to\n\t     * the critic points are more sampled than the other ones.\n\t     * @param spectrum\n\t     * @param peaks\n\t     * @param rowWise\n\t     */\n\t    sampling: function(spectrum, peaks, rowWise){\n\t        var i0, ie, ic,i, j,nbPoints;\n\t        var xy = []\n\t        if(i0>ie){\n\t            var tmp = i0;\n\t            i0 = ie;\n\t            ie = tmp;\n\t        }\n\t        //Non linear sampling for each peak.\n\t        for(i=0;i<peaks.length;i++){\n\t            var more = true;\n\t            var nL = 4;\n\t            while(more) {\n\t                i0 = spectrum.unitsToArrayPoint(peaks[i][0] - peaks[i][2] * nL);\n\t                ie = spectrum.unitsToArrayPoint(peaks[i][0] + peaks[i][2] * nL);\n\t                ic = spectrum.unitsToArrayPoint(peaks[i][0]);\n\t                if (i0 > ie) {\n\t                    tmp = i0;\n\t                    i0 = ie;\n\t                    ie = tmp;\n\t                }\n\t                i0 = i0 < 0 ? 0 : i0;\n\t                ie = ie >= spectrum.getNbPoints() ? spectrum.getNbPoints() - 1 : ie;\n\t\n\t                if (ie - i0 < 10) {\n\t                    for (j = i0; j <= ie; j++) {\n\t                        xy.push([spectrum.getX(j), spectrum.getY(j)]);\n\t                    }\n\t                    more = false;\n\t                }\n\t                else {\n\t                    xy.push([spectrum.getX(i0), spectrum.getY(i0)]);\n\t                    xy.push([spectrum.getX(ie), spectrum.getY(ie)]);\n\t                    if (nL > 0.5) {\n\t                        nL -= 0.5;\n\t                    }\n\t                    else {\n\t                        nL /= 2;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        //console.log(xy);\n\t        xy.sort(function(a,b){\n\t            return a[0]-b[0];\n\t        });\n\t        //console.log(\"XX \"+xy.length);\n\t        var x=[],y=[];\n\t        var index =0;\n\t        if(rowWise){\n\t            x=[xy[0][0]],y=[xy[0][1]];\n\t            for(i=1;i<xy.length;i++){\n\t                if(x[index]!=xy[i][0]){\n\t                    x.push(xy[i][0]);\n\t                    y.push(xy[i][1]);\n\t                    index++;\n\t                }\n\t            }\n\t        }\n\t        else{\n\t            x=[[xy[0][0]]],y=[[xy[0][1]]];\n\t            for(i=1;i<xy.length;i++){\n\t                if(x[index][0]!=xy[i][0]){\n\t                    x.push([xy[i][0]]);\n\t                    y.push([xy[i][1]]);\n\t                    index++;\n\t                }\n\t            }\n\t        }\n\t        return [x,y];\n\t\n\t    },\n\t\n\t    getVector: function(spectrum, from, to, rowWise){\n\t        var i0 = spectrum.unitsToArrayPoint(from);\n\t        var ie = spectrum.unitsToArrayPoint(to);\n\t        var x = [];\n\t        var y = [];\n\t        if(i0>ie){\n\t            var tmp = i0;\n\t            i0 = ie;\n\t            ie = tmp;\n\t        }\n\t        i0=i0<0?0:i0;\n\t        ie=ie>=spectrum.getNbPoints()?spectrum.getNbPoints()-1:ie;\n\t        for(var i=i0;i<ie;i+=10){\n\t            if(rowWise){\n\t                y.push(spectrum.getY(i));\n\t                x.push(spectrum.getX(i));\n\t            }\n\t            else{\n\t                y.push([spectrum.getY(i)]);\n\t                x.push([spectrum.getX(i)]);\n\t            }\n\t        }\n\t        return [x,y];\n\t    },\n\t\n\t\n\t\n\t    updateLimits : function(signal){\n\t        if(signal.multiplicity!=\"m\" && signal.multiplicity!=\"\"){\n\t            //Remove the integral of the removed peaks\n\t            var peaksO = signal.peaks;\n\t            var nbPeaks0 = peaksO.length, index = 0, factor = 0, toRemove = 0;\n\t\n\t            for(var i=0;i<nbPeaks0;i++){\n\t                if(signal.maskPattern[i]===false)\n\t                    toRemove+=this.area(peaksO[i]);\n\t                factor+= this.area(peaksO[i]);\n\t            }\n\t            factor=signal.integralData.value/factor;\n\t            signal.integralData.value-=toRemove*factor;\n\t        }\n\t        return signal.integralData.value;\n\t    },\n\t\n\t    updateIntegrals : function(signals, nH){\n\t        var sumIntegral = 0,i,sumObserved=0;\n\t        for(i=0;i<signals.length;i++){\n\t            sumObserved+=Math.round(signals[i].integralData.value);\n\t        }\n\t        if(sumObserved!=nH){\n\t\n\t            sumIntegral=nH/sumObserved;\n\t            for(i=0;i<signals.length;i++){\n\t                signals[i].integralData.value*=sumIntegral;\n\t            }\n\t        }\n\t    },\n\t\n\t    /*\n\t     {\n\t     \"nbPeaks\":1,\"multiplicity\":\"\",\"units\":\"PPM\",\"startX\":3.43505,\"assignment\":\"\",\n\t     \"pattern\":\"s\",\"stopX\":3.42282,\"observe\":400.08,\"asymmetric\":false,\n\t     \"delta1\":3.42752,\n\t     \"integralData\":{\"to\":3.43505,\"value\":590586504,\"from\":3.42282},\n\t     \"nucleus\":\"1H\",\n\t     \"peaks\":[{\"intensity\":60066147,\"x\":3.42752}]\n\t     }\n\t     */\n\t    detectSignals: function(peakList, spectrum, nH, integralType){\n\t\n\t        var frequency = spectrum.observeFrequencyX();\n\t        var signals = [];\n\t        var signal1D = {};\n\t        var prevPeak = {x:100000,y:0,width:0},peaks=null;\n\t        var rangeX = 16/frequency;//Peaks withing this range are considered to belongs to the same signal1D\n\t        var spectrumIntegral = 0,cs,sum, i,j;\n\t        //console.log(\"RangeX \"+rangeX);\n\t        for(i=0;i<peakList.length;i++){\n\t            //console.log(peakList[i]);\n\t            if(Math.abs(peakList[i].x-prevPeak.x)>rangeX){\n\t                //console.log(typeof peakList[i].x+\" \"+typeof peakList[i].width);\n\t                signal1D = {\"nbPeaks\":1,\"units\":\"PPM\",\n\t                    \"startX\":peakList[i].x+peakList[i].width,\n\t                    \"stopX\":peakList[i].x-peakList[i].width,\n\t                    \"multiplicity\":\"\",\"pattern\":\"\",\n\t                    \"observe\":frequency,\"nucleus\":\"1H\",\n\t                    \"integralData\":{\"from\":peakList[i].x-peakList[i].width*3,\n\t                                    \"to\":peakList[i].x+peakList[i].width*3\n\t                                    //\"value\":this.area(peakList[i])\n\t                    },\n\t                    \"peaks\":[]};\n\t                signal1D.peaks.push({x:peakList[i].x,\"intensity\":peakList[i].y, width:peakList[i].width});\n\t                signals.push(signal1D);\n\t                //spectrumIntegral+=this.area(peakList[i]);\n\t            }\n\t            else{\n\t                var tmp = peakList[i].x-peakList[i].width;\n\t                signal1D.stopX = Math.min(signal1D.stopX,tmp);\n\t                tmp = peakList[i].x+peakList[i].width;\n\t                signal1D.stopX = Math.max(signal1D.stopX,tmp);\n\t                signal1D.nbPeaks++;\n\t                signal1D.peaks.push({x:peakList[i].x,\"intensity\":peakList[i].y, width:peakList[i].width});\n\t                //signal1D.integralData.value+=this.area(peakList[i]);\n\t                signal1D.integralData.from = Math.min(signal1D.integralData.from, peakList[i].x-peakList[i].width*3);\n\t                signal1D.integralData.to = Math.max(signal1D.integralData.to,peakList[i].x+peakList[i].width*3);\n\t                //spectrumIntegral+=this.area(peakList[i]);\n\t            }\n\t            prevPeak = peakList[i];\n\t        }\n\t        //Normalize the integral to the normalization parameter and calculate cs\n\t        for(i=0;i<signals.length;i++){\n\t            peaks = signals[i].peaks;\n\t            var integral = signals[i].integralData;\n\t            cs = 0;\n\t            sum = 0;\n\t\n\t            for(var j=0;j<peaks.length;j++){\n\t                cs+=peaks[j].x*this.area(peaks[j]);//.intensity;\n\t                sum+=this.area(peaks[j]);\n\t            }\n\t            signals[i].delta1 = cs/sum;\n\t\n\t            if(integralType==0)\n\t                integral.value = sum;\n\t            else {\n\t                integral.value=spectrum.getArea(integral.from,integral.to);//*nH/spectrumIntegral;\n\t            }\n\t            spectrumIntegral+=integral.value;\n\t\n\t        }\n\t        for(var i=0;i<signals.length;i++){\n\t            //console.log(integral.value);\n\t            var integral = signals[i].integralData;\n\t            integral.value*=nH/spectrumIntegral;\n\t        }\n\t\n\t        return signals;\n\t    },\n\t\n\t    area: function(peak){\n\t        return Math.abs(peak.intensity*peak.width*1.57)//1.772453851);\n\t    },\n\t\n\t    /**\n\t     Updates the score that a given impurity is present in the current spectrum. In this part I would expect\n\t     to have into account the multiplicity of the signal. Also the relative intensity of the signals.\n\t     THIS IS the KEY part of the algorithm!!!!!!!!!\n\t     */\n\t    updateScore:function(candidates, peakList, maxIntensity, frequency){\n\t        //You may do it to avoid this part.\n\t        //return 1;\n\t\n\t        //Check the multiplicity\n\t        var mul = \"\";\n\t        var j = 0,index, k, maxJppm=this.maxJ/frequency;\n\t        var min=0, indexMin=0, score=0;\n\t        for(var i=candidates.length-1;i>=0;i--){\n\t            mul = candidates[i][1];\n\t            j = candidates[i][2];\n\t            //console.log(candidates[i][4]);\n\t            index = candidates[i][4][0];\n\t            //console.log(peakList[index][0]+\" \"+mul+\" \"+j+\" \"+index);\n\t            //I guess we should try to identify the pattern in the nearby.\n\t            if(mul.indexOf(\"sep\")>=0){\n\t                if(peakList[index][1]>maxIntensity*0.33){\n\t                    candidates.splice(i,1);//Not a candidate anymore.\n\t                }\n\t            }else{\n\t                if(mul.indexOf(\"s\")>=0||mul.indexOf(\"X\")>=0){\n\t                    k=index-1;\n\t                    min=peakList[index][1];\n\t                    indexMin=index;\n\t                    while(k>=0&&Math.abs(peakList[index][0]-peakList[k][0])<0.025){\n\t                        if(peakList[k][1]<min){\n\t                            min=peakList[k][1];\n\t                            indexMin=k;\n\t                        }\n\t                        k--;\n\t                    }\n\t                    k=index+1;\n\t                    while(k<peakList.length&&Math.abs(peakList[index][0]-peakList[k][0])<0.025){\n\t                        if(peakList[k][1]<min){\n\t                            min=peakList[k][1];\n\t                            indexMin=k;\n\t                        }\n\t                        k++;\n\t                    }\n\t                    candidates[i][4][0]=indexMin;\n\t                    score+=1;\n\t                }\n\t            }\n\t            if(mul.indexOf(\"d\")>=0){\n\t                if(index>0&&index<peakList.length-1){\n\t                    var thisJ1 = Math.abs(Math.abs(peakList[index-1][0]-peakList[index][0])*frequency-j);\n\t                    var thisJ2 = Math.abs(Math.abs(peakList[index+1][0]-peakList[index][0])*frequency-j);\n\t                    var thisJ3 = Math.abs(Math.abs(peakList[index+1][0]-peakList[index-1][0])*frequency-j);\n\t                    if(thisJ1<2||thisJ2<2||thisJ3<2){\n\t                        if(thisJ1<thisJ2){\n\t                            if(thisJ1<thisJ3){\n\t                                candidates[i][4]=[index-1,index];\n\t                                score+=1;\n\t                            }\n\t                            else{\n\t                                candidates[i][4]=[index-1,index+1];\n\t                                score+=1;\n\t                            }\n\t                        }\n\t                        else{\n\t                            if(thisJ2<thisJ3){\n\t                                candidates[i][4]=[index,index+1];\n\t                                score+=1;\n\t                            }\n\t                            else{\n\t                                candidates[i][4]=[index-1,index+1];\n\t                                score+=1;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            if(mul.indexOf(\"t\")>=0){\n\t                //console.log(\"here\");\n\t                if(index>0&&index<peakList.length-1){\n\t                    var thisJ1 = Math.abs(Math.abs(peakList[index-1][0]-peakList[index][0])*frequency-j);\n\t                    var thisJ2 = Math.abs(Math.abs(peakList[index+1][0]-peakList[index][0])*frequency-j);\n\t                    var thisJ4 = Math.abs(Math.abs(peakList[index+1][0]-peakList[index+2][0])*frequency-j);\n\t                    //console.log(\"XX \"+thisJ1+\" \"+thisJ2);\n\t                    if(thisJ1<2){\n\t                        candidates[i][4]=[index-1, index];\n\t                        score+=0.5;\n\t                    }\n\t                    if(thisJ2<2){\n\t                        candidates[i][4].push(index+1);\n\t                        score+=0.5;\n\t                    }\n\t                    if(thisJ3<2){\n\t                        candidates[i][4].push(index+2);\n\t                        score+=0.5;\n\t                    }\n\t\n\t                }\n\t            }\n\t            if(mul.indexOf(\"q\")>=0){\n\t                if(index>1&&index<peakList.length-2){\n\t                    var thisJ1 = Math.abs(Math.abs(peakList[index-2][0]-peakList[index-1][0])*frequency-j);\n\t                    var thisJ2 = Math.abs(Math.abs(peakList[index-1][0]-peakList[index][0])*frequency-j);\n\t                    var thisJ3 = Math.abs(Math.abs(peakList[index+1][0]-peakList[index][0])*frequency-j);\n\t                    var thisJ4= Math.abs(Math.abs(peakList[index+2][0]-peakList[index+1][0])*frequency-j);\n\t                    if(thisJ1<2){\n\t                        candidates[i][4].push(index-2);\n\t                        score+=0.25;\n\t                    }\n\t                    if(thisJ2<2){\n\t                        candidates[i][4].push(index-1);\n\t                        score+=0.25;\n\t                    }\n\t                    if(thisJ3<2){\n\t                        candidates[i][4].push(index+1);\n\t                        score+=0.25;\n\t                    }\n\t                    if(thisJ4<2){\n\t                        candidates[i][4].push(index+2);\n\t                        score+=0.25;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        //console.log(score/candidates.length+ \" -> \"+candidates);\n\t        //Lets remove the candidates to be impurities.\n\t        //It would be equivalent to mark the peaks as valid again\n\t        if(score/candidates.length < 0.5){\n\t            for(var i=candidates.length-1;i>=0;i--){\n\t                candidates.splice(i,1);\n\t            }\n\t            return 0;\n\t        }\n\t        //Check the relative intensity\n\t        return 1;\n\t    },\n\t\n\t    score:function(value, gamma){\n\t        return Math.exp(-Math.pow(value/gamma,2)/2.0);\n\t    }\n\t\n\t}\n\t\n\tmodule.exports = PeakPicking;\n\t\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t/**\n\t * This library implements the J analyser described by Cobas et al in the paper:\n\t * A two-stage approach to automatic determination of 1H NMR coupling constants\n\t * Created by acastillo on 4/5/15.\n\t */\n\tvar JAnalyzer = {\n\t    pascalTriangle : [[0],[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]],\n\t    patterns: [\"s\",\"d\",\"t\",\"q\",\"quint\",\"h\",\"sept\",\"o\",\"n\"],\n\t    symRatio : 1.5,\n\t    maxErrorIter1 : 2.5,//Hz\n\t    maxErrorIter2 : 1,//Hz\n\t    DEBUG : false,\n\t\n\t    /**\n\t     * The compilation process implements at the first stage a normalization procedure described by Golotvin et al.\n\t     * embedding in peak-component-counting method described by Hoyes et al.\n\t     * @param signal\n\t     */\n\t    compilePattern : function(signal){\n\t        if(this.DEBUG)console.log(\"Debugin...\");\n\t\n\t        signal.multiplicity=\"m\";//By default the multiplicity is massive\n\t        // 1.1 symmetrize\n\t        // It will add a set of peaks(signal.peaksComp) to the signal that will be used during\n\t        // the compilation process. The unit of those peaks will be in Hz\n\t        signal.symRank = this.symmetrizeChoiseBest(signal,this.maxErrorIter1,1);\n\t        signal.asymmetric = true;\n\t       // console.log(signal.delta1+\" \"+signal.symRank);\n\t        //Is the signal symmetric?\n\t        if(signal.symRank>=0.95&&signal.peaksComp.length<32){\n\t            if(this.DEBUG)console.log(signal.delta1+ \" nbPeaks \"+signal.peaksComp.length);\n\t            signal.asymmetric = false;\n\t            var i,j,n,k=1,P1,Jc=[],n2,maxFlagged;\n\t            //Loop over the possible number of coupling contributing to the multiplet\n\t            for(n=0;n<9;n++){\n\t                if(this.DEBUG)console.log(\"Trying \"+n+\" couplings\");\n\t                //1.2 Normalize. It makes a deep copy of the peaks before to modify them.\n\t                var peaks = this.normalize(signal,n);\n\t                //signal.peaksCompX = peaks;\n\t                var validPattern = false;//It will change to true, when we find the good patter\n\t                //Lets check if the signal could be a singulet.\n\t                if(peaks.length == 1 && n === 0){\n\t                    validPattern=true;\n\t                }\n\t                else{\n\t                    if(peaks.length <= 1){\n\t                        continue;\n\t                    }\n\t                }\n\t                // 1.3 Establish a range for the Heights Hi [peaks.intensity*0.85,peaks.intensity*1.15];\n\t                var ranges = this.getRanges(peaks);\n\t                n2 = Math.pow(2,n);\n\t\n\t                if(this.DEBUG){\n\t                    console.log(\"ranges: \"+JSON.stringify(ranges));\n\t                    console.log(\"Target sum: \"+n2);\n\t                }\n\t\n\t                // 1.4 Find a combination of integer heights Hi, one from each Si, that sums to 2^n.\n\t                var heights = null;\n\t                while(!validPattern&&(heights = this.getNextCombination(ranges, n2))!==null){\n\t\n\t                    if(this.DEBUG){\n\t                        console.log(\"Possible pattern found with \"+n+\" couplings!!!\");\n\t                        console.log(heights);\n\t                    }\n\t                    // 2.1 Number the components of the multiplet consecutively from 1 to 2n,\n\t                    //starting at peak 1\n\t                    var numbering = new Array(heights.length);\n\t                    k=1;\n\t                    for(i=0;i<heights.length;i++){\n\t                        numbering[i]=new Array(heights[i]);\n\t                        for(j=0;j<heights[i];j++){\n\t                            numbering[i][j]=k++;\n\t                        }\n\t                    }\n\t                    if(this.DEBUG){\n\t                        console.log(\"Numbering: \"+JSON.stringify(numbering));\n\t                    }\n\t                    Jc = []; //The array to store the detected j-coupling\n\t                    // 2.2 Set j = 1; J1 = P2 - P1. Flag components 1 and 2 as accounted for.\n\t                    j=1;\n\t                    Jc.push(peaks[1].x-peaks[0].x);\n\t                    P1 = peaks[0].x;\n\t                    numbering[0].splice(0,1);//Flagged\n\t                    numbering[1].splice(0,1);//Flagged\n\t                    k=1;\n\t                    var nFlagged = 2;\n\t                    maxFlagged = Math.pow(2,n)-1;\n\t                    while(Jc.length<n&&nFlagged<maxFlagged&&k<peaks.length){\n\t                        if(this.DEBUG){\n\t                            console.log(\"New Jc\"+JSON.stringify(Jc));\n\t                            console.log(\"Aval. numbering \"+JSON.stringify(numbering));\n\t                        }\n\t                        // 4.1. Increment j. Set k to the number of the first unflagged component.\n\t                        j++;\n\t                        while(k<peaks.length&&numbering[k].length===0){\n\t                            k++;\n\t                        }\n\t                        if(k<peaks.length){\n\t                            // 4.2 Jj = Pk - P1.\n\t                            Jc.push(peaks[k].x-peaks[0].x);\n\t                            //Flag component k and, for each sum of the...\n\t                            numbering[k].splice(0,1);//Flageed\n\t                            nFlagged++;\n\t                            //Flag the other components of the multiplet\n\t                            for(var u=2;u<=j;u++){\n\t                                //TODO improve those loops\n\t                                var jSum = 0;\n\t                                for(i=0;i<u;i++){\n\t                                    jSum+=Jc[i];\n\t                                }\n\t                                for(i=1;i<numbering.length;i++){\n\t                                    //Maybe 0.25 Hz is too much?\n\t                                    if(Math.abs(peaks[i].x-(P1+jSum))<0.25){\n\t                                        numbering[i].splice(0,1);//Flageed\n\t                                        nFlagged++;\n\t                                        break;\n\t                                    }\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t                    //Calculate the ideal patter by using the extracted j-couplings\n\t                    var pattern = this.idealPattern(Jc);\n\t                    //Compare the ideal pattern with the proposed intensities.\n\t                    // All the intensities have to match to accept the multiplet\n\t                    validPattern = true;\n\t                    for(i=0;i<pattern.length;i++){\n\t                        if(pattern[i].intensity != heights[i])\n\t                            validPattern = false;\n\t                    }\n\t                    //More verbosity of the process\n\t                    if(this.DEBUG){\n\t                        console.log(\"Jc \"+JSON.stringify(Jc));\n\t                        console.log(\"Heights \"+JSON.stringify(heights));\n\t                        console.log(\"pattern \"+JSON.stringify(pattern));\n\t                        console.log(\"Valid? \"+validPattern);\n\t                    }\n\t                }\n\t                //If we found a valid pattern we should inform about the pattern.\n\t                if(validPattern){\n\t                    this.updateSignal(signal,Jc);\n\t                }\n\t            }\n\t        }\n\t\n\t        //Before to return, change the units of peaksComp from Hz to PPM again\n\t        for(i=0;i<signal.peaksComp.length;i++){\n\t            signal.peaksComp[i].x/=signal.observe;\n\t        }\n\t    },\n\t\n\t    updateSignal : function(signal, Jc){\n\t        //Update the limits of the signal\n\t        var peaks = signal.peaksComp;//Always in Hz\n\t        var nbPeaks = peaks.length;\n\t        signal.startX=peaks[0].x/signal.observe+peaks[0].width;\n\t        signal.stopX=peaks[nbPeaks-1].x/signal.observe-peaks[nbPeaks-1].width;\n\t        signal.integralData.to=peaks[0].x/signal.observe+peaks[0].width*3;\n\t        signal.integralData.from=peaks[nbPeaks-1].x/signal.observe-peaks[nbPeaks-1].width*3;\n\t\n\t        //Compile the pattern and format the constant couplings\n\t        signal.maskPattern = signal.mask2;\n\t        signal.multiplicity = this.abstractPattern(signal,Jc);\n\t        signal.pattern=signal.multiplicity;//Our library depends on this parameter, but it is old\n\t        //console.log(signal);\n\t        if(this.DEBUG)\n\t            console.log(\"Final j-couplings: \"+JSON.stringify(Jc));\n\t    },\n\t\n\t    /**\n\t     * Returns the multiplet in the compact format\n\t     */\n\t    abstractPattern : function(signal,Jc){\n\t        var tol = 0.05,i, pattern = \"\", cont = 1;\n\t        var newNmrJs = [];\n\t        if(Jc&&Jc.length>0){\n\t            Jc.sort(function(a,b){\n\t                return a-b;\n\t            });\n\t            for(i=0;i<Jc.length-1;i++){\n\t                if(Math.abs(Jc[i]-Jc[i+1])<tol){\n\t                    cont++;\n\t                }\n\t                else{\n\t                    newNmrJs.push({\"coupling\":Math.abs(Jc[i]),\"multiplicity\":this.patterns[cont]});\n\t                    pattern+=this.patterns[cont];\n\t                    cont=1;\n\t                }\n\t            }\n\t            newNmrJs.push({\"coupling\":Math.abs(Jc[i]),\"multiplicity\":this.patterns[cont]});\n\t            pattern+=this.patterns[cont];\n\t            signal.nmrJs =  newNmrJs;\n\t        }\n\t        else{\n\t            pattern=\"s\";\n\t            if(Math.abs(signal.startX-signal.stopX)*signal.observe>16){\n\t                pattern=\"br s\"\n\t            }\n\t        }\n\t        return pattern;\n\t    },\n\t\n\t    /**\n\t     *This function creates an ideal pattern from the given J-couplings\n\t     */\n\t    idealPattern : function(Jc){\n\t        var hsum = Math.pow(2,Jc.length),i,j;\n\t        var pattern = [{x:0,intensity:hsum}];\n\t        //To split the initial height\n\t        for(i=0;i<Jc.length;i++){\n\t            for(j=pattern.length-1;j>=0;j--){\n\t                pattern.push({x:pattern[j].x+Jc[i]/2,\n\t                    intensity:pattern[j].intensity/2});\n\t                pattern[j].x = pattern[j].x-Jc[i]/2;\n\t                pattern[j].intensity = pattern[j].intensity/2;\n\t            }\n\t        }\n\t        //To sum the heights in the same positions\n\t        pattern.sort(function compare(a,b) { return a.x-b.x});\n\t        for(j=pattern.length-2;j>=0;j--){\n\t            if(Math.abs(pattern[j].x-pattern[j+1].x)<0.1){\n\t                pattern[j].intensity+= pattern[j+1].intensity\n\t                pattern.splice(j+1,1);\n\t            }\n\t        }\n\t        return pattern;\n\t    },\n\t\n\t    /**\n\t     * Find a combination of integer heights Hi, one from each Si, that sums to 2n.\n\t     */\n\t    getNextCombination : function(ranges, value){\n\t        var half = Math.ceil(ranges.values.length/2), lng = ranges.values.length;\n\t        var sum = 0,i,ok;\n\t        while(sum!=value){\n\t            //Update the indexes to point at the next possible combination\n\t            ok = false;\n\t            var leftIndex = 0;\n\t            while(!ok){\n\t                ok = true;\n\t                ranges.currentIndex[ranges.active]++;\n\t                if(ranges.currentIndex[ranges.active]>=ranges.values[ranges.active].length){\n\t                    //In this case, there is no more possible combinations\n\t                    if(ranges.active+1==half){\n\t                        return null;\n\t                    }\n\t                    else{\n\t                        //If this happens we need to try the next active peak\n\t                        ranges.currentIndex[ranges.active]=0;\n\t                        ok=false;\n\t                        ranges.active++;\n\t                    }\n\t                }\n\t                else{\n\t                    ranges.active=0;\n\t                }\n\t            }\n\t            // Sum the heights for this combination\n\t            sum=0;\n\t            for(i=0;i<half;i++){\n\t                sum+= ranges.values[i][ranges.currentIndex[i]]*2;\n\t            }\n\t            if(ranges.values.length%2!==0){\n\t                sum-= ranges.values[half-1][ranges.currentIndex[half-1]];\n\t            }\n\t            if(this.DEBUG){\n\t                console.log(ranges.currentIndex);\n\t                console.log(sum+\" \"+value);\n\t            }\n\t        }\n\t        //If the sum is equal to the expected value, fill the array to return\n\t        if(sum==value){\n\t            var heights = new Array(lng);\n\t            for(i=0;i<half;i++){\n\t                heights[i] = ranges.values[i][ranges.currentIndex[i]];\n\t                heights[lng-i-1] = ranges.values[i][ranges.currentIndex[i]];\n\t            }\n\t            return heights;\n\t        }\n\t        return null;\n\t    },\n\t\n\t    /**\n\t     * This function generates the possible values that each peak can contribute\n\t     * to the multiplet.\n\t     * @param peaks\n\t     * @returns {{values: Array, currentIndex: Array, active: number}}\n\t     */\n\t    getRanges : function(peaks){\n\t        var ranges = new Array(peaks.length);\n\t        var currentIndex = new Array(peaks.length);\n\t        var min,max;\n\t        ranges[0] = [1];\n\t        ranges[peaks.length-1] = [1];\n\t        currentIndex[0]=-1;\n\t        currentIndex[peaks.length-1] = 0;\n\t        for(var i=1;i<peaks.length-1;i++){\n\t            min = Math.round(peaks[i].intensity*0.85);\n\t            max = Math.round(peaks[i].intensity*1.15);\n\t            ranges[i] =[];\n\t            for(var j=min;j<=max;j++){\n\t                ranges[i].push(j);\n\t            }\n\t            currentIndex[i]=0;\n\t        }\n\t        return {values:ranges, currentIndex:currentIndex, active:0};\n\t    },\n\t    /**\n\t     * Performs a symmetrization of the signal by using different aproximations to the center.\n\t     * It will return the result of the symmetrization that removes less peaks from the signal\n\t     * @param signal\n\t     * @param maxError\n\t     * @param iteration\n\t     * @returns {*}\n\t     */\n\t    symmetrizeChoiseBest : function(signal,maxError,iteration){\n\t        var symRank1 = this.symmetrize(signal,maxError,iteration);\n\t        var tmpPeaks = signal.peaksComp;\n\t        var tmpMask = signal.mask;\n\t        var cs = signal.delta1;\n\t        signal.delta1 = (signal.peaks[0].x+signal.peaks[signal.peaks.length-1].x)/2;\n\t        var symRank2 = this.symmetrize(signal,maxError,iteration);\n\t        if(signal.peaksComp.length>tmpPeaks.length)\n\t            return symRank2;\n\t        else{\n\t            signal.delta1 = cs;\n\t            signal.peaksComp = tmpPeaks;\n\t            signal.mask = tmpMask;\n\t            return symRank1;\n\t        }\n\t\n\t    },\n\t    /**\n\t     * This function will return a set of symmetric peaks that will\n\t     * be the enter point for the patter compilation process.\n\t     */\n\t    symmetrize : function(signal, maxError, iteration){\n\t        //Before to symmetrize we need to keep only the peaks that possibly conforms the multiplete\n\t        var max, min, avg, ratio, avgWidth, j;\n\t        var peaks = new Array(signal.peaks.length);\n\t        //Make a deep copy of the peaks and convert PPM ot HZ\n\t        for(j=0;j<peaks.length;j++){\n\t            peaks[j]= {x:signal.peaks[j].x*signal.observe,\n\t                intensity:signal.peaks[j].intensity,\n\t                width:signal.peaks[j].width};\n\t        }\n\t        //Join the peaks that are closer than 0.25 Hz\n\t        for(j=peaks.length-2;j>=0;j--){\n\t            if(Math.abs(peaks[j].x-peaks[j+1].x)<0.25){\n\t                peaks[j].x = (peaks[j].x*peaks[j].intensity+peaks[j+1].x*peaks[j+1].intensity);\n\t                peaks[j].intensity = peaks[j].intensity+peaks[j+1].intensity;\n\t                peaks[j].x/=peaks[j].intensity;\n\t                peaks[j].intensity/=2;\n\t                peaks[j].width+=peaks[j+1].width;\n\t                peaks.splice(j+1,1);\n\t            }\n\t        }\n\t        signal.peaksComp = peaks;\n\t        var nbPeaks = peaks.length;\n\t        var mask = new Array(nbPeaks);\n\t        signal.mask = mask;\n\t        var left=0, right=peaks.length-1, cs = signal.delta1*signal.observe, middle = [(peaks[0].x+peaks[nbPeaks-1].x)/2,1];\n\t        maxError = this.error(Math.abs(cs-middle[0]));\n\t        var heightSum = 0;\n\t        //We try to symmetrize the extreme peaks. We consider as candidates for symmetricing those which have\n\t        //ratio smaller than 3\n\t        for(var i=0;i<nbPeaks;i++){\n\t            mask[i]= true;\n\t            heightSum+=signal.peaks[i].intensity;\n\t        }\n\t\n\t        while(left<=right){\n\t            mask[left] = true;\n\t            mask[right] = true;\n\t            if(left==right){\n\t                if(nbPeaks>2&&Math.abs(peaks[left].x-cs)>maxError){\n\t                    mask[left] = false;\n\t                }\n\t            }\n\t            else{\n\t                max = Math.max(peaks[left].intensity,peaks[right].intensity);\n\t                min = Math.min(peaks[left].intensity,peaks[right].intensity);\n\t                ratio = max/min;\n\t                if(ratio>this.symRatio){\n\t                    if(peaks[left].intensity==min){\n\t                        mask[left] = false;\n\t                        right++;\n\t                    }\n\t                    else{\n\t                        mask[right] = false;\n\t                        left--;\n\t                    }\n\t                }\n\t                else{\n\t                    var diffL = Math.abs(peaks[left].x-cs);\n\t                    var diffR = Math.abs(peaks[right].x-cs);\n\t\n\t                    if(Math.abs(diffL-diffR)<maxError){\n\t                        //avg = (peaks[left].intensity+peaks[right].intensity)/2;\n\t                        avg = Math.min(peaks[left].intensity,peaks[right].intensity);\n\t                        avgWidth = Math.min(peaks[left].width,peaks[right].width);\n\t                        peaks[left].intensity=peaks[right].intensity=avg;\n\t                        peaks[left].width=peaks[right].width=avgWidth;\n\t                        middle=[middle[0]+((peaks[right].x+peaks[left].x)/2), middle[1]+1];\n\t                    }\n\t                    else{\n\t                        if(Math.max(diffL,diffR)==diffR){\n\t                            mask[right] = false;\n\t                            left--;\n\t                        }\n\t                        else{\n\t                            mask[left] = false;\n\t                            right++;\n\t                        }\n\t                    }\n\t                    if(this.DEBUG){\n\t                        console.log(\"MaxError: \"+maxError+\" \"+middle[0]+\" \"+middle[1]);\n\t                        console.log(iteration+\" CS: \"+cs+\" Hz \"+cs/signal.observe+\" PPM\");\n\t                        console.log(\"Middle: \"+(middle[0]/middle[1])+\" Hz \"+(middle[0]/middle[1])/signal.observe+\" PPM\");\n\t                        console.log(diffL+ \" \"+diffR);\n\t                        console.log(Math.abs(diffL-diffR));\n\t                        console.log(JSON.stringify(peaks));\n\t                        console.log(JSON.stringify(mask));\n\t                    }\n\t                }\n\t            }\n\t            left++;\n\t            right--;\n\t            //Only alter cs if it is the first iteration of the sym process.\n\t            if(iteration==1){\n\t                cs = this.chemicalShift(peaks, mask);\n\t                //There is not more available peaks\n\t                if(isNaN(cs)){ return 0;}\n\t            }\n\t            maxError = this.error(Math.abs(cs-middle[0]/middle[1]));\n\t        }\n\t        //To remove the weak peaks and recalculate the cs\n\t        for(i=nbPeaks-1;i>=0;i--){\n\t            if(mask[i]===false){\n\t                peaks.splice(i,1);\n\t            }\n\t        }\n\t        cs = this.chemicalShift(peaks);\n\t        if(isNaN(cs)){ return 0;}\n\t        signal.delta1 = cs/signal.observe;\n\t        //Now, the peak should be symmetric in heights, but we need to know if it is symmetric in x\n\t        var symFactor = 0,weight = 0;\n\t        if(peaks.length>1){\n\t            for(i=Math.ceil(peaks.length/2)-1;i>=0;i--){\n\t                symFactor+=(3+Math.min(Math.abs(peaks[i].x-cs),Math.abs(peaks[peaks.length-1-i].x-cs)))\n\t                /(3+Math.max(Math.abs(peaks[i].x-cs),Math.abs(peaks[peaks.length-1-i].x-cs)))*peaks[i].intensity;\n\t                weight+=peaks[i].intensity;\n\t            }\n\t            symFactor/=weight;\n\t        }\n\t        else{\n\t            if(peaks.length==1)\n\t                symFactor=1;\n\t        }\n\t        var newSumHeights = 0;\n\t        for(i=0;i<peaks.length;i++){\n\t            newSumHeights+=peaks[i].intensity;\n\t        }\n\t        symFactor-=(heightSum-newSumHeights)/heightSum*0.12; //Removed peaks penalty\n\t        if(this.DEBUG){\n\t            console.log(\"Penalty \"+(heightSum-newSumHeights)/heightSum*0.12);\n\t            console.log(\"cs: \"+(cs/signal.observe)+\" symFactor: \"+symFactor);\n\t        }\n\t        //Sometimes we need a second opinion after the first symmetrization.\n\t        if(symFactor>0.8&&symFactor<0.97&&iteration<2){\n\t            return this.symmetrize(signal, this.maxErrorIter2, 2);\n\t        }{\n\t            //Center the given pattern at cs and symmetrize x\n\t            if(peaks.length>1) {\n\t                var weight = 0, dxi;\n\t                for (i = Math.ceil(peaks.length / 2) - 1; i >= 0; i--) {\n\t                    dxi = (peaks[i].x - peaks[peaks.length - 1 - i].x)/2.0;\n\t                    peaks[i].x =cs+dxi;\n\t                    peaks[peaks.length - 1 - i].x=cs-dxi;\n\t                }\n\t            }\n\t        }\n\t        return symFactor;\n\t    },\n\t\n\t    error : function(value){\n\t        var maxError = value*2.5;\n\t        if(maxError<0.75)\n\t            maxError = 0.75;\n\t        if(maxError > 3)\n\t            maxError = 3;\n\t        return maxError;\n\t    },\n\t    /**\n\t     * 2 stages normalizarion of the peaks heights to Math.pow(2,n).\n\t     * Creates a new mask with the peaks that could contribute to the multiplete\n\t     * @param signal\n\t     * @param n\n\t     * @returns {*}\n\t     */\n\t    normalize : function(signal, n){\n\t        //Perhaps this is slow\n\t        var peaks = JSON.parse(JSON.stringify(signal.peaksComp));\n\t        var norm = 0,norm2=0,i;//Math.pow(2,n);\n\t        for(i=0;i<peaks.length;i++){\n\t            norm+= peaks[i].intensity;\n\t        }\n\t        norm=Math.pow(2,n)/norm;\n\t        signal.mask2 = JSON.parse(JSON.stringify(signal.mask));\n\t        //console.log(\"Mask0 \"+JSON.stringify(signal.mask2));\n\t        var index=signal.mask2.length-1;\n\t        for(i=peaks.length-1;i>=0;i--){\n\t            peaks[i].intensity*= norm;\n\t            while(index>=0&&signal.mask2[index]===false)\n\t                index--;\n\t            if(peaks[i].intensity<0.75){\n\t                if(this.DEBUG)\n\t                    console.log(\"Peak \"+i+\" does not seem to belong to this multiplet \"+peaks[i].intensity);\n\t                peaks.splice(i,1);\n\t                signal.mask2[index]=false;\n\t            }\n\t            else{\n\t                norm2+= peaks[i].intensity;\n\t            }\n\t            index--;\n\t        }\n\t        norm2=Math.pow(2,n)/norm2;\n\t        for(i=peaks.length-1;i>=0;i--){\n\t            peaks[i].intensity*= norm2;\n\t        }\n\t        //console.log(\"Mask1 \"+JSON.stringify(signal.mask2));\n\t        if(this.DEBUG) console.log(JSON.stringify(peaks));\n\t        return peaks;\n\t    },\n\t\n\t    /**\n\t     * Calculates the chemical shift as the weighted sum of the peaks\n\t     * @param peaks\n\t     * @param mask\n\t     * @returns {number}\n\t     */\n\t    chemicalShift : function(peaks, mask){\n\t        var sum=0,cs= 0, i, area;\n\t        if(mask){\n\t            for(i=0;i<peaks.length;i++){\n\t                //console.log(mask[i]);\n\t                if(mask[i]===true){\n\t                    area = this.area(peaks[i]);\n\t                    sum+=area;\n\t                    cs+=area*peaks[i].x;\n\t                }\n\t            }\n\t        }\n\t        else{\n\t            for(i=0;i<peaks.length;i++){\n\t                area = this.area(peaks[i]);\n\t                sum+=area;\n\t                cs+=area*peaks[i].x;\n\t            }\n\t        }\n\t        return cs/sum;\n\t    },\n\t\n\t    area: function(peak){\n\t        return Math.abs(peak.intensity*peak.width*1.57)//1.772453851);\n\t    }\n\t}\n\t\n\tmodule.exports = JAnalyzer;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tmodule.exports.post = __webpack_require__(13);\n\tmodule.exports.gsd = __webpack_require__(36);\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Created by acastillo on 9/6/15.\n\t */\n\tvar Opt = __webpack_require__(14);\n\t\n\tfunction sampleFunction(from, to, x, y, lastIndex){\n\t    var nbPoints = x.length;\n\t    var sampleX = [];\n\t    var sampleY = [];\n\t    var direction = Math.sign(x[1]-x[0]);//Direction of the derivative\n\t    if(direction==-1){\n\t        lastIndex[0]= x.length-1;\n\t    }\n\t\n\t    var delta = Math.abs(to-from)/2;\n\t    var mid = (from+to)/2;\n\t    var stop = false;\n\t    var index = lastIndex[0];\n\t    while(!stop&&index<nbPoints&&index>=0){\n\t        if(Math.abs(x[index]-mid)<=delta){\n\t            sampleX.push(x[index]);\n\t            sampleY.push(y[index]);\n\t            index+=direction;\n\t        }\n\t        //It is outside the range.\n\t        else{\n\t\n\t            if(Math.sign(mid-x[index])==1){\n\t                //We'll reach the mid going in the current direction\n\t                index+=direction;\n\t            }\n\t            else{\n\t                //There is not more peaks in the current range\n\t                stop=true;\n\t            }\n\t        }\n\t        //console.log(sampleX);\n\t    }\n\t    lastIndex[0]=index;\n\t    return [sampleX, sampleY];\n\t}\n\t\n\tfunction optimizePeaks(peakList,x,y,n, fnType){\n\t    var i, j, lastIndex=[0];\n\t    var groups = groupPeaks(peakList,n);\n\t    var result = [];\n\t    var factor = 1;\n\t    if(fnType==\"gaussian\")\n\t        factor = 1.17741;//From https://en.wikipedia.org/wiki/Gaussian_function#Properties\n\t    for(i=0;i<groups.length;i++){\n\t        var peaks = groups[i].group;\n\t        if(peaks.length>1){\n\t            //Multiple peaks\n\t            //console.log(\"Pending group of overlaped peaks \"+peaks.length);\n\t            //console.log(\"here1\");\n\t            //console.log(groups[i].limits);\n\t            var sampling = sampleFunction(groups[i].limits[0]-groups[i].limits[1],groups[i].limits[0]+groups[i].limits[1],x,y,lastIndex);\n\t            //console.log(sampling);\n\t            if(sampling[0].length>5){\n\t                var error = peaks[0].width/1000;\n\t                var opts = [  3,    100, error, error, error, error*10, error*10,    11,    9,        1 ];\n\t                //var gauss = Opt.optimizeSingleGaussian(sampling[0], sampling[1], opts, peaks);\n\t                var optPeaks = [];\n\t                if(fnType==\"gaussian\")\n\t                    optPeaks = Opt.optimizeGaussianSum(sampling, peaks, opts);\n\t                else{\n\t                    if(fnType==\"lorentzian\"){\n\t                        optPeaks = Opt.optimizeLorentzianSum(sampling, peaks, opts);\n\t                    }\n\t                }\n\t                //console.log(optPeak);\n\t                for(j=0;j<optPeaks.length;j++){\n\t                    result.push({x:optPeaks[j][0][0],y:optPeaks[j][1][0],width:optPeaks[j][2][0]*factor});\n\t                }\n\t            }\n\t        }\n\t        else{\n\t            //Single peak\n\t            peaks = peaks[0];\n\t            var sampling = sampleFunction(peaks.x-n*peaks.width,\n\t                peaks.x+n*peaks.width,x,y,lastIndex);\n\t            //console.log(\"here2\");\n\t            //console.log(groups[i].limits);\n\t            if(sampling[0].length>5){\n\t                var error = peaks.width/1000;\n\t                var opts = [  3,    100, error, error, error, error*10, error*10,    11,    9,        1 ];\n\t                //var gauss = Opt.optimizeSingleGaussian(sampling[0], sampling[1], opts, peaks);\n\t                //var gauss = Opt.optimizeSingleGaussian([sampling[0],sampling[1]], peaks, opts);\n\t                var optPeak = [];\n\t                if(fnType==\"gaussian\")\n\t                    var optPeak = Opt.optimizeSingleGaussian([sampling[0],sampling[1]], peaks,  opts);\n\t                else{\n\t                    if(fnType==\"lorentzian\"){\n\t                        var optPeak = Opt.optimizeSingleLorentzian([sampling[0],sampling[1]], peaks,  opts);\n\t                    }\n\t                }\n\t                //console.log(optPeak);\n\t                result.push({x:optPeak[0][0],y:optPeak[1][0],width:optPeak[2][0]*factor}); // From https://en.wikipedia.org/wiki/Gaussian_function#Properties}\n\t            }\n\t        }\n\t\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction groupPeaks(peakList,nL){\n\t    var group = [];\n\t    var groups = [];\n\t    var i, j;\n\t    var limits = [peakList[0].x,nL*peakList[0].width];\n\t    var upperLimit, lowerLimit;\n\t    //Merge forward\n\t    for(i=0;i<peakList.length;i++){\n\t        //If the 2 things overlaps\n\t        if(Math.abs(peakList[i].x-limits[0])<(nL*peakList[i].width+limits[1])){\n\t            //Add the peak to the group\n\t            group.push(peakList[i]);\n\t            //Update the group limits\n\t            upperLimit = limits[0]+limits[1];\n\t            if(peakList[i].x+nL*peakList[i].width>upperLimit){\n\t                upperLimit = peakList[i].x+nL*peakList[i].width;\n\t            }\n\t            lowerLimit = limits[0]-limits[1];\n\t            if(peakList[i].x-nL*peakList[i].width<lowerLimit){\n\t                lowerLimit = peakList[i].x-nL*peakList[i].width;\n\t            }\n\t            limits = [(upperLimit+lowerLimit)/2,Math.abs(upperLimit-lowerLimit)/2];\n\t\n\t        }\n\t        else{\n\t            groups.push({limits:limits,group:group});\n\t            //var optmimalPeak = fitSpectrum(group,limits,spectrum);\n\t            group=[peakList[i]];\n\t            limits = [peakList[i].x,nL*peakList[i].width];\n\t        }\n\t    }\n\t    groups.push({limits:limits,group:group});\n\t    //Merge backward\n\t    for(i =groups.length-2;i>=0;i--){\n\t        //The groups overlaps\n\t        if(Math.abs(groups[i].limits[0]-groups[i+1].limits[0])<\n\t            (groups[i].limits[1]+groups[i+1].limits[1])/2){\n\t            for(j=0;j<groups[i+1].group.length;j++){\n\t                groups[i].group.push(groups[i+1].group[j]);\n\t            }\n\t            upperLimit = groups[i].limits[0]+groups[i].limits[1];\n\t            if(groups[i+1].limits[0]+groups[i+1].limits[1]>upperLimit){\n\t                upperLimit = groups[i+1].limits[0]+groups[i+1].limits[1];\n\t            }\n\t            lowerLimit = groups[i].limits[0]-groups[i].limits[1];\n\t            if(groups[i+1].limits[0]-groups[i+1].limits[1]<lowerLimit){\n\t                lowerLimit = groups[i+1].limits[0]-groups[i+1].limits[1];\n\t            }\n\t            //console.log(limits);\n\t            groups[i].limits = [(upperLimit+lowerLimit)/2,Math.abs(upperLimit-lowerLimit)/2];\n\t\n\t            groups.splice(i+1,1);\n\t        }\n\t    }\n\t    return groups;\n\t}\n\t/**\n\t * This function try to join the peaks that seems to belong to a broad signal in a single broad peak.\n\t * @param peakList\n\t * @param options\n\t */\n\tfunction joinBroadPeaks(peakList, options){\n\t    var width = options.width;\n\t    var broadLines=[];\n\t    //Optimize the possible broad lines\n\t    var max=0, maxI=0,count=1;\n\t    var isPartOf = false;\n\t    for(var i=peakList.length-1;i>=0;i--){\n\t        if(peakList[i].soft){\n\t            broadLines.push(peakList.splice(i,1)[0]);\n\t        }\n\t    }\n\t    //Push a feak peak\n\t    broadLines.push({x:Number.MAX_VALUE});\n\t\n\t    var candidates = [[broadLines[0].x,\n\t                        broadLines[0].y]];\n\t    var indexes = [0];\n\t\n\t    for(var i=1;i<broadLines.length;i++){\n\t        //console.log(broadLines[i-1].x+\" \"+broadLines[i].x);\n\t        if(Math.abs(broadLines[i-1].x-broadLines[i].x)<width){\n\t            candidates.push([broadLines[i].x,broadLines[i].y]);\n\t            if(broadLines[i].y>max){\n\t                max = broadLines[i].y;\n\t                maxI = i;\n\t            }\n\t            indexes.push(i);\n\t            count++;\n\t        }\n\t        else{\n\t            if(count>2){\n\t                var fitted =  Opt.optimizeSingleLorentzian(candidates,\n\t                    {x: broadLines[maxI].x, y:max, width: Math.abs(candidates[0][0]-candidates[candidates.length-1][0])});\n\t                //console.log(fitted)\n\t                peakList.push({x:fitted[0][0],y:fitted[1][0],width:fitted[2][0],soft:false});\n\t\n\t            }\n\t            else{\n\t                //Put back the candidates to the signals list\n\t                indexes.map(function(index){peakList.push(broadLines[index])});\n\t            }\n\t            candidates = [[broadLines[i].x,broadLines[i].y]];\n\t            indexes = [i];\n\t            max = broadLines[i].y;\n\t            maxI = i;\n\t            count = 1;\n\t        }\n\t    }\n\t\n\t    peakList.sort(function (a, b) {\n\t        return a.x - b.x;\n\t    });\n\t\n\t    return peakList;\n\t\n\t}\n\t\n\t/*if(options.broadRatio>0){\n\t var broadLines=[[Number.MAX_VALUE,0,0]];\n\t //Optimize the possible broad lines\n\t var max=0, maxI=0,count=0;\n\t var candidates = [],broadLinesS=[];\n\t var isPartOf = false;\n\t\n\t for(var i=broadLines.length-1;i>0;i--){\n\t //console.log(broadLines[i][0]+\" \"+rangeX+\" \"+Math.abs(broadLines[i-1][0]-broadLines[i][0]));\n\t if(Math.abs(broadLines[i-1][0]-broadLines[i][0])<rangeX){\n\t\n\t candidates.push(broadLines[i]);\n\t if(broadLines[i][1]>max){\n\t max = broadLines[i][1];\n\t maxI = i;\n\t }\n\t count++;\n\t }\n\t else{\n\t isPartOf = true;\n\t if(count>30){ // TODO, an options ?\n\t isPartOf = false;\n\t //for(var j=0;j<signals.length;j++){\n\t //    if(Math.abs(broadLines[maxI][0]-signals[j][0])<rangeX)\n\t //       isPartOf = true;\n\t //    }\n\t //console.log(\"Was part of \"+isPartOf);\n\t }\n\t if(isPartOf){\n\t for(var j=0;j<candidates.length;j++){\n\t signals.push([candidates[j][0], candidates[j][1], dx]);\n\t }\n\t }\n\t else{\n\t var fitted =  Opt.optimizeSingleLorentzian(candidates,{x:candidates[maxI][0],\n\t width:Math.abs(candidates[0][0]-candidates[candidates.length-1][0])},\n\t []);\n\t //console.log(fitted);\n\t signals.push([fitted[0][0],fitted[0][1],fitted[0][2]]);\n\t }\n\t candidates = [];\n\t max = 0;\n\t maxI = 0;\n\t count = 0;\n\t }\n\t }\n\t }*/\n\t\n\tmodule.exports={optimizePeaks:optimizePeaks,joinBroadPeaks:joinBroadPeaks};\n\t\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar LM = __webpack_require__(15);\n\tvar math = LM.Matrix.algebra;\n\tvar Matrix = __webpack_require__(27);\n\t\n\t/**\n\t * This function calculates the spectrum as a sum of lorentzian functions. The Lorentzian\n\t * parameters are divided in 3 batches. 1st: centers; 2nd: heights; 3th: widths;\n\t * @param t Ordinate values\n\t * @param p Lorentzian parameters\n\t * @param c Constant parameters(Not used)\n\t * @returns {*}\n\t */\n\tfunction sumOfLorentzians(t,p,c){\n\t    var nL = p.length/3,factor,i, j,p2, cols = t.rows;\n\t    var result = Matrix.zeros(t.length,1);\n\t\n\t    for(i=0;i<nL;i++){\n\t        p2 = Math.pow(p[i+nL*2][0]/2,2);\n\t        factor = p[i+nL][0]*p2;\n\t        for(j=0;j<cols;j++){\n\t            result[j][0]+=factor/(Math.pow(t[j][0]-p[i][0],2)+p2);\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\t/**\n\t * This function calculates the spectrum as a sum of gaussian functions. The Gaussian\n\t * parameters are divided in 3 batches. 1st: centers; 2nd: height; 3th: std's;\n\t * @param t Ordinate values\n\t * @param p Gaussian parameters\n\t * @param c Constant parameters(Not used)\n\t * @returns {*}\n\t */\n\tfunction sumOfGaussians(t,p,c){\n\t    var nL = p.length/3,factor,i, j, cols = t.rows;\n\t    var result = Matrix.zeros(t.length,1);\n\t\n\t    for(i=0;i<nL;i++){\n\t        factor = p[i+nL*2][0]*p[i+nL*2][0]/2;\n\t        for(j=0;j<cols;j++){\n\t            result[j][0]+=p[i+nL][0]*Math.exp(-(t[i][0]-p[i][0])*(t[i][0]-p[i][0])/factor);\n\t        }\n\t    }\n\t    return result;\n\t}\n\t/**\n\t * Single 4 parameter lorentzian function\n\t * @param t Ordinate values\n\t * @param p Lorentzian parameters\n\t * @param c Constant parameters(Not used)\n\t * @returns {*}\n\t */\n\tfunction singleLorentzian(t,p,c){\n\t    var factor = p[1][0]*Math.pow(p[2][0]/2,2);\n\t    var rows = t.rows;\n\t    var result = new Matrix(t.rows, t.columns);\n\t    for(var i=0;i<rows;i++){\n\t        result[i][0]=factor/(Math.pow(t[i][0]-p[0][0],2)+Math.pow(p[2][0]/2,2));\n\t    }\n\t    return result;\n\t}\n\t\n\t/**\n\t * Single 3 parameter gaussian function\n\t * @param t Ordinate values\n\t * @param p Gaussian parameters [mean, height, std]\n\t * @param c Constant parameters(Not used)\n\t * @returns {*}\n\t */\n\tfunction singleGaussian(t,p,c){\n\t    var factor2 = p[2][0]*p[2][0]/2;\n\t    var rows = t.rows;\n\t    var result = new Matrix(t.rows, t.columns);\n\t    for(var i=0;i<rows;i++){\n\t        result[i][0]=p[1][0]*Math.exp(-(t[i][0]-p[0][0])*(t[i][0]-p[0][0])/factor2);\n\t    }\n\t    return result;\n\t}\n\t\n\t/**\n\t * * Fits a set of points to a Lorentzian function. Returns the center of the peak, the width at half height, and the height of the signal.\n\t * @param data,[y]\n\t * @returns {*[]}\n\t */\n\tfunction optimizeSingleLorentzian(xy, peak, opts) {\n\t    var xy2 = parseData(xy);\n\t    var t = xy2[0];\n\t    var y_data = xy2[1];\n\t    var maxY = xy2[2];\n\t    var nbPoints = t.columns, i;\n\t\n\t    var weight = [nbPoints / Math.sqrt(y_data.dot(y_data))];\n\t\n\t    var opts=Object.create(opts || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ]);\n\t    //var opts = [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ];\n\t    var consts = [ ];\n\t    var dt = Math.abs(t[0][0]-t[1][0]);// optional vector of constants\n\t    var dx = new Matrix([[-dt/10000],[-1e-3],[-dt/10000]]);//-Math.abs(t[0][0]-t[1][0])/100;\n\t    var p_init = new Matrix([[peak.x],[1],[peak.width]]);\n\t    var p_min = new Matrix([[peak.x-dt],[0.75],[peak.width/4]]);\n\t    var p_max = new Matrix([[peak.x+dt],[1.25],[peak.width*4]]);\n\t\n\t    var p_fit = LM.optimize(singleLorentzian,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);\n\t\n\t\n\t    p_fit = p_fit.p;\n\t    return [p_fit[0],[p_fit[1][0]*maxY],p_fit[2]];\n\t\n\t}\n\t\n\t/**\n\t * Fits a set of points to a gaussian bell. Returns the mean of the peak, the std and the height of the signal.\n\t * @param data,[y]\n\t * @returns {*[]}\n\t */\n\tfunction optimizeSingleGaussian(xy, peak, opts) {\n\t    var xy2 = parseData(xy);\n\t    var t = xy2[0];\n\t    var y_data = xy2[1];\n\t    var maxY = xy2[2];\n\t\n\t    var nbPoints = t.columns, i;\n\t\n\t    var weight = [nbPoints / Math.sqrt(y_data.dot(y_data))];\n\t\n\t    var opts=Object.create(opts || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ]);\n\t    //var opts = [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ];\n\t    var consts = [ ];                         // optional vector of constants\n\t    var dt = Math.abs(t[0][0]-t[1][0]);\n\t    var dx = new Matrix([[-dt/10000],[-1e-3],[-dt/10000]]);//-Math.abs(t[0][0]-t[1][0])/100;\n\t\n\t    var dx = new Matrix([[-Math.abs(t[0][0]-t[1][0])/1000],[-1e-3],[-peak.width/1000]]);\n\t    var p_init = new Matrix([[peak.x],[1],[peak.width]]);\n\t    var p_min = new Matrix([[peak.x-dt],[0.75],[peak.width/4]]);\n\t    var p_max = new Matrix([[peak.x+dt],[1.25],[peak.width*4]]);\n\t    //var p_min = new Matrix([[peak.x-peak.width/4],[0.75],[peak.width/3]]);\n\t    //var p_max = new Matrix([[peak.x+peak.width/4],[1.25],[peak.width*3]]);\n\t\n\t    var p_fit = LM.optimize(singleGaussian,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);\n\t    p_fit = p_fit.p;\n\t    return [p_fit[0],[p_fit[1][0]*maxY],p_fit[2]];\n\t}\n\t\n\t\n\t/**\n\t *\n\t * @param xy A two column matrix containing the x and y data to be fitted\n\t * @param group A set of initial lorentzian parameters to be optimized [center, heigth, half_width_at_half_height]\n\t * @returns {Array} A set of final lorentzian parameters [center, heigth, hwhh*2]\n\t */\n\tfunction optimizeLorentzianSum(xy, group, opts){\n\t    var xy2 = parseData(xy);\n\t    var t = xy2[0];\n\t    var y_data = xy2[1];\n\t    var maxY = xy2[2];\n\t    var nbPoints = t.columns, i;\n\t\n\t    var weight = [nbPoints / math.sqrt(y_data.dot(y_data))];\n\t    var opts=Object.create(opts || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ]);\n\t    var consts = [ ];// optional vector of constants\n\t\n\t    var nL = group.length;\n\t    var p_init = new Matrix(nL*3,1);\n\t    var p_min =  new Matrix(nL*3,1);\n\t    var p_max =  new Matrix(nL*3,1);\n\t    var dx = new Matrix(nL*3,1);\n\t    var dt = Math.abs(t[0][0]-t[1][0]);\n\t    for( i=0;i<nL;i++){\n\t        p_init[i][0] = group[i].x;\n\t        p_init[i+nL][0] = 1;\n\t        p_init[i+2*nL][0] = group[i].width;\n\t\n\t        p_min[i][0] = group[i].x-dt;//-group[i].width/4;\n\t        p_min[i+nL][0] = 0;\n\t        p_min[i+2*nL][0] = group[i].width/4;\n\t\n\t        p_max[i][0] = group[i].x+dt;//+group[i].width/4;\n\t        p_max[i+nL][0] = 1.5;\n\t        p_max[i+2*nL][0] = group[i].width*4;\n\t\n\t        dx[i][0] = -dt/1000;\n\t        dx[i+nL][0] = -1e-3;\n\t        dx[i+2*nL][0] = -dt/1000;\n\t    }\n\t\n\t    var dx = -Math.abs(t[0][0]-t[1][0])/10000;\n\t    var p_fit = LM.optimize(sumOfLorentzians, p_init, t, y_data, weight, dx, p_min, p_max, consts, opts);\n\t    p_fit=p_fit.p;\n\t    //Put back the result in the correct format\n\t    var result = new Array(nL);\n\t    for( i=0;i<nL;i++){\n\t        result[i]=[p_fit[i],[p_fit[i+nL][0]*maxY],p_fit[i+2*nL]];\n\t    }\n\t\n\t    return result;\n\t\n\t}\n\t\n\t/**\n\t *\n\t * @param xy A two column matrix containing the x and y data to be fitted\n\t * @param group A set of initial lorentzian parameters to be optimized [center, heigth, half_width_at_half_height]\n\t * @returns {Array} A set of final lorentzian parameters [center, heigth, hwhh*2]\n\t */\n\tfunction optimizeGaussianSum(xy, group, opts){\n\t    var xy2 = parseData(xy);\n\t    var t = xy2[0];\n\t    var y_data = xy2[1];\n\t    var maxY = xy2[2];\n\t    var nbPoints = t.rows,i;\n\t\n\t    var weight = new Matrix(nbPoints,1);//[nbPoints / math.sqrt(y_data.dot(y_data))];\n\t    var k = nbPoints / math.sqrt(y_data.dot(y_data));\n\t    for(i=0;i<nbPoints;i++){\n\t        weight[i][0]=k;///(y_data[i][0]);\n\t        //weight[i][0]=k*(2-y_data[i][0]);\n\t    }\n\t\n\t    var opts=Object.create(opts || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        2 ]);\n\t    //var opts=[  3,    100, 1e-5, 1e-6, 1e-6, 1e-6, 1e-6,    11,    9,        1 ];\n\t    var consts = [ ];// optional vector of constants\n\t\n\t    var nL = group.length;\n\t    var p_init = new Matrix(nL*3,1);\n\t    var p_min =  new Matrix(nL*3,1);\n\t    var p_max =  new Matrix(nL*3,1);\n\t    var dx = new Matrix(nL*3,1);\n\t    var dt = Math.abs(t[0][0]-t[1][0]);\n\t    for( i=0;i<nL;i++){\n\t        p_init[i][0] = group[i].x;\n\t        p_init[i+nL][0] = group[i].y/maxY;\n\t        p_init[i+2*nL][0] = group[i].width;\n\t\n\t        p_min[i][0] = group[i].x-dt;\n\t        p_min[i+nL][0] = group[i].y*0.8/maxY;\n\t        p_min[i+2*nL][0] = group[i].width/2;\n\t\n\t        p_max[i][0] = group[i].x+dt;\n\t        p_max[i+nL][0] = group[i].y*1.2/maxY;\n\t        p_max[i+2*nL][0] = group[i].width*2;\n\t\n\t        dx[i][0] = -dt/1000;\n\t        dx[i+nL][0] = -1e-3;\n\t        dx[i+2*nL][0] = -dt/1000;\n\t    }\n\t    //console.log(t);\n\t    var p_fit = LM.optimize(sumOfLorentzians,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);\n\t    p_fit = p_fit.p;\n\t    //Put back the result in the correct format\n\t    var result = new Array(nL);\n\t    for( i=0;i<nL;i++){\n\t        result[i]=[p_fit[i],[p_fit[i+nL][0]*maxY],p_fit[i+2*nL]];\n\t    }\n\t\n\t    return result;\n\t\n\t}\n\t/**\n\t *\n\t * Converts the given input to the required x, y column matrices. y data is normalized to max(y)=1\n\t * @param xy\n\t * @returns {*[]}\n\t */\n\tfunction parseData(xy){\n\t    var nbSeries = xy.length;\n\t    var t = null;\n\t    var y_data = null, x,y;\n\t    var maxY = 0, i,j;\n\t\n\t    if(nbSeries==2){\n\t        //Looks like row wise matrix [x,y]\n\t        var nbPoints = xy[0].length;\n\t        if(nbPoints<3)\n\t            throw new SizeException(nbPoints);\n\t        else{\n\t            t = new Matrix(nbPoints,1);\n\t            y_data = new Matrix(nbPoints,1);\n\t            x = xy[0];\n\t            y = xy[1];\n\t            if(typeof x[0] === \"number\"){\n\t                for(i=0;i<nbPoints;i++){\n\t                    t[i][0]=x[i];\n\t                    y_data[i][0]=y[i];\n\t                    if(y[i]>maxY)\n\t                        maxY = y[i];\n\t                }\n\t            }\n\t            else{\n\t                //It is a colum matrix\n\t                if(typeof x[0] === \"object\"){\n\t                    for(i=0;i<nbPoints;i++){\n\t                        t[i][0]=x[i][0];\n\t                        y_data[i][0]=y[i][0];\n\t                        if(y[i][0]>maxY)\n\t                            maxY = y[i][0];\n\t                    }\n\t                }\n\t\n\t            }\n\t\n\t        }\n\t    }\n\t    else{\n\t        //Looks like a column wise matrix [[x],[y]]\n\t        var nbPoints = nbSeries;\n\t        if(nbPoints<3)\n\t            throw new SizeException(nbPoints);\n\t        else {\n\t            t = new Matrix(nbPoints, 1);\n\t            y_data = new Matrix(nbPoints, 1);\n\t            for (i = 0; i < nbPoints; i++) {\n\t                t[i][0] = xy[i][0];\n\t                y_data[i][0] = xy[i][1];\n\t                if(y_data[i][0]>maxY)\n\t                    maxY = y_data[i][0];\n\t            }\n\t        }\n\t    }\n\t    for (i = 0; i < nbPoints; i++) {\n\t        y_data[i][0]/=maxY;\n\t    }\n\t    return [t,y_data,maxY];\n\t}\n\t\n\tfunction sizeException(nbPoints) {\n\t    return new RangeError(\"Not enough points to perform the optimization: \"+nbPoints +\"< 3\");\n\t}\n\t\n\tmodule.exports.optimizeSingleLorentzian = optimizeSingleLorentzian;\n\tmodule.exports.optimizeLorentzianSum = optimizeLorentzianSum;\n\tmodule.exports.optimizeSingleGaussian = optimizeSingleGaussian;\n\tmodule.exports.optimizeGaussianSum = optimizeGaussianSum;\n\tmodule.exports.singleGaussian = singleGaussian;\n\tmodule.exports.singleLorentzian = singleLorentzian;\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(16);\n\tmodule.exports.Matrix = __webpack_require__(17);\n\tmodule.exports.Matrix.algebra = __webpack_require__(26);\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Created by acastillo on 8/5/15.\n\t */\n\tvar Matrix = __webpack_require__(17);\n\tvar math = __webpack_require__(26);\n\t\n\tvar DEBUG = false;\n\t/** Levenberg Marquardt curve-fitting: minimize sum of weighted squared residuals\n\t ----------  INPUT  VARIABLES  -----------\n\t func   = function of n independent variables, 't', and m parameters, 'p',\n\t returning the simulated model: y_hat = func(t,p,c)\n\t p      = n-vector of initial guess of parameter values\n\t t      = m-vectors or matrix of independent variables (used as arg to func)\n\t y_dat  = m-vectors or matrix of data to be fit by func(t,p)\n\t weight = weighting vector for least squares fit ( weight >= 0 ) ...\n\t inverse of the standard measurement errors\n\t Default:  sqrt(d.o.f. / ( y_dat' * y_dat ))\n\t dp     = fractional increment of 'p' for numerical derivatives\n\t dp(j)>0 central differences calculated\n\t dp(j)<0 one sided 'backwards' differences calculated\n\t dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n\t Default:  0.001;\n\t p_min  = n-vector of lower bounds for parameter values\n\t p_max  = n-vector of upper bounds for parameter values\n\t c      = an optional matrix of values passed to func(t,p,c)\n\t opts   = vector of algorithmic parameters\n\t parameter    defaults    meaning\n\t opts(1)  =  prnt            3        >1 intermediate results; >2 plots\n\t opts(2)  =  MaxIter      10*Npar     maximum number of iterations\n\t opts(3)  =  epsilon_1       1e-3     convergence tolerance for gradient\n\t opts(4)  =  epsilon_2       1e-3     convergence tolerance for parameters\n\t opts(5)  =  epsilon_3       1e-3     convergence tolerance for Chi-square\n\t opts(6)  =  epsilon_4       1e-2     determines acceptance of a L-M step\n\t opts(7)  =  lambda_0        1e-2     initial value of L-M paramter\n\t opts(8)  =  lambda_UP_fac   11       factor for increasing lambda\n\t opts(9)  =  lambda_DN_fac    9       factor for decreasing lambda\n\t opts(10) =  Update_Type      1       1: Levenberg-Marquardt lambda update\n\t 2: Quadratic update\n\t 3: Nielsen's lambda update equations\n\t\n\t ----------  OUTPUT  VARIABLES  -----------\n\t p       = least-squares optimal estimate of the parameter values\n\t X2      = Chi squared criteria\n\t sigma_p = asymptotic standard error of the parameters\n\t sigma_y = asymptotic standard error of the curve-fit\n\t corr    = correlation matrix of the parameters\n\t R_sq    = R-squared cofficient of multiple determination\n\t cvg_hst = convergence history\n\t\n\t Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. 22 Sep 2013\n\t modified from: http://octave.sourceforge.net/optim/function/leasqr.html\n\t using references by\n\t Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\t Sam Roweis       http://www.cs.toronto.edu/~roweis/notes/lm.pdf\n\t Manolis Lourakis http://www.ics.forth.gr/~lourakis/levmar/levmar.pdf\n\t Hans Nielson     http://www2.imm.dtu.dk/~hbn/publ/TR9905.ps\n\t Mathworks        optimization toolbox reference manual\n\t K. Madsen, H.B., Nielsen, and O. Tingleff\n\t http://www2.imm.dtu.dk/pubdb/views/edoc_download.php/3215/pdf/imm3215.pdf\n\t */\n\tvar LM = {\n\t\n\t    optimize: function(func,p,t,y_dat,weight,dp,p_min,p_max,c,opts){\n\t\n\t        var tensor_parameter = 0;\t\t\t// set to 1 of parameter is a tensor\n\t\n\t        var iteration  = 0;\t\t\t// iteration counter\n\t        //func_calls = 0;\t\t\t// running count of function evaluations\n\t\n\t        if((typeof p[0])!=\"object\"){\n\t            for(var i=0;i< p.length;i++){\n\t                p[i]=[p[i]];\n\t            }\n\t\n\t        }\n\t        //p = p(:); y_dat = y_dat(:);\t\t// make column vectors\n\t        var i,k;\n\t        var eps = 2^-52;\n\t        var Npar   = p.length;//length(p); \t\t\t// number of parameters\n\t        var Npnt   = y_dat.length;//length(y_dat);\t\t// number of data points\n\t        var p_old  = Matrix.zeros(Npar,1);\t\t// previous set of parameters\n\t        var y_old  = Matrix.zeros(Npnt,1);\t\t// previous model, y_old = y_hat(t;p_old)\n\t        var X2     = 1e-2/eps;\t\t\t// a really big initial Chi-sq value\n\t        var X2_old = 1e-2/eps;\t\t\t// a really big initial Chi-sq value\n\t        var J =  Matrix.zeros(Npnt,Npar);\n\t\n\t\n\t        if (t.length != y_dat.length) {\n\t            console.log('lm.m error: the length of t must equal the length of y_dat');\n\t\n\t            length_t = t.length;\n\t            length_y_dat = y_dat.length;\n\t            var X2 = 0, corr = 0, sigma_p = 0, sigma_y = 0, R_sq = 0, cvg_hist = 0;\n\t            if (!tensor_parameter) {\n\t                return;\n\t            }\n\t        }\n\t\n\t        weight = weight||Math.sqrt((Npnt-Npar+1)/(math.multiply(math.transpose(y_dat),y_dat)));\n\t        dp = dp || 0.001;\n\t        p_min   = p_min || math.multiply(Math.abs(p),-100);\n\t        p_max   = p_max || math.multiply(Math.abs(p),100);\n\t        c = c || 1;\n\t        // Algorithmic Paramters\n\t        //prnt MaxIter  eps1  eps2  epx3  eps4  lam0  lamUP lamDN UpdateType\n\t        opts = opts ||[  3,10*Npar, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2, 11, 9, 1 ];\n\t\n\t        var prnt          = opts[0];\t// >1 intermediate results; >2 plots\n\t        var MaxIter       = opts[1];\t// maximum number of iterations\n\t        var epsilon_1     = opts[2];\t// convergence tolerance for gradient\n\t        var epsilon_2     = opts[3];\t// convergence tolerance for parameter\n\t        var epsilon_3     = opts[4];\t// convergence tolerance for Chi-square\n\t        var epsilon_4     = opts[5];\t// determines acceptance of a L-M step\n\t        var lambda_0      = opts[6];\t// initial value of damping paramter, lambda\n\t        var lambda_UP_fac = opts[7];\t// factor for increasing lambda\n\t        var lambda_DN_fac = opts[8];\t// factor for decreasing lambda\n\t        var Update_Type   = opts[9];\t// 1: Levenberg-Marquardt lambda update\n\t        // 2: Quadratic update\n\t        // 3: Nielsen's lambda update equations\n\t\n\t        if ( tensor_parameter && prnt == 3 ) prnt = 2;\n\t\n\t\n\t        if(!dp.length || dp.length == 1){\n\t            var dp_array = new Array(Npar);\n\t            for(var i=0;i<Npar;i++)\n\t                dp_array[i]=[dp];\n\t            dp=dp_array;\n\t        }\n\t\n\t        // indices of the parameters to be fit\n\t        var idx   = [];\n\t        for(i=0;i<dp.length;i++){\n\t            if(dp[i][0]!=0){\n\t                idx.push(i);\n\t            }\n\t        }\n\t\n\t        var Nfit = idx.length;\t\t\t// number of parameters to fit\n\t        var stop = false;\t\t\t\t// termination flag\n\t\n\t        var weight_sq = null;\n\t        //console.log(weight);\n\t        if ( !weight.length || weight.length < Npnt )\t{\n\t            // squared weighting vector\n\t            //weight_sq = ( weight(1)*ones(Npnt,1) ).^2;\n\t            //console.log(\"weight[0] \"+typeof weight[0]);\n\t            var tmp = math.multiply(Matrix.ones(Npnt,1),weight[0]);\n\t            weight_sq = math.dotMultiply(tmp,tmp);\n\t        }\n\t        else{\n\t            //weight_sq = (weight(:)).^2;\n\t            weight_sq = math.dotMultiply(weight,weight);\n\t        }\n\t\n\t\n\t        // initialize Jacobian with finite difference calculation\n\t        //console.log(\"J \"+weight_sq);\n\t        var result = this.lm_matx(func,t,p_old,y_old,1,J,p,y_dat,weight_sq,dp,c);\n\t        var JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n\t        //[JtWJ,JtWdy,X2,y_hat,J] = this.lm_matx(func,t,p_old,y_old,1,J,p,y_dat,weight_sq,dp,c);\n\t        //console.log(JtWJ);\n\t\n\t        if ( Math.max(Math.abs(JtWdy)) < epsilon_1 ){\n\t            console.log(' *** Your Initial Guess is Extremely Close to Optimal ***')\n\t            console.log(' *** epsilon_1 = ', epsilon_1);\n\t            stop = true;\n\t        }\n\t\n\t\n\t        switch(Update_Type){\n\t            case 1: // Marquardt: init'l lambda\n\t                lambda  = lambda_0;\n\t                break;\n\t            default:    // Quadratic and Nielsen\n\t                lambda  = lambda_0 * Math.max(math.diag(JtWJ));\n\t                nu=2;\n\t        }\n\t        //console.log(X2);\n\t        X2_old = X2; // previous value of X2\n\t        //console.log(MaxIter+\" \"+Npar);\n\t        //var cvg_hst = Matrix.ones(MaxIter,Npar+3);\t\t// initialize convergence history\n\t        var h = null;\n\t        while ( !stop && iteration <= MaxIter ) {\t\t// --- Main Loop\n\t            iteration = iteration + 1;\n\t            // incremental change in parameters\n\t            switch(Update_Type){\n\t                case 1:\t\t\t\t\t// Marquardt\n\t                    //h = ( JtWJ + lambda * math.diag(math.diag(JtWJ)) ) \\ JtWdy;\n\t                    //h = math.multiply(math.inv(JtWdy),math.add(JtWJ,math.multiply(lambda,math.diag(math.diag(Npar)))));\n\t                    h = math.solve(math.add(JtWJ,math.multiply(math.diag(math.diag(JtWJ)),lambda)),JtWdy);\n\t                    break;\n\t                default:\t\t\t\t\t// Quadratic and Nielsen\n\t                    //h = ( JtWJ + lambda * math.eye(Npar) ) \\ JtWdy;\n\t\n\t                    h = math.solve(math.add(JtWJ,math.multiply( Matrix.eye(Npar),lambda)),JtWdy);\n\t            }\n\t\n\t            /*for(var k=0;k< h.length;k++){\n\t             h[k]=[h[k]];\n\t             }*/\n\t            //console.log(\"h \"+h);\n\t            //h=math.matrix(h);\n\t            //  big = max(abs(h./p)) > 2;\n\t            //this is a big step\n\t            // --- Are parameters [p+h] much better than [p] ?\n\t            var hidx = new Array(idx.length);\n\t            for(k=0;k<idx.length;k++){\n\t                hidx[k]=h[idx[k]];\n\t            }\n\t            var p_try = math.add(p, hidx);// update the [idx] elements\n\t\n\t            for(k=0;k<p_try.length;k++){\n\t                p_try[k][0]=Math.min(Math.max(p_min[k][0],p_try[k][0]),p_max[k][0]);\n\t            }\n\t            // p_try = Math.min(Math.max(p_min,p_try),p_max);           // apply constraints\n\t\n\t            var delta_y = math.subtract(y_dat, func(t,p_try,c));       // residual error using p_try\n\t            //func_calls = func_calls + 1;\n\t            //X2_try = delta_y' * ( delta_y .* weight_sq );  // Chi-squared error criteria\n\t\n\t            var X2_try = math.multiply(math.transpose(delta_y),math.dotMultiply(delta_y,weight_sq));\n\t\n\t            if ( Update_Type == 2 ){  \t\t\t  // Quadratic\n\t                //    One step of quadratic line update in the h direction for minimum X2\n\t                //var alpha =  JtWdy'*h / ( (X2_try - X2)/2 + 2*JtWdy'*h ) ;\n\t                var JtWdy_th = math.multiply(math.transpose(JtWdy),h);\n\t                var alpha =  math.multiply(JtWdy_th,math.inv(math.add(math.multiply(math.subtract(X2_try - X2),1/2)),math.multiply(JtWdy_th,2)));//JtWdy'*h / ( (X2_try - X2)/2 + 2*JtWdy'*h ) ;\n\t\n\t                h = math.multiply(alpha, h);\n\t                for(var k=0;k<idx.length;k++){\n\t                    hidx[k]=h[idx[k]];\n\t                }\n\t\n\t                p_try = math.add(p ,hidx);                     // update only [idx] elements\n\t                p_try = math.min(math.max(p_min,p_try),p_max);          // apply constraints\n\t\n\t                delta_y = math.subtract(y_dat, func(t,p_try,c));      // residual error using p_try\n\t                // func_calls = func_calls + 1;\n\t                //X2_try = delta_y' * ( delta_y .* weight_sq ); // Chi-squared error criteria\n\t                X2_try = math.multiply(math.transpose(delta_y), mat.dotMultiply(delta_y, weight_sq));\n\t            }\n\t\n\t            //rho = (X2 - X2_try) / ( 2*h' * (lambda * h + JtWdy) ); // Nielsen\n\t            var rho = (X2-X2_try)/math.multiply(math.multiply(math.transpose(h),2),math.add(math.multiply(lambda, h),JtWdy));\n\t            //console.log(\"rho \"+rho);\n\t            if ( rho > epsilon_4 ) {\t\t// it IS significantly better\n\t                //console.log(\"Here\");\n\t                dX2 = X2 - X2_old;\n\t                X2_old = X2;\n\t                p_old = p;\n\t                y_old = y_hat;\n\t                p = p_try;\t\t\t// accept p_try\n\t\n\t                result = this.lm_matx(func, t, p_old, y_old, dX2, J, p, y_dat, weight_sq, dp, c);\n\t                JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n\t                // decrease lambda ==> Gauss-Newton method\n\t\n\t                switch (Update_Type) {\n\t                    case 1:\t\t\t\t\t\t\t// Levenberg\n\t                        lambda = Math.max(lambda / lambda_DN_fac, 1.e-7);\n\t                        break;\n\t                    case 2:\t\t\t\t\t\t\t// Quadratic\n\t                        lambda = Math.max(lambda / (1 + alpha), 1.e-7);\n\t                        break;\n\t                    case 3:\t\t\t\t\t\t\t// Nielsen\n\t                        lambda = math.multiply(Math.max(1 / 3, 1 - (2 * rho - 1) ^ 3),lambda);\n\t                        nu = 2;\n\t                        break;\n\t                }\n\t            }\n\t            else {\t\t\t\t\t// it IS NOT better\n\t                X2 = X2_old;\t\t\t// do not accept p_try\n\t                if (iteration%(2 * Npar)==0) {\t// rank-1 update of Jacobian\n\t                    result = this.lm_matx(func, t, p_old, y_old, -1, J, p, y_dat, weight_sq, dp, c);\n\t                    JtWJ = result.JtWJ,JtWdy=result.JtWdy,dX2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n\t                }\n\t\n\t                // increase lambda  ==> gradient descent method\n\t                switch (Update_Type) {\n\t                    case 1:\t\t\t\t\t\t\t// Levenberg\n\t                        lambda = Math.min(lambda * lambda_UP_fac, 1.e7);\n\t                        break;\n\t                    case 2:\t\t\t\t\t\t\t// Quadratic\n\t                        lambda = lambda + Math.abs((X2_try - X2) / 2 / alpha);\n\t                        break;\n\t                    case 3:\t\t\t\t\t\t// Nielsen\n\t                        lambda = lambda * nu;\n\t                        nu = 2 * nu;\n\t                        break;\n\t                }\n\t            }\n\t        }// --- End of Main Loop\n\t\n\t        // --- convergence achieved, find covariance and confidence intervals\n\t\n\t        // equal weights for paramter error analysis\n\t        weight_sq = math.multiply(math.multiply(math.transpose(delta_y),delta_y), Matrix.ones(Npnt,1));\n\t\n\t        weight_sq.apply(function(i,j){\n\t            weight_sq[i][j] = (Npnt-Nfit+1)/weight_sq[i][j];\n\t        });\n\t        //console.log(weight_sq);\n\t        result = this.lm_matx(func,t,p_old,y_old,-1,J,p,y_dat,weight_sq,dp,c);\n\t        JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n\t\n\t        /*if nargout > 2\t\t\t\t// standard error of parameters\n\t         covar = inv(JtWJ);\n\t         sigma_p = sqrt(diag(covar));\n\t         end\n\t\n\t         if nargout > 3\t\t\t\t// standard error of the fit\n\t         //  sigma_y = sqrt(diag(J * covar * J'));\t// slower version of below\n\t         sigma_y = zeros(Npnt,1);\n\t         for i=1:Npnt\n\t         sigma_y(i) = J(i,:) * covar * J(i,:)';\n\t         end\n\t         sigma_y = sqrt(sigma_y);\n\t         end\n\t\n\t         if nargout > 4\t\t\t\t// parameter correlation matrix\n\t         corr = covar ./ [sigma_p*sigma_p'];\n\t         end\n\t\n\t         if nargout > 5\t\t\t\t// coefficient of multiple determination\n\t         R_sq = corrcoef([y_dat y_hat]);\n\t         R_sq = R_sq(1,2).^2;\n\t         end\n\t\n\t         if nargout > 6\t\t\t\t// convergence history\n\t         cvg_hst = cvg_hst(1:iteration,:);\n\t         end*/\n\t\n\t        // endfunction  # ---------------------------------------------------------- LM\n\t\n\t        return { p:p, X2:X2};\n\t    },\n\t\n\t    lm_FD_J:function(func,t,p,y,dp,c) {\n\t        // J = lm_FD_J(func,t,p,y,{dp},{c})\n\t        //\n\t        // partial derivatives (Jacobian) dy/dp for use with lm.m\n\t        // computed via Finite Differences\n\t        // Requires n or 2n function evaluations, n = number of nonzero values of dp\n\t        // -------- INPUT VARIABLES ---------\n\t        // func = function of independent variables, 't', and parameters, 'p',\n\t        //        returning the simulated model: y_hat = func(t,p,c)\n\t        // t  = m-vector of independent variables (used as arg to func)\n\t        // p  = n-vector of current parameter values\n\t        // y  = func(t,p,c) n-vector initialised by user before each call to lm_FD_J\n\t        // dp = fractional increment of p for numerical derivatives\n\t        //      dp(j)>0 central differences calculated\n\t        //      dp(j)<0 one sided differences calculated\n\t        //      dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n\t        //      Default:  0.001;\n\t        // c  = optional vector of constants passed to y_hat = func(t,p,c)\n\t        //---------- OUTPUT VARIABLES -------\n\t        // J  = Jacobian Matrix J(i,j)=dy(i)/dp(j)\ti=1:n; j=1:m\n\t\n\t        //   Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. November 2005\n\t        //   modified from: ftp://fly.cnuce.cnr.it/pub/software/octave/leasqr/\n\t        //   Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\t\n\t        var m = y.length;\t\t\t// number of data points\n\t        var n = p.length;\t\t\t// number of parameters\n\t\n\t        dp = dp || math.multiply( Matrix.ones(n, 1), 0.001);\n\t\n\t        var ps = p.clone();//JSON.parse(JSON.stringify(p));\n\t        //var ps = $.extend(true, [], p);\n\t        var J = new Matrix(m,n), del =new Array(n);         // initialize Jacobian to Zero\n\t\n\t        for (var j = 0;j < n; j++) {\n\t            //console.log(j+\" \"+dp[j]+\" \"+p[j]+\" \"+ps[j]+\" \"+del[j]);\n\t            del[j] = dp[j]*(1+Math.abs(p[j][0]));  // parameter perturbation\n\t            p[j] = [ps[j][0]+del[j]];\t      // perturb parameter p(j)\n\t            //console.log(j+\" \"+dp[j]+\" \"+p[j]+\" \"+ps[j]+\" \"+del[j]);\n\t\n\t            if (del[j] != 0){\n\t                y1 = func(t, p, c);\n\t                //func_calls = func_calls + 1;\n\t                if (dp[j][0] < 0) {\t\t// backwards difference\n\t                    //J(:,j) = math.dotDivide(math.subtract(y1, y),del[j]);//. / del[j];\n\t                    //console.log(del[j]);\n\t                    //console.log(y);\n\t                    var column = math.dotDivide(math.subtract(y1, y),del[j]);\n\t                    for(var k=0;k< m;k++){\n\t                        J[k][j]=column[k][0];\n\t                    }\n\t                    //console.log(column);\n\t                }\n\t                else{\n\t                    p[j][0] = ps[j][0] - del[j];\n\t                    //J(:,j) = (y1 - feval(func, t, p, c)). / (2. * del[j]);\n\t                    var column = math.dotDivide(math.subtract(y1,func(t,p,c)),2*del[j]);\n\t                    for(var k=0;k< m;k++){\n\t                        J[k][j]=column[k][0];\n\t                    }\n\t\n\t                }\t\t\t// central difference, additional func call\n\t            }\n\t\n\t            p[j] = ps[j];\t\t// restore p(j)\n\t\n\t        }\n\t        //console.log(\"lm_FD_J: \"+ JSON.stringify(J));\n\t        return J;\n\t\n\t    },\n\t\n\t    // endfunction # -------------------------------------------------- LM_FD_J\n\t    lm_Broyden_J: function(p_old,y_old,J,p,y){\n\t        // J = lm_Broyden_J(p_old,y_old,J,p,y)\n\t        // carry out a rank-1 update to the Jacobian matrix using Broyden's equation\n\t        //---------- INPUT VARIABLES -------\n\t        // p_old = previous set of parameters\n\t        // y_old = model evaluation at previous set of parameters, y_hat(t;p_old)\n\t        // J  = current version of the Jacobian matrix\n\t        // p     = current  set of parameters\n\t        // y     = model evaluation at current  set of parameters, y_hat(t;p)\n\t        //---------- OUTPUT VARIABLES -------\n\t        // J = rank-1 update to Jacobian Matrix J(i,j)=dy(i)/dp(j)\ti=1:n; j=1:m\n\t        //console.log(p+\" X \"+ p_old)\n\t        var h  = math.subtract(p, p_old);\n\t\n\t        //console.log(\"hhh \"+h);\n\t        var h_t = math.transpose(h);\n\t        h_t.div(math.multiply(h_t,h));\n\t\n\t        //console.log(h_t);\n\t        //J = J + ( y - y_old - J*h )*h' / (h'*h);\t// Broyden rank-1 update eq'n\n\t        J = math.add(J, math.multiply(math.subtract(y, math.add(y_old,math.multiply(J,h))),h_t));\n\t        return J;\n\t        // endfunction # ---------------------------------------------- LM_Broyden_J\n\t    },\n\t\n\t    lm_matx : function (func,t,p_old,y_old,dX2,J,p,y_dat,weight_sq,dp,c,iteration){\n\t        // [JtWJ,JtWdy,Chi_sq,y_hat,J] = this.lm_matx(func,t,p_old,y_old,dX2,J,p,y_dat,weight_sq,{da},{c})\n\t        //\n\t        // Evaluate the linearized fitting matrix, JtWJ, and vector JtWdy,\n\t        // and calculate the Chi-squared error function, Chi_sq\n\t        // Used by Levenberg-Marquard algorithm, lm.m\n\t        // -------- INPUT VARIABLES ---------\n\t        // func   = function ofpn independent variables, p, and m parameters, p,\n\t        //         returning the simulated model: y_hat = func(t,p,c)\n\t        // t      = m-vectors or matrix of independent variables (used as arg to func)\n\t        // p_old  = n-vector of previous parameter values\n\t        // y_old  = m-vector of previous model ... y_old = y_hat(t;p_old);\n\t        // dX2    = previous change in Chi-squared criteria\n\t        // J   = m-by-n Jacobian of model, y_hat, with respect to parameters, p\n\t        // p      = n-vector of current  parameter values\n\t        // y_dat  = n-vector of data to be fit by func(t,p,c)\n\t        // weight_sq = square of the weighting vector for least squares fit ...\n\t        //\t    inverse of the standard measurement errors\n\t        // dp     = fractional increment of 'p' for numerical derivatives\n\t        //          dp(j)>0 central differences calculated\n\t        //          dp(j)<0 one sided differences calculated\n\t        //          dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n\t        //          Default:  0.001;\n\t        // c      = optional vector of constants passed to y_hat = func(t,p,c)\n\t        //---------- OUTPUT VARIABLES -------\n\t        // JtWJ\t = linearized Hessian matrix (inverse of covariance matrix)\n\t        // JtWdy   = linearized fitting vector\n\t        // Chi_sq = Chi-squared criteria: weighted sum of the squared residuals WSSR\n\t        // y_hat  = model evaluated with parameters 'p'\n\t        // J   = m-by-n Jacobian of model, y_hat, with respect to parameters, p\n\t\n\t        //   Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. November 2005\n\t        //   modified from: ftp://fly.cnuce.cnr.it/pub/software/octave/leasqr/\n\t        //   Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\t\n\t\n\t        var Npnt = y_dat.length;\t\t// number of data points\n\t        var Npar = p.length;\t\t// number of parameters\n\t\n\t        dp = dp || 0.001;\n\t\n\t\n\t        //var JtWJ = new Matrix.zeros(Npar);\n\t        //var JtWdy  = new Matrix.zeros(Npar,1);\n\t\n\t        var y_hat = func(t,p,c);\t// evaluate model using parameters 'p'\n\t        //func_calls = func_calls + 1;\n\t        //console.log(J);\n\t        if ( (iteration%(2*Npar))==0 || dX2 > 0 ) {\n\t            //console.log(\"Par\");\n\t            J = this.lm_FD_J(func, t, p, y_hat, dp, c);\t\t// finite difference\n\t        }\n\t        else{\n\t            //console.log(\"ImPar\");\n\t            J = this.lm_Broyden_J(p_old, y_old, J, p, y_hat); // rank-1 update\n\t        }\n\t        var delta_y = math.subtract(y_dat, y_hat);\t// residual error between model and data\n\t        //console.log(delta_y[0][0]);\n\t        //console.log(delta_y.rows+\" \"+delta_y.columns+\" \"+JSON.stringify(weight_sq));\n\t        //var Chi_sq = delta_y' * ( delta_y .* weight_sq ); \t// Chi-squared error criteria\n\t        var Chi_sq = math.multiply(math.transpose(delta_y),math.dotMultiply(delta_y,weight_sq));\n\t        //JtWJ  = J' * ( J .* ( weight_sq * ones(1,Npar) ) );\n\t        var Jt = math.transpose(J);\n\t\n\t        //console.log(weight_sq);\n\t\n\t        var JtWJ = math.multiply(Jt, math.dotMultiply(J,math.multiply(weight_sq, Matrix.ones(1,Npar))));\n\t\n\t        //JtWdy = J' * ( weight_sq .* delta_y );\n\t        var JtWdy = math.multiply(Jt, math.dotMultiply(weight_sq,delta_y));\n\t\n\t\n\t        return {JtWJ:JtWJ,JtWdy:JtWdy,Chi_sq:Chi_sq,y_hat:y_hat,J:J};\n\t        // endfunction  # ------------------------------------------------------ LM_MATX\n\t    }\n\t\n\t\n\t\n\t};\n\t\n\tmodule.exports = LM;\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(18);\n\tmodule.exports.Decompositions = module.exports.DC = __webpack_require__(19);\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar Asplice = Array.prototype.splice,\n\t    Aconcat = Array.prototype.concat;\n\t\n\t// For performance : http://jsperf.com/clone-array-slice-vs-while-vs-for\n\tfunction slice(arr) {\n\t    var i = 0,\n\t        ii = arr.length,\n\t        result = new Array(ii);\n\t    for (; i < ii; i++) {\n\t        result[i] = arr[i];\n\t    }\n\t    return result;\n\t}\n\t\n\t/**\n\t * Real matrix.\n\t * @constructor\n\t * @param {number|Array} nRows - Number of rows of the new matrix or a 2D array containing the data.\n\t * @param {number|boolean} [nColumns] - Number of columns of the new matrix or a boolean specifying if the input array should be cloned\n\t */\n\tfunction Matrix(nRows, nColumns) {\n\t    var i = 0, rows, columns, matrix, newInstance;\n\t    if (Array.isArray(nRows)) {\n\t        newInstance = nColumns;\n\t        matrix = newInstance ? slice(nRows) : nRows;\n\t        nRows = matrix.length;\n\t        nColumns = matrix[0].length;\n\t        if (typeof nColumns === 'undefined') {\n\t            throw new TypeError('Data must be a 2D array');\n\t        }\n\t        if (nRows > 0 && nColumns > 0) {\n\t            for (; i < nRows; i++) {\n\t                if (matrix[i].length !== nColumns) {\n\t                    throw new RangeError('Inconsistent array dimensions');\n\t                } else if (newInstance) {\n\t                    matrix[i] = slice(matrix[i]);\n\t                }\n\t            }\n\t        } else {\n\t            throw new RangeError('Invalid dimensions: ' + nRows + 'x' + nColumns);\n\t        }\n\t    } else if (typeof nRows === 'number') { // Create empty matrix\n\t        if (nRows > 0 && nColumns > 0) {\n\t            matrix = new Array(nRows);\n\t            for (; i < nRows; i++) {\n\t                matrix[i] = new Array(nColumns);\n\t            }\n\t        } else {\n\t            throw new RangeError('Invalid dimensions: ' + nRows + 'x' + nColumns);\n\t        }\n\t    } else {\n\t        throw new TypeError('Invalid arguments');\n\t    }\n\t\n\t    Object.defineProperty(matrix, 'rows', {writable: true, value: nRows});\n\t    Object.defineProperty(matrix, 'columns', {writable: true, value: nColumns});\n\t\n\t    matrix.__proto__ = Matrix.prototype;\n\t\n\t    return matrix;\n\t}\n\t\n\t/**\n\t * Constructs a Matrix with the chosen dimensions from a 1D array.\n\t * @param {number} newRows - Number of rows\n\t * @param {number} newColumns - Number of columns\n\t * @param {Array} newData - A 1D array containing data for the matrix\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.from1DArray = function from1DArray(newRows, newColumns, newData) {\n\t    var length, data, i = 0;\n\t\n\t    length = newRows * newColumns;\n\t    if (length !== newData.length)\n\t        throw new RangeError('Data length does not match given dimensions');\n\t\n\t    data = new Array(newRows);\n\t    for (; i < newRows; i++) {\n\t        data[i] = newData.slice(i * newColumns, (i + 1) * newColumns);\n\t    }\n\t    return new Matrix(data);\n\t};\n\t\n\t/**\n\t * Creates a row vector, a matrix with only one row.\n\t * @param {Array} newData - A 1D array containing data for the vector\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.rowVector = function rowVector(newData) {\n\t    return new Matrix([newData]);\n\t};\n\t\n\t/**\n\t * Creates a column vector, a matrix with only one column.\n\t * @param {Array} newData - A 1D array containing data for the vector\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.columnVector = function columnVector(newData) {\n\t    var l = newData.length, vector = new Array(l);\n\t    for (var i = 0; i < l; i++)\n\t        vector[i] = [newData[i]];\n\t    return new Matrix(vector);\n\t};\n\t\n\t/**\n\t * Creates an empty matrix with the given dimensions. Values will be undefined. Same as using new Matrix(rows, columns).\n\t * @param {number} rows - Number of rows\n\t * @param {number} columns - Number of columns\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.empty = function empty(rows, columns) {\n\t    return new Matrix(rows, columns);\n\t};\n\t\n\t/**\n\t * Creates a matrix with the given dimensions. Values will be set to zero.\n\t * @param {number} rows - Number of rows\n\t * @param {number} columns - Number of columns\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.zeros = function zeros(rows, columns) {\n\t    return Matrix.empty(rows, columns).fill(0);\n\t};\n\t\n\t/**\n\t * Creates a matrix with the given dimensions. Values will be set to one.\n\t * @param {number} rows - Number of rows\n\t * @param {number} columns - Number of columns\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.ones = function ones(rows, columns) {\n\t    return Matrix.empty(rows, columns).fill(1);\n\t};\n\t\n\t/**\n\t * Creates a matrix with the given dimensions. Values will be randomly set using Math.random().\n\t * @param {number} rows - Number of rows\n\t * @param {number} columns - Number of columns\n\t * @returns {Matrix} The new matrix\n\t */\n\tMatrix.rand = function rand(rows, columns) {\n\t    var matrix = Matrix.empty(rows, columns);\n\t    for (var i = 0, ii = matrix.rows; i < ii; i++) {\n\t        for (var j = 0, jj = matrix.columns; j < jj; j++) {\n\t            matrix[i][j] = Math.random();\n\t        }\n\t    }\n\t    return matrix;\n\t};\n\t\n\t/**\n\t * Creates an identity matrix with the given dimension. Values of the diagonal will be 1 and other will be 0.\n\t * @param {number} n - Number of rows and columns\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.eye = function eye(n) {\n\t    var matrix = Matrix.zeros(n, n), l = matrix.rows;\n\t    for (var i = 0; i < l; i++) {\n\t        matrix[i][i] = 1;\n\t    }\n\t    return matrix;\n\t};\n\t\n\t/**\n\t * Creates a diagonal matrix based on the given array.\n\t * @param {Array} data - Array containing the data for the diagonal\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.diag = function diag(data) {\n\t    var l = data.length, matrix = Matrix.zeros(l, l);\n\t    for (var i = 0; i < l; i++) {\n\t        matrix[i][i] = data[i];\n\t    }\n\t    return matrix;\n\t};\n\t\n\t/**\n\t * Creates an array of indices between two values\n\t * @param {number} from\n\t * @param {number} to\n\t * @returns {Array}\n\t */\n\tMatrix.indices = function indices(from, to) {\n\t    var vector = new Array(to - from);\n\t    for (var i = 0; i < vector.length; i++)\n\t        vector[i] = from++;\n\t    return vector;\n\t};\n\t\n\t// TODO DOC\n\tMatrix.stack = function stack(arg1) {\n\t    var i, j, k;\n\t    if (Matrix.isMatrix(arg1)) {\n\t        var rows = 0,\n\t            cols = 0;\n\t        for (i = 0; i < arguments.length; i++) {\n\t            rows += arguments[i].rows;\n\t            if (arguments[i].columns > cols)\n\t                cols = arguments[i].columns;\n\t        }\n\t\n\t        var r = Matrix.zeros(rows, cols);\n\t        var c = 0;\n\t        for (i = 0; i < arguments.length; i++) {\n\t            var current = arguments[i];\n\t            for (j = 0; j < current.rows; j++) {\n\t                for (k = 0; k < current.columns; k++)\n\t                    r[c][k] = current[j][k];\n\t                c++;\n\t            }\n\t        }\n\t        return r;\n\t    }\n\t    else if (Array.isArray(arg1)) {\n\t        var matrix = Matrix.empty(arguments.length, arg1.length);\n\t        for (i = 0; i < arguments.length; i++)\n\t            matrix.setRow(i, arguments[i]);\n\t        return matrix;\n\t    }\n\t};\n\t\n\t// TODO DOC\n\tMatrix.expand = function expand(base, count) {\n\t    var expansion = [];\n\t    for (var i = 0; i < count.length; i++)\n\t        for (var j = 0; j < count[i]; j++)\n\t            expansion.push(base[i]);\n\t    return new Matrix(expansion);\n\t};\n\t\n\t/**\n\t * Check that the provided value is a Matrix and tries to instantiate one if not\n\t * @param value - The value to check\n\t * @returns {Matrix}\n\t * @throws {TypeError}\n\t */\n\tMatrix.checkMatrix = function checkMatrix(value) {\n\t    if (!value) {\n\t        throw new TypeError('Argument has to be a matrix');\n\t    }\n\t    if (value.klass !== 'Matrix') {\n\t        value = new Matrix(value);\n\t    }\n\t    return value;\n\t};\n\t\n\t/**\n\t * Returns true if the argument is a Matrix, false otherwise\n\t * @param value - The value to check\n\t * @returns {boolean}\n\t */\n\tMatrix.isMatrix = function isMatrix(value) {\n\t    return value ? value.klass === 'Matrix' : false;\n\t};\n\t\n\t/**\n\t * @property {string} - The name of this class.\n\t */\n\tObject.defineProperty(Matrix.prototype, 'klass', {\n\t    get: function klass() {\n\t        return 'Matrix';\n\t    }\n\t});\n\t\n\t/**\n\t * @property {number} - The number of elements in the matrix.\n\t */\n\tObject.defineProperty(Matrix.prototype, 'size', {\n\t    get: function size() {\n\t        return this.rows * this.columns;\n\t    }\n\t});\n\t\n\t/**\n\t * @private\n\t * Internal check that a row index is not out of bounds\n\t * @param {number} index\n\t */\n\tMatrix.prototype.checkRowIndex = function checkRowIndex(index) {\n\t    if (index < 0 || index > this.rows - 1)\n\t        throw new RangeError('Row index out of range.');\n\t};\n\t\n\t/**\n\t * @private\n\t * Internal check that a column index is not out of bounds\n\t * @param {number} index\n\t */\n\tMatrix.prototype.checkColumnIndex = function checkColumnIndex(index) {\n\t    if (index < 0 || index > this.columns - 1)\n\t        throw new RangeError('Column index out of range.');\n\t};\n\t\n\t/**\n\t * @private\n\t * Internal check that two matrices have the same dimensions\n\t * @param {Matrix} otherMatrix\n\t */\n\tMatrix.prototype.checkDimensions = function checkDimensions(otherMatrix) {\n\t    if ((this.rows !== otherMatrix.rows) || (this.columns !== otherMatrix.columns))\n\t        throw new RangeError('Matrices dimensions must be equal.');\n\t};\n\t\n\t/**\n\t * Applies a callback for each element of the matrix. The function is called in the matrix (this) context.\n\t * @param {function} callback - Function that will be called with two parameters : i (row) and j (column)\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.apply = function apply(callback) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            callback.call(this, i, j);\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Creates an exact and independent copy of the matrix\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.clone = function clone() {\n\t    return new Matrix(this.to2DArray());\n\t};\n\t\n\t/**\n\t * Returns a new 1D array filled row by row with the matrix values\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.to1DArray = function to1DArray() {\n\t    return Aconcat.apply([], this);\n\t};\n\t\n\t/**\n\t * Returns a 2D array containing a copy of the data\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.to2DArray = function to2DArray() {\n\t    var l = this.rows, copy = new Array(l);\n\t    for (var i = 0; i < l; i++) {\n\t        copy[i] = slice(this[i]);\n\t    }\n\t    return copy;\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix has one row\n\t */\n\tMatrix.prototype.isRowVector = function isRowVector() {\n\t    return this.rows === 1;\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix has one column\n\t */\n\tMatrix.prototype.isColumnVector = function isColumnVector() {\n\t    return this.columns === 1;\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix has one row or one column\n\t */\n\tMatrix.prototype.isVector = function isVector() {\n\t    return (this.rows === 1) || (this.columns === 1);\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix has the same number of rows and columns\n\t */\n\tMatrix.prototype.isSquare = function isSquare() {\n\t    return this.rows === this.columns;\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix is square and has the same values on both sides of the diagonal\n\t */\n\tMatrix.prototype.isSymmetric = function isSymmetric() {\n\t    if (this.isSquare()) {\n\t        var l = this.rows;\n\t        for (var i = 0; i < l; i++) {\n\t            for (var j = 0; j <= i; j++) {\n\t                if (this[i][j] !== this[j][i]) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    return false;\n\t};\n\t\n\t/**\n\t * Sets a given element of the matrix. mat.set(3,4,1) is equivalent to mat[3][4]=1\n\t * @param {number} rowIndex - Index of the row\n\t * @param {number} columnIndex - Index of the column\n\t * @param {number} value - The new value for the element\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.set = function set(rowIndex, columnIndex, value) {\n\t    this[rowIndex][columnIndex] = value;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Returns the given element of the matrix. mat.get(3,4) is equivalent to matrix[3][4]\n\t * @param {number} rowIndex - Index of the row\n\t * @param {number} columnIndex - Index of the column\n\t * @returns {number}\n\t */\n\tMatrix.prototype.get = function get(rowIndex, columnIndex) {\n\t    return this[rowIndex][columnIndex];\n\t};\n\t\n\t/**\n\t * Fills the matrix with a given value. All elements will be set to this value.\n\t * @param {number} value - New value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.fill = function fill(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] = value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Negates the matrix. All elements will be multiplied by (-1)\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.neg = function neg() {\n\t    return this.mulS(-1);\n\t};\n\t\n\t/**\n\t * Adds a scalar or values from another matrix (in place)\n\t * @param {number|Matrix} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.add = function add(value) {\n\t    if (typeof value === 'number')\n\t        return this.addS(value);\n\t    value = Matrix.checkMatrix(value);\n\t        return this.addM(value);\n\t};\n\t\n\t/**\n\t * Adds a scalar to each element of the matrix\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addS = function addS(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] += value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Adds the value of each element of matrix to the corresponding element of this\n\t * @param {Matrix} matrix\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addM = function addM(matrix) {\n\t    this.checkDimensions(matrix);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] += matrix[i][j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Subtracts a scalar or values from another matrix (in place)\n\t * @param {number|Matrix} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.sub = function sub(value) {\n\t    if (typeof value === 'number')\n\t        return this.subS(value);\n\t    value = Matrix.checkMatrix(value);\n\t        return this.subM(value);\n\t};\n\t\n\t/**\n\t * Subtracts a scalar from each element of the matrix\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.subS = function subS(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] -= value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Subtracts the value of each element of matrix from the corresponding element of this\n\t * @param {Matrix} matrix\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.subM = function subM(matrix) {\n\t    this.checkDimensions(matrix);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] -= matrix[i][j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies a scalar or values from another matrix (in place)\n\t * @param {number|Matrix} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mul = function mul(value) {\n\t    if (typeof value === 'number')\n\t        return this.mulS(value);\n\t    value = Matrix.checkMatrix(value);\n\t        return this.mulM(value);\n\t};\n\t\n\t/**\n\t * Multiplies a scalar with each element of the matrix\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulS = function mulS(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] *= value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the value of each element of matrix with the corresponding element of this\n\t * @param {Matrix} matrix\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulM = function mulM(matrix) {\n\t    this.checkDimensions(matrix);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] *= matrix[i][j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Divides by a scalar or values from another matrix (in place)\n\t * @param {number|Matrix} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.div = function div(value) {\n\t    if (typeof value === 'number')\n\t        return this.divS(value);\n\t    value = Matrix.checkMatrix(value);\n\t        return this.divM(value);\n\t};\n\t\n\t/**\n\t * Divides each element of the matrix by a scalar\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.divS = function divS(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] /= value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Divides each element of this by the corresponding element of matrix\n\t * @param {Matrix} matrix\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.divM = function divM(matrix) {\n\t    this.checkDimensions(matrix);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] /= matrix[i][j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Returns a new array from the given row index\n\t * @param {number} index - Row index\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.getRow = function getRow(index) {\n\t    this.checkRowIndex(index);\n\t    return slice(this[index]);\n\t};\n\t\n\t/**\n\t * Returns a new row vector from the given row index\n\t * @param {number} index - Row index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.getRowVector = function getRowVector(index) {\n\t    return Matrix.rowVector(this.getRow(index));\n\t};\n\t\n\t/**\n\t * Sets a row at the given index\n\t * @param {number} index - Row index\n\t * @param {Array|Matrix} array - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.setRow = function setRow(index, array) {\n\t    this.checkRowIndex(index);\n\t    if (Matrix.isMatrix(array)) array = array.to1DArray();\n\t    if (array.length !== this.columns)\n\t        throw new RangeError('Invalid row size');\n\t    this[index] = slice(array);\n\t    return this;\n\t};\n\t\n\t/**\n\t * Removes a row from the given index\n\t * @param {number} index - Row index\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.removeRow = function removeRow(index) {\n\t    this.checkRowIndex(index);\n\t    if (this.rows === 1)\n\t        throw new RangeError('A matrix cannot have less than one row');\n\t    Asplice.call(this, index, 1);\n\t    this.rows -= 1;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Adds a row at the given index\n\t * @param {number} [index = this.rows] - Row index\n\t * @param {Array|Matrix} array - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addRow = function addRow(index, array) {\n\t    if (typeof array === 'undefined') {\n\t        array = index;\n\t        index = this.rows;\n\t    }\n\t    if (index < 0 || index > this.rows)\n\t        throw new RangeError('Row index out of range.');\n\t    if (Matrix.isMatrix(array)) array = array.to1DArray();\n\t    if (array.length !== this.columns)\n\t        throw new RangeError('Invalid row size');\n\t    Asplice.call(this, index, 0, slice(array));\n\t    this.rows += 1;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Swaps two rows\n\t * @param {number} row1 - First row index\n\t * @param {number} row2 - Second row index\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.swapRows = function swapRows(row1, row2) {\n\t    this.checkRowIndex(row1);\n\t    this.checkRowIndex(row2);\n\t    var temp = this[row1];\n\t    this[row1] = this[row2];\n\t    this[row2] = temp;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Returns a new array from the given column index\n\t * @param {number} index - Column index\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.getColumn = function getColumn(index) {\n\t    this.checkColumnIndex(index);\n\t    var l = this.rows, column = new Array(l);\n\t    for (var i = 0; i < l; i++) {\n\t        column[i] = this[i][index];\n\t    }\n\t    return column;\n\t};\n\t\n\t/**\n\t * Returns a new column vector from the given column index\n\t * @param {number} index - Column index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.getColumnVector = function getColumnVector(index) {\n\t    return Matrix.columnVector(this.getColumn(index));\n\t};\n\t\n\t/**\n\t * Sets a column at the given index\n\t * @param {number} index - Column index\n\t * @param {Array|Matrix} array - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.setColumn = function setColumn(index, array) {\n\t    this.checkColumnIndex(index);\n\t    if (Matrix.isMatrix(array)) array = array.to1DArray();\n\t    var l = this.rows;\n\t    if (array.length !== l)\n\t        throw new RangeError('Invalid column size');\n\t    for (var i = 0; i < l; i++) {\n\t        this[i][index] = array[i];\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Removes a column from the given index\n\t * @param {number} index - Column index\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.removeColumn = function removeColumn(index) {\n\t    this.checkColumnIndex(index);\n\t    if (this.columns === 1)\n\t        throw new RangeError('A matrix cannot have less than one column');\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        this[i].splice(index, 1);\n\t    }\n\t    this.columns -= 1;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Adds a column at the given index\n\t * @param {number} [index = this.columns] - Column index\n\t * @param {Array|Matrix} array - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addColumn = function addColumn(index, array) {\n\t    if (typeof array === 'undefined') {\n\t        array = index;\n\t        index = this.columns;\n\t    }\n\t    if (index < 0 || index > this.columns)\n\t        throw new RangeError('Column index out of range.');\n\t    if (Matrix.isMatrix(array)) array = array.to1DArray();\n\t    var l = this.rows;\n\t    if (array.length !== l)\n\t        throw new RangeError('Invalid column size');\n\t    for (var i = 0; i < l; i++) {\n\t        this[i].splice(index, 0, array[i]);\n\t    }\n\t    this.columns += 1;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Swaps two columns\n\t * @param {number} column1 - First column index\n\t * @param {number} column2 - Second column index\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.swapColumns = function swapColumns(column1, column2) {\n\t    this.checkRowIndex(column1);\n\t    this.checkRowIndex(column2);\n\t    var l = this.rows, temp, row;\n\t    for (var i = 0; i < l; i++) {\n\t        row = this[i];\n\t        temp = row[column1];\n\t        row[column1] = row[column2];\n\t        row[column2] = temp;\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * @private\n\t * Internal check that the provided vector is an array with the right length\n\t * @param {Array|Matrix} vector\n\t * @returns {Array}\n\t * @throws {RangeError}\n\t */\n\tMatrix.prototype.checkRowVector = function checkRowVector(vector) {\n\t    if (Matrix.isMatrix(vector))\n\t        vector = vector.to1DArray();\n\t    if (vector.length !== this.columns)\n\t        throw new RangeError('vector size must be the same as the number of columns');\n\t    return vector;\n\t};\n\t\n\t/**\n\t * @private\n\t * Internal check that the provided vector is an array with the right length\n\t * @param {Array|Matrix} vector\n\t * @returns {Array}\n\t * @throws {RangeError}\n\t */\n\tMatrix.prototype.checkColumnVector = function checkColumnVector(vector) {\n\t    if (Matrix.isMatrix(vector))\n\t        vector = vector.to1DArray();\n\t    if (vector.length !== this.rows)\n\t        throw new RangeError('vector size must be the same as the number of rows');\n\t    return vector;\n\t};\n\t\n\t/**\n\t * Adds the values of a vector to each row\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addRowVector = function addRowVector(vector) {\n\t    vector = this.checkRowVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] += vector[j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Subtracts the values of a vector from each row\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.subRowVector = function subRowVector(vector) {\n\t    vector = this.checkRowVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] -= vector[j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the values of a vector with each row\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulRowVector = function mulRowVector(vector) {\n\t    vector = this.checkRowVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] *= vector[j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Divides the values of each row by those of a vector\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.divRowVector = function divRowVector(vector) {\n\t    vector = this.checkRowVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] /= vector[j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Adds the values of a vector to each column\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addColumnVector = function addColumnVector(vector) {\n\t    vector = this.checkColumnVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] += vector[i];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Subtracts the values of a vector from each column\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.subColumnVector = function subColumnVector(vector) {\n\t    vector = this.checkColumnVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] -= vector[i];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the values of a vector with each column\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulColumnVector = function mulColumnVector(vector) {\n\t    vector = this.checkColumnVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] *= vector[i];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Divides the values of each column by those of a vector\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.divColumnVector = function divColumnVector(vector) {\n\t    vector = this.checkColumnVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] /= vector[i];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the values of a row with a scalar\n\t * @param {number} index - Row index\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulRow = function mulRow(index, value) {\n\t    this.checkRowIndex(index);\n\t    var i = 0, l = this.columns;\n\t    for (; i < l; i++) {\n\t        this[index][i] *= value;\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the values of a column with a scalar\n\t * @param {number} index - Column index\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulColumn = function mulColumn(index, value) {\n\t    this.checkColumnIndex(index);\n\t    var i = 0, l = this.rows;\n\t    for (; i < l; i++) {\n\t        this[i][index] *= value;\n\t    }\n\t};\n\t\n\t/**\n\t * A matrix index\n\t * @typedef {Object} MatrixIndex\n\t * @property {number} row\n\t * @property {number} column\n\t */\n\t\n\t/**\n\t * Returns the maximum value of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.max = function max() {\n\t    var v = -Infinity;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (this[i][j] > v) {\n\t                v = this[i][j];\n\t            }\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the maximum value\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.maxIndex = function maxIndex() {\n\t    var v = -Infinity;\n\t    var idx = {};\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (this[i][j] > v) {\n\t                v = this[i][j];\n\t                idx.row = i;\n\t                idx.column = j;\n\t            }\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the minimum value of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.min = function min() {\n\t    var v = Infinity;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (this[i][j] < v) {\n\t                v = this[i][j];\n\t            }\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the minimum value\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.minIndex = function minIndex() {\n\t    var v = Infinity;\n\t    var idx = {};\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (this[i][j] < v) {\n\t                v = this[i][j];\n\t                idx.row = i;\n\t                idx.column = j;\n\t            }\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the maximum value of one row\n\t * @param {number} index - Row index\n\t * @returns {number}\n\t */\n\tMatrix.prototype.maxRow = function maxRow(index) {\n\t    this.checkRowIndex(index);\n\t    var v = -Infinity;\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        if (this[index][i] > v) {\n\t            v = this[index][i];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the maximum value of one row\n\t * @param {number} index - Row index\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.maxRowIndex = function maxRowIndex(index) {\n\t    this.checkRowIndex(index);\n\t    var v = -Infinity;\n\t    var idx = {\n\t            row: index\n\t        };\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        if (this[index][i] > v) {\n\t            v = this[index][i];\n\t            idx.column = i;\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the minimum value of one row\n\t * @param {number} index - Row index\n\t * @returns {number}\n\t */\n\tMatrix.prototype.minRow = function minRow(index) {\n\t    this.checkRowIndex(index);\n\t    var v = Infinity;\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        if (this[index][i] < v) {\n\t            v = this[index][i];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the maximum value of one row\n\t * @param {number} index - Row index\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.minRowIndex = function minRowIndex(index) {\n\t    this.checkRowIndex(index);\n\t    var v = Infinity;\n\t    var idx = {\n\t        row: index,\n\t        column: 0\n\t    };\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        if (this[index][i] < v) {\n\t            v = this[index][i];\n\t            idx.column = i;\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the maximum value of one column\n\t * @param {number} index - Column index\n\t * @returns {number}\n\t */\n\tMatrix.prototype.maxColumn = function maxColumn(index) {\n\t    this.checkColumnIndex(index);\n\t    var v = -Infinity;\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        if (this[i][index] > v) {\n\t            v = this[i][index];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the maximum value of one column\n\t * @param {number} index - Column index\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.maxColumnIndex = function maxColumnIndex(index) {\n\t    this.checkColumnIndex(index);\n\t    var v = -Infinity;\n\t    var idx = {\n\t        row: 0,\n\t        column: index\n\t    };\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        if (this[i][index] > v) {\n\t            v = this[i][index];\n\t            idx.row = i;\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the minimum value of one column\n\t * @param {number} index - Column index\n\t * @returns {number}\n\t */\n\tMatrix.prototype.minColumn = function minColumn(index) {\n\t    this.checkColumnIndex(index);\n\t    var v = Infinity;\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        if (this[i][index] < v) {\n\t            v = this[i][index];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the minimum value of one column\n\t * @param {number} index - Column index\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.minColumnIndex = function minColumnIndex(index) {\n\t    this.checkColumnIndex(index);\n\t    var v = Infinity;\n\t    var idx = {\n\t        row: 0,\n\t        column: index\n\t    };\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        if (this[i][index] < v) {\n\t            v = this[i][index];\n\t            idx.row = i;\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns an array containing the diagonal values of the matrix\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.diag = function diag() {\n\t    if (!this.isSquare())\n\t        throw new TypeError('Only square matrices have a diagonal.');\n\t    var diag = new Array(this.rows);\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        diag[i] = this[i][i];\n\t    }\n\t    return diag;\n\t};\n\t\n\t/**\n\t * Returns the sum of all elements of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.sum = function sum() {\n\t    var v = 0;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            v += this[i][j];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the mean of all elements of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.mean = function mean() {\n\t    return this.sum() / this.size;\n\t};\n\t\n\t/**\n\t * Returns the product of all elements of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.prod = function prod() {\n\t    var prod = 1;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            prod *= this[i][j];\n\t        }\n\t    }\n\t    return prod;\n\t};\n\t\n\t/**\n\t * Computes the cumulative sum of the matrix elements (in place, row by row)\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.cumulativeSum = function cumulativeSum() {\n\t    var sum = 0;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            sum += this[i][j];\n\t            this[i][j] = sum;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Computes the dot (scalar) product between the matrix and another\n\t * @param {Matrix} other vector\n\t * @returns {number}\n\t */\n\tMatrix.prototype.dot = function dot(other) {\n\t    if (this.size !== other.size)\n\t        throw new RangeError('vectors do not have the same size');\n\t    var vector1 = this.to1DArray();\n\t    var vector2 = other.to1DArray();\n\t    var dot = 0, l = vector1.length;\n\t    for (var i = 0; i < l; i++) {\n\t        dot += vector1[i] * vector2[i];\n\t    }\n\t    return dot;\n\t};\n\t\n\t/**\n\t * Returns the matrix product between this and other\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.mmul = function mmul(other) {\n\t    if (!Matrix.isMatrix(other))\n\t        throw new TypeError('parameter \"other\" must be a matrix');\n\t    if (this.columns !== other.rows)\n\t        console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');\n\t\n\t    var m = this.rows, n = this.columns, p = other.columns;\n\t    var result = new Matrix(m, p);\n\t\n\t    var Bcolj = new Array(n);\n\t    var i, j, k;\n\t    for (j = 0; j < p; j++) {\n\t        for (k = 0; k < n; k++)\n\t            Bcolj[k] = other[k][j];\n\t\n\t        for (i = 0; i < m; i++) {\n\t            var Arowi = this[i];\n\t\n\t            var s = 0;\n\t            for (k = 0; k < n; k++)\n\t                s += Arowi[k] * Bcolj[k];\n\t\n\t            result[i][j] = s;\n\t        }\n\t    }\n\t    return result;\n\t};\n\t\n\t/**\n\t * Sorts the rows (in place)\n\t * @param {function} compareFunction - usual Array.prototype.sort comparison function\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.sortRows = function sortRows(compareFunction) {\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        this[i].sort(compareFunction);\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Sorts the columns (in place)\n\t * @param {function} compareFunction - usual Array.prototype.sort comparison function\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.sortColumns = function sortColumns(compareFunction) {\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        this.setColumn(i, this.getColumn(i).sort(compareFunction));\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Transposes the matrix and returns a new one containing the result\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.transpose = function transpose() {\n\t    var result = new Matrix(this.columns, this.rows);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            result[j][i] = this[i][j];\n\t        }\n\t    }\n\t    return result;\n\t};\n\t\n\t/**\n\t * Returns a subset of the matrix\n\t * @param {number} startRow - First row index\n\t * @param {number} endRow - Last row index\n\t * @param {number} startColumn - First column index\n\t * @param {number} endColumn - Last column index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.subMatrix = function subMatrix(startRow, endRow, startColumn, endColumn) {\n\t    if ((startRow > endRow) || (startColumn > endColumn) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns))\n\t        throw new RangeError('Argument out of range');\n\t    var newMatrix = new Matrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\t    for (var i = startRow; i <= endRow; i++) {\n\t        for (var j = startColumn; j <= endColumn; j++) {\n\t            newMatrix[i - startRow][j - startColumn] = this[i][j];\n\t        }\n\t    }\n\t    return newMatrix;\n\t};\n\t\n\t/**\n\t * Returns a subset of the matrix based on an array of row indices\n\t * @param {Array} indices - Array containing the row indices\n\t * @param {number} [startColumn = 0] - First column index\n\t * @param {number} [endColumn = this.columns-1] - Last column index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.subMatrixRow = function subMatrixRow(indices, startColumn, endColumn) {\n\t    if (typeof startColumn === 'undefined') {\n\t        startColumn = 0;\n\t        endColumn = this.columns - 1;\n\t    } else if (typeof endColumn === 'undefined') {\n\t        endColumn = this.columns - 1;\n\t    }\n\t    if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns))\n\t        throw new RangeError('Argument out of range.');\n\t    var l = indices.length, rows = this.rows,\n\t        X = new Matrix(l, endColumn - startColumn + 1);\n\t    for (var i = 0; i < l; i++) {\n\t        for (var j = startColumn; j <= endColumn; j++) {\n\t            if ((indices[i] < 0) || (indices[i] >= rows))\n\t                throw new RangeError('Argument out of range.');\n\t            X[i][j - startColumn] = this[indices[i]][j];\n\t        }\n\t    }\n\t    return X;\n\t};\n\t\n\t/**\n\t * Returns a subset of the matrix based on an array of column indices\n\t * @param {Array} indices - Array containing the column indices\n\t * @param {number} [startRow = 0] - First row index\n\t * @param {number} [endRow = this.rows-1] - Last row index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.subMatrixColumn = function subMatrixColumn(indices, startRow, endRow) {\n\t    if (typeof startRow === 'undefined') {\n\t        startRow = 0;\n\t        endRow = this.rows - 1;\n\t    } else if (typeof endRow === 'undefined') {\n\t        endRow = this.rows - 1;\n\t    }\n\t    if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows))\n\t        throw new RangeError('Argument out of range.');\n\t    var l = indices.length, columns = this.columns,\n\t        X = new Matrix(endRow - startRow + 1, l);\n\t    for (var i = 0; i < l; i++) {\n\t        for (var j = startRow; j <= endRow; j++) {\n\t            if ((indices[i] < 0) || (indices[i] >= columns))\n\t                throw new RangeError('Argument out of range.');\n\t            X[j - startRow][i] = this[j][indices[i]];\n\t        }\n\t    }\n\t    return X;\n\t};\n\t\n\t/**\n\t * Returns the trace of the matrix (sum of the diagonal elements)\n\t * @returns {number}\n\t */\n\tMatrix.prototype.trace = function trace() {\n\t    if (!this.isSquare())\n\t        throw new TypeError('The matrix is not square');\n\t    var trace = 0, i = 0, l = this.rows;\n\t    for (; i < l; i++) {\n\t        trace += this[i][i];\n\t    }\n\t    return trace;\n\t};\n\t\n\t/**\n\t * Sets each element of the matrix to its absolute value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.abs = function abs() {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] = Math.abs(this[i][j]);\n\t        }\n\t    }\n\t};\n\t\n\tmodule.exports = Matrix;\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(18);\n\t\n\tvar SingularValueDecomposition = __webpack_require__(20);\n\tvar EigenvalueDecomposition = __webpack_require__(22);\n\tvar LuDecomposition = __webpack_require__(23);\n\tvar QrDecomposition = __webpack_require__(24);\n\tvar CholeskyDecomposition = __webpack_require__(25);\n\t\n\tfunction inverse(matrix) {\n\t    return solve(matrix, Matrix.eye(matrix.rows));\n\t}\n\t\n\tMatrix.prototype.inverse = function () {\n\t    return inverse(this);\n\t};\n\t\n\tfunction solve(leftHandSide, rightHandSide) {\n\t    return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).solve(rightHandSide);\n\t}\n\t\n\tMatrix.prototype.solve = function (other) {\n\t    return solve(this, other);\n\t};\n\t\n\tmodule.exports = {\n\t    SingularValueDecomposition: SingularValueDecomposition,\n\t    SVD: SingularValueDecomposition,\n\t    EigenvalueDecomposition: EigenvalueDecomposition,\n\t    EVD: EigenvalueDecomposition,\n\t    LuDecomposition: LuDecomposition,\n\t    LU: LuDecomposition,\n\t    QrDecomposition: QrDecomposition,\n\t    QR: QrDecomposition,\n\t    CholeskyDecomposition: CholeskyDecomposition,\n\t    CHO: CholeskyDecomposition,\n\t    inverse: inverse,\n\t    solve: solve\n\t};\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(18);\n\tvar hypotenuse = __webpack_require__(21).hypotenuse;\n\t\n\t// https://github.com/lutzroeder/Mapack/blob/master/Source/SingularValueDecomposition.cs\n\tfunction SingularValueDecomposition(value, options) {\n\t    if (!(this instanceof SingularValueDecomposition)) {\n\t        return new SingularValueDecomposition(value, options);\n\t    }\n\t    value = Matrix.checkMatrix(value);\n\t\n\t    options = options || {};\n\t\n\t    var a = value.clone(),\n\t        m = value.rows,\n\t        n = value.columns,\n\t        nu = Math.min(m, n);\n\t\n\t    var wantu = true, wantv = true;\n\t    if (options.computeLeftSingularVectors === false)\n\t        wantu = false;\n\t    if (options.computeRightSingularVectors === false)\n\t        wantv = false;\n\t    var autoTranspose = options.autoTranspose === true;\n\t\n\t    var swapped = false;\n\t    if (m < n) {\n\t        if (!autoTranspose) {\n\t            console.warn('Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose');\n\t        } else {\n\t            a = a.transpose();\n\t            m = a.rows;\n\t            n = a.columns;\n\t            swapped = true;\n\t            var aux = wantu;\n\t            wantu = wantv;\n\t            wantv = aux;\n\t        }\n\t    }\n\t\n\t    var s = new Array(Math.min(m + 1, n)),\n\t        U = Matrix.zeros(m, nu),\n\t        V = Matrix.zeros(n, n),\n\t        e = new Array(n),\n\t        work = new Array(m);\n\t\n\t    var nct = Math.min(m - 1, n);\n\t    var nrt = Math.max(0, Math.min(n - 2, m));\n\t\n\t    var i, j, k, p, t, ks, f, cs, sn, max, kase,\n\t        scale, sp, spm1, epm1, sk, ek, b, c, shift, g;\n\t\n\t    for (k = 0, max = Math.max(nct, nrt); k < max; k++) {\n\t        if (k < nct) {\n\t            s[k] = 0;\n\t            for (i = k; i < m; i++) {\n\t                s[k] = hypotenuse(s[k], a[i][k]);\n\t            }\n\t            if (s[k] !== 0) {\n\t                if (a[k][k] < 0) {\n\t                    s[k] = -s[k];\n\t                }\n\t                for (i = k; i < m; i++) {\n\t                    a[i][k] /= s[k];\n\t                }\n\t                a[k][k] += 1;\n\t            }\n\t            s[k] = -s[k];\n\t        }\n\t\n\t        for (j = k + 1; j < n; j++) {\n\t            if ((k < nct) && (s[k] !== 0)) {\n\t                t = 0;\n\t                for (i = k; i < m; i++) {\n\t                    t += a[i][k] * a[i][j];\n\t                }\n\t                t = -t / a[k][k];\n\t                for (i = k; i < m; i++) {\n\t                    a[i][j] += t * a[i][k];\n\t                }\n\t            }\n\t            e[j] = a[k][j];\n\t        }\n\t\n\t        if (wantu && (k < nct)) {\n\t            for (i = k; i < m; i++) {\n\t                U[i][k] = a[i][k];\n\t            }\n\t        }\n\t\n\t        if (k < nrt) {\n\t            e[k] = 0;\n\t            for (i = k + 1; i < n; i++) {\n\t                e[k] = hypotenuse(e[k], e[i]);\n\t            }\n\t            if (e[k] !== 0) {\n\t                if (e[k + 1] < 0)\n\t                    e[k] = -e[k];\n\t                for (i = k + 1; i < n; i++) {\n\t                    e[i] /= e[k];\n\t                }\n\t                e[k + 1] += 1;\n\t            }\n\t            e[k] = -e[k];\n\t            if ((k + 1 < m) && (e[k] !== 0)) {\n\t                for (i = k + 1; i < m; i++) {\n\t                    work[i] = 0;\n\t                }\n\t                for (j = k + 1; j < n; j++) {\n\t                    for (i = k + 1; i < m; i++) {\n\t                        work[i] += e[j] * a[i][j];\n\t                    }\n\t                }\n\t                for (j = k + 1; j < n; j++) {\n\t                    t = -e[j] / e[k + 1];\n\t                    for (i = k + 1; i < m; i++) {\n\t                        a[i][j] += t * work[i];\n\t                    }\n\t                }\n\t            }\n\t            if (wantv) {\n\t                for (i = k + 1; i < n; i++) {\n\t                    V[i][k] = e[i];\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    p = Math.min(n, m + 1);\n\t    if (nct < n) {\n\t        s[nct] = a[nct][nct];\n\t    }\n\t    if (m < p) {\n\t        s[p - 1] = 0;\n\t    }\n\t    if (nrt + 1 < p) {\n\t        e[nrt] = a[nrt][p - 1];\n\t    }\n\t    e[p - 1] = 0;\n\t\n\t    if (wantu) {\n\t        for (j = nct; j < nu; j++) {\n\t            for (i = 0; i < m; i++) {\n\t                U[i][j] = 0;\n\t            }\n\t            U[j][j] = 1;\n\t        }\n\t        for (k = nct - 1; k >= 0; k--) {\n\t            if (s[k] !== 0) {\n\t                for (j = k + 1; j < nu; j++) {\n\t                    t = 0;\n\t                    for (i = k; i < m; i++) {\n\t                        t += U[i][k] * U[i][j];\n\t                    }\n\t                    t = -t / U[k][k];\n\t                    for (i = k; i < m; i++) {\n\t                        U[i][j] += t * U[i][k];\n\t                    }\n\t                }\n\t                for (i = k; i < m; i++) {\n\t                    U[i][k] = -U[i][k];\n\t                }\n\t                U[k][k] = 1 + U[k][k];\n\t                for (i = 0; i < k - 1; i++) {\n\t                    U[i][k] = 0;\n\t                }\n\t            } else {\n\t                for (i = 0; i < m; i++) {\n\t                    U[i][k] = 0;\n\t                }\n\t                U[k][k] = 1;\n\t            }\n\t        }\n\t    }\n\t\n\t    if (wantv) {\n\t        for (k = n - 1; k >= 0; k--) {\n\t            if ((k < nrt) && (e[k] !== 0)) {\n\t                for (j = k + 1; j < n; j++) {\n\t                    t = 0;\n\t                    for (i = k + 1; i < n; i++) {\n\t                        t += V[i][k] * V[i][j];\n\t                    }\n\t                    t = -t / V[k + 1][k];\n\t                    for (i = k + 1; i < n; i++) {\n\t                        V[i][j] += t * V[i][k];\n\t                    }\n\t                }\n\t            }\n\t            for (i = 0; i < n; i++) {\n\t                V[i][k] = 0;\n\t            }\n\t            V[k][k] = 1;\n\t        }\n\t    }\n\t\n\t    var pp = p - 1,\n\t        iter = 0,\n\t        eps = Math.pow(2, -52);\n\t    while (p > 0) {\n\t        for (k = p - 2; k >= -1; k--) {\n\t            if (k === -1) {\n\t                break;\n\t            }\n\t            if (Math.abs(e[k]) <= eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {\n\t                e[k] = 0;\n\t                break;\n\t            }\n\t        }\n\t        if (k === p - 2) {\n\t            kase = 4;\n\t        } else {\n\t            for (ks = p - 1; ks >= k; ks--) {\n\t                if (ks === k) {\n\t                    break;\n\t                }\n\t                t = (ks !== p ? Math.abs(e[ks]) : 0) + (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);\n\t                if (Math.abs(s[ks]) <= eps * t) {\n\t                    s[ks] = 0;\n\t                    break;\n\t                }\n\t            }\n\t            if (ks === k) {\n\t                kase = 3;\n\t            } else if (ks === p - 1) {\n\t                kase = 1;\n\t            } else {\n\t                kase = 2;\n\t                k = ks;\n\t            }\n\t        }\n\t\n\t        k++;\n\t\n\t        switch (kase) {\n\t            case 1: {\n\t                f = e[p - 2];\n\t                e[p - 2] = 0;\n\t                for (j = p - 2; j >= k; j--) {\n\t                    t = hypotenuse(s[j], f);\n\t                    cs = s[j] / t;\n\t                    sn = f / t;\n\t                    s[j] = t;\n\t                    if (j !== k) {\n\t                        f = -sn * e[j - 1];\n\t                        e[j - 1] = cs * e[j - 1];\n\t                    }\n\t                    if (wantv) {\n\t                        for (i = 0; i < n; i++) {\n\t                            t = cs * V[i][j] + sn * V[i][p - 1];\n\t                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n\t                            V[i][j] = t;\n\t                        }\n\t                    }\n\t                }\n\t                break;\n\t            }\n\t            case 2 : {\n\t                f = e[k - 1];\n\t                e[k - 1] = 0;\n\t                for (j = k; j < p; j++) {\n\t                    t = hypotenuse(s[j], f);\n\t                    cs = s[j] / t;\n\t                    sn = f / t;\n\t                    s[j] = t;\n\t                    f = -sn * e[j];\n\t                    e[j] = cs * e[j];\n\t                    if (wantu) {\n\t                        for (i = 0; i < m; i++) {\n\t                            t = cs * U[i][j] + sn * U[i][k - 1];\n\t                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n\t                            U[i][j] = t;\n\t                        }\n\t                    }\n\t                }\n\t                break;\n\t            }\n\t            case 3 : {\n\t                scale = Math.max(Math.max(Math.max(Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2])), Math.abs(e[p - 2])), Math.abs(s[k])), Math.abs(e[k]));\n\t                sp = s[p - 1] / scale;\n\t                spm1 = s[p - 2] / scale;\n\t                epm1 = e[p - 2] / scale;\n\t                sk = s[k] / scale;\n\t                ek = e[k] / scale;\n\t                b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;\n\t                c = (sp * epm1) * (sp * epm1);\n\t                shift = 0;\n\t                if ((b !== 0) || (c !== 0)) {\n\t                    shift = Math.sqrt(b * b + c);\n\t                    if (b < 0) {\n\t                        shift = -shift;\n\t                    }\n\t                    shift = c / (b + shift);\n\t                }\n\t                f = (sk + sp) * (sk - sp) + shift;\n\t                g = sk * ek;\n\t                for (j = k; j < p - 1; j++) {\n\t                    t = hypotenuse(f, g);\n\t                    cs = f / t;\n\t                    sn = g / t;\n\t                    if (j !== k) {\n\t                        e[j - 1] = t;\n\t                    }\n\t                    f = cs * s[j] + sn * e[j];\n\t                    e[j] = cs * e[j] - sn * s[j];\n\t                    g = sn * s[j + 1];\n\t                    s[j + 1] = cs * s[j + 1];\n\t                    if (wantv) {\n\t                        for (i = 0; i < n; i++) {\n\t                            t = cs * V[i][j] + sn * V[i][j + 1];\n\t                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n\t                            V[i][j] = t;\n\t                        }\n\t                    }\n\t                    t = hypotenuse(f, g);\n\t                    cs = f / t;\n\t                    sn = g / t;\n\t                    s[j] = t;\n\t                    f = cs * e[j] + sn * s[j + 1];\n\t                    s[j + 1] = -sn * e[j] + cs * s[j + 1];\n\t                    g = sn * e[j + 1];\n\t                    e[j + 1] = cs * e[j + 1];\n\t                    if (wantu && (j < m - 1)) {\n\t                        for (i = 0; i < m; i++) {\n\t                            t = cs * U[i][j] + sn * U[i][j + 1];\n\t                            U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n\t                            U[i][j] = t;\n\t                        }\n\t                    }\n\t                }\n\t                e[p - 2] = f;\n\t                iter = iter + 1;\n\t                break;\n\t            }\n\t            case 4: {\n\t                if (s[k] <= 0) {\n\t                    s[k] = (s[k] < 0 ? -s[k] : 0);\n\t                    if (wantv) {\n\t                        for (i = 0; i <= pp; i++) {\n\t                            V[i][k] = -V[i][k];\n\t                        }\n\t                    }\n\t                }\n\t                while (k < pp) {\n\t                    if (s[k] >= s[k + 1]) {\n\t                        break;\n\t                    }\n\t                    t = s[k];\n\t                    s[k] = s[k + 1];\n\t                    s[k + 1] = t;\n\t                    if (wantv && (k < n - 1)) {\n\t                        for (i = 0; i < n; i++) {\n\t                            t = V[i][k + 1];\n\t                            V[i][k + 1] = V[i][k];\n\t                            V[i][k] = t;\n\t                        }\n\t                    }\n\t                    if (wantu && (k < m - 1)) {\n\t                        for (i = 0; i < m; i++) {\n\t                            t = U[i][k + 1];\n\t                            U[i][k + 1] = U[i][k];\n\t                            U[i][k] = t;\n\t                        }\n\t                    }\n\t                    k++;\n\t                }\n\t                iter = 0;\n\t                p--;\n\t                break;\n\t            }\n\t        }\n\t    }\n\t\n\t    if (swapped) {\n\t        var tmp = V;\n\t        V = U;\n\t        U = tmp;\n\t    }\n\t\n\t    this.m = m;\n\t    this.n = n;\n\t    this.s = s;\n\t    this.U = U;\n\t    this.V = V;\n\t}\n\t\n\tSingularValueDecomposition.prototype = {\n\t    get condition() {\n\t        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];\n\t    },\n\t    get norm2() {\n\t        return this.s[0];\n\t    },\n\t    get rank() {\n\t        var eps = Math.pow(2, -52),\n\t            tol = Math.max(this.m, this.n) * this.s[0] * eps,\n\t            r = 0,\n\t            s = this.s;\n\t        for (var i = 0, ii = s.length; i < ii; i++) {\n\t            if (s[i] > tol) {\n\t                r++;\n\t            }\n\t        }\n\t        return r;\n\t    },\n\t    get diagonal() {\n\t        return this.s;\n\t    },\n\t    // https://github.com/accord-net/framework/blob/development/Sources/Accord.Math/Decompositions/SingularValueDecomposition.cs\n\t    get threshold() {\n\t        return (Math.pow(2, -52) / 2) * Math.max(this.m, this.n) * this.s[0];\n\t    },\n\t    get leftSingularVectors() {\n\t        return this.U;\n\t    },\n\t    get rightSingularVectors() {\n\t        return this.V;\n\t    },\n\t    get diagonalMatrix() {\n\t        return Matrix.diag(this.s);\n\t    },\n\t    solve: function (value) {\n\t\n\t        var Y = value,\n\t            e = this.threshold,\n\t            scols = this.s.length,\n\t            Ls = Matrix.zeros(scols, scols),\n\t            i;\n\t\n\t        for (i = 0; i < scols; i++) {\n\t            if (Math.abs(this.s[i]) <= e) {\n\t                Ls[i][i] = 0;\n\t            } else {\n\t                Ls[i][i] = 1 / this.s[i];\n\t            }\n\t        }\n\t\n\t\n\t        var VL = this.V.mmul(Ls),\n\t            vrows = this.V.rows,\n\t            urows = this.U.rows,\n\t            VLU = Matrix.zeros(vrows, urows),\n\t            j, k, sum;\n\t\n\t        for (i = 0; i < vrows; i++) {\n\t            for (j = 0; j < urows; j++) {\n\t                sum = 0;\n\t                for (k = 0; k < scols; k++) {\n\t                    sum += VL[i][k] * this.U[j][k];\n\t                }\n\t                VLU[i][j] = sum;\n\t            }\n\t        }\n\t\n\t        return VLU.mmul(Y);\n\t    },\n\t    solveForDiagonal: function (value) {\n\t        return this.solve(Matrix.diag(value));\n\t    },\n\t    inverse: function () {\n\t        var e = this.threshold,\n\t            vrows = this.V.rows,\n\t            vcols = this.V.columns,\n\t            X = new Matrix(vrows, this.s.length),\n\t            i, j;\n\t\n\t        for (i = 0; i < vrows; i++) {\n\t            for (j = 0; j < vcols; j++) {\n\t                if (Math.abs(this.s[j]) > e) {\n\t                    X[i][j] = this.V[i][j] / this.s[j];\n\t                } else {\n\t                    X[i][j] = 0;\n\t                }\n\t            }\n\t        }\n\t\n\t        var urows = this.U.rows,\n\t            ucols = this.U.columns,\n\t            Y = new Matrix(vrows, urows),\n\t            k, sum;\n\t\n\t        for (i = 0; i < vrows; i++) {\n\t            for (j = 0; j < urows; j++) {\n\t                sum = 0;\n\t                for (k = 0; k < ucols; k++) {\n\t                    sum += X[i][k] * this.U[j][k];\n\t                }\n\t                Y[i][j] = sum;\n\t            }\n\t        }\n\t\n\t        return Y;\n\t    }\n\t};\n\t\n\tmodule.exports = SingularValueDecomposition;\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.hypotenuse = function hypotenuse(a, b) {\n\t    var r;\n\t    if (Math.abs(a) > Math.abs(b)) {\n\t        r = b / a;\n\t        return Math.abs(a) * Math.sqrt(1 + r * r);\n\t    }\n\t    if (b !== 0) {\n\t        r = a / b;\n\t        return Math.abs(b) * Math.sqrt(1 + r * r);\n\t    }\n\t    return 0;\n\t};\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(18);\n\tvar hypotenuse = __webpack_require__(21).hypotenuse;\n\t\n\t// https://github.com/lutzroeder/Mapack/blob/master/Source/EigenvalueDecomposition.cs\n\tfunction EigenvalueDecomposition(matrix) {\n\t    if (!(this instanceof EigenvalueDecomposition)) {\n\t        return new EigenvalueDecomposition(matrix);\n\t    }\n\t    matrix = Matrix.checkMatrix(matrix);\n\t    if (!matrix.isSquare()) {\n\t        throw new Error('Matrix is not a square matrix');\n\t    }\n\t\n\t    var n = matrix.columns,\n\t        V = Matrix.zeros(n, n),\n\t        d = new Array(n),\n\t        e = new Array(n),\n\t        value = matrix,\n\t        i, j;\n\t\n\t    if (matrix.isSymmetric()) {\n\t        for (i = 0; i < n; i++) {\n\t            for (j = 0; j < n; j++) {\n\t                V[i][j] = value[i][j];\n\t            }\n\t        }\n\t        tred2(n, e, d, V);\n\t        tql2(n, e, d, V);\n\t    }\n\t    else {\n\t        var H = Matrix.zeros(n, n),\n\t            ort = new Array(n);\n\t        for (j = 0; j < n; j++) {\n\t            for (i = 0; i < n; i++) {\n\t                H[i][j] = value[i][j];\n\t            }\n\t        }\n\t        orthes(n, H, ort, V);\n\t        hqr2(n, e, d, V, H);\n\t    }\n\t\n\t    this.n = n;\n\t    this.e = e;\n\t    this.d = d;\n\t    this.V = V;\n\t}\n\t\n\tEigenvalueDecomposition.prototype = {\n\t    get realEigenvalues() {\n\t        return this.d;\n\t    },\n\t    get imaginaryEigenvalues() {\n\t        return this.e;\n\t    },\n\t    get eigenvectorMatrix() {\n\t        return this.V;\n\t    },\n\t    get diagonalMatrix() {\n\t        var n = this.n,\n\t            e = this.e,\n\t            d = this.d,\n\t            X = new Matrix(n, n),\n\t            i, j;\n\t        for (i = 0; i < n; i++) {\n\t            for (j = 0; j < n; j++) {\n\t                X[i][j] = 0;\n\t            }\n\t            X[i][i] = d[i];\n\t            if (e[i] > 0) {\n\t                X[i][i + 1] = e[i];\n\t            }\n\t            else if (e[i] < 0) {\n\t                X[i][i - 1] = e[i];\n\t            }\n\t        }\n\t        return X;\n\t    }\n\t};\n\t\n\tfunction tred2(n, e, d, V) {\n\t\n\t    var f, g, h, i, j, k,\n\t        hh, scale;\n\t\n\t    for (j = 0; j < n; j++) {\n\t        d[j] = V[n - 1][j];\n\t    }\n\t\n\t    for (i = n - 1; i > 0; i--) {\n\t        scale = 0;\n\t        h = 0;\n\t        for (k = 0; k < i; k++) {\n\t            scale = scale + Math.abs(d[k]);\n\t        }\n\t\n\t        if (scale === 0) {\n\t            e[i] = d[i - 1];\n\t            for (j = 0; j < i; j++) {\n\t                d[j] = V[i - 1][j];\n\t                V[i][j] = 0;\n\t                V[j][i] = 0;\n\t            }\n\t        } else {\n\t            for (k = 0; k < i; k++) {\n\t                d[k] /= scale;\n\t                h += d[k] * d[k];\n\t            }\n\t\n\t            f = d[i - 1];\n\t            g = Math.sqrt(h);\n\t            if (f > 0) {\n\t                g = -g;\n\t            }\n\t\n\t            e[i] = scale * g;\n\t            h = h - f * g;\n\t            d[i - 1] = f - g;\n\t            for (j = 0; j < i; j++) {\n\t                e[j] = 0;\n\t            }\n\t\n\t            for (j = 0; j < i; j++) {\n\t                f = d[j];\n\t                V[j][i] = f;\n\t                g = e[j] + V[j][j] * f;\n\t                for (k = j + 1; k <= i - 1; k++) {\n\t                    g += V[k][j] * d[k];\n\t                    e[k] += V[k][j] * f;\n\t                }\n\t                e[j] = g;\n\t            }\n\t\n\t            f = 0;\n\t            for (j = 0; j < i; j++) {\n\t                e[j] /= h;\n\t                f += e[j] * d[j];\n\t            }\n\t\n\t            hh = f / (h + h);\n\t            for (j = 0; j < i; j++) {\n\t                e[j] -= hh * d[j];\n\t            }\n\t\n\t            for (j = 0; j < i; j++) {\n\t                f = d[j];\n\t                g = e[j];\n\t                for (k = j; k <= i - 1; k++) {\n\t                    V[k][j] -= (f * e[k] + g * d[k]);\n\t                }\n\t                d[j] = V[i - 1][j];\n\t                V[i][j] = 0;\n\t            }\n\t        }\n\t        d[i] = h;\n\t    }\n\t\n\t    for (i = 0; i < n - 1; i++) {\n\t        V[n - 1][i] = V[i][i];\n\t        V[i][i] = 1;\n\t        h = d[i + 1];\n\t        if (h !== 0) {\n\t            for (k = 0; k <= i; k++) {\n\t                d[k] = V[k][i + 1] / h;\n\t            }\n\t\n\t            for (j = 0; j <= i; j++) {\n\t                g = 0;\n\t                for (k = 0; k <= i; k++) {\n\t                    g += V[k][i + 1] * V[k][j];\n\t                }\n\t                for (k = 0; k <= i; k++) {\n\t                    V[k][j] -= g * d[k];\n\t                }\n\t            }\n\t        }\n\t\n\t        for (k = 0; k <= i; k++) {\n\t            V[k][i + 1] = 0;\n\t        }\n\t    }\n\t\n\t    for (j = 0; j < n; j++) {\n\t        d[j] = V[n - 1][j];\n\t        V[n - 1][j] = 0;\n\t    }\n\t\n\t    V[n - 1][n - 1] = 1;\n\t    e[0] = 0;\n\t}\n\t\n\tfunction tql2(n, e, d, V) {\n\t\n\t    var g, h, i, j, k, l, m, p, r,\n\t        dl1, c, c2, c3, el1, s, s2,\n\t        iter;\n\t\n\t    for (i = 1; i < n; i++) {\n\t        e[i - 1] = e[i];\n\t    }\n\t\n\t    e[n - 1] = 0;\n\t\n\t    var f = 0,\n\t        tst1 = 0,\n\t        eps = Math.pow(2, -52);\n\t\n\t    for (l = 0; l < n; l++) {\n\t        tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));\n\t        m = l;\n\t        while (m < n) {\n\t            if (Math.abs(e[m]) <= eps * tst1) {\n\t                break;\n\t            }\n\t            m++;\n\t        }\n\t\n\t        if (m > l) {\n\t            iter = 0;\n\t            do {\n\t                iter = iter + 1;\n\t\n\t                g = d[l];\n\t                p = (d[l + 1] - g) / (2 * e[l]);\n\t                r = hypotenuse(p, 1);\n\t                if (p < 0) {\n\t                    r = -r;\n\t                }\n\t\n\t                d[l] = e[l] / (p + r);\n\t                d[l + 1] = e[l] * (p + r);\n\t                dl1 = d[l + 1];\n\t                h = g - d[l];\n\t                for (i = l + 2; i < n; i++) {\n\t                    d[i] -= h;\n\t                }\n\t\n\t                f = f + h;\n\t\n\t                p = d[m];\n\t                c = 1;\n\t                c2 = c;\n\t                c3 = c;\n\t                el1 = e[l + 1];\n\t                s = 0;\n\t                s2 = 0;\n\t                for (i = m - 1; i >= l; i--) {\n\t                    c3 = c2;\n\t                    c2 = c;\n\t                    s2 = s;\n\t                    g = c * e[i];\n\t                    h = c * p;\n\t                    r = hypotenuse(p, e[i]);\n\t                    e[i + 1] = s * r;\n\t                    s = e[i] / r;\n\t                    c = p / r;\n\t                    p = c * d[i] - s * g;\n\t                    d[i + 1] = h + s * (c * g + s * d[i]);\n\t\n\t                    for (k = 0; k < n; k++) {\n\t                        h = V[k][i + 1];\n\t                        V[k][i + 1] = s * V[k][i] + c * h;\n\t                        V[k][i] = c * V[k][i] - s * h;\n\t                    }\n\t                }\n\t\n\t                p = -s * s2 * c3 * el1 * e[l] / dl1;\n\t                e[l] = s * p;\n\t                d[l] = c * p;\n\t\n\t            }\n\t            while (Math.abs(e[l]) > eps * tst1);\n\t        }\n\t        d[l] = d[l] + f;\n\t        e[l] = 0;\n\t    }\n\t\n\t    for (i = 0; i < n - 1; i++) {\n\t        k = i;\n\t        p = d[i];\n\t        for (j = i + 1; j < n; j++) {\n\t            if (d[j] < p) {\n\t                k = j;\n\t                p = d[j];\n\t            }\n\t        }\n\t\n\t        if (k !== i) {\n\t            d[k] = d[i];\n\t            d[i] = p;\n\t            for (j = 0; j < n; j++) {\n\t                p = V[j][i];\n\t                V[j][i] = V[j][k];\n\t                V[j][k] = p;\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction orthes(n, H, ort, V) {\n\t\n\t    var low = 0,\n\t        high = n - 1,\n\t        f, g, h, i, j, m,\n\t        scale;\n\t\n\t    for (m = low + 1; m <= high - 1; m++) {\n\t        scale = 0;\n\t        for (i = m; i <= high; i++) {\n\t            scale = scale + Math.abs(H[i][m - 1]);\n\t        }\n\t\n\t        if (scale !== 0) {\n\t            h = 0;\n\t            for (i = high; i >= m; i--) {\n\t                ort[i] = H[i][m - 1] / scale;\n\t                h += ort[i] * ort[i];\n\t            }\n\t\n\t            g = Math.sqrt(h);\n\t            if (ort[m] > 0) {\n\t                g = -g;\n\t            }\n\t\n\t            h = h - ort[m] * g;\n\t            ort[m] = ort[m] - g;\n\t\n\t            for (j = m; j < n; j++) {\n\t                f = 0;\n\t                for (i = high; i >= m; i--) {\n\t                    f += ort[i] * H[i][j];\n\t                }\n\t\n\t                f = f / h;\n\t                for (i = m; i <= high; i++) {\n\t                    H[i][j] -= f * ort[i];\n\t                }\n\t            }\n\t\n\t            for (i = 0; i <= high; i++) {\n\t                f = 0;\n\t                for (j = high; j >= m; j--) {\n\t                    f += ort[j] * H[i][j];\n\t                }\n\t\n\t                f = f / h;\n\t                for (j = m; j <= high; j++) {\n\t                    H[i][j] -= f * ort[j];\n\t                }\n\t            }\n\t\n\t            ort[m] = scale * ort[m];\n\t            H[m][m - 1] = scale * g;\n\t        }\n\t    }\n\t\n\t    for (i = 0; i < n; i++) {\n\t        for (j = 0; j < n; j++) {\n\t            V[i][j] = (i === j ? 1 : 0);\n\t        }\n\t    }\n\t\n\t    for (m = high - 1; m >= low + 1; m--) {\n\t        if (H[m][m - 1] !== 0) {\n\t            for (i = m + 1; i <= high; i++) {\n\t                ort[i] = H[i][m - 1];\n\t            }\n\t\n\t            for (j = m; j <= high; j++) {\n\t                g = 0;\n\t                for (i = m; i <= high; i++) {\n\t                    g += ort[i] * V[i][j];\n\t                }\n\t\n\t                g = (g / ort[m]) / H[m][m - 1];\n\t                for (i = m; i <= high; i++) {\n\t                    V[i][j] += g * ort[i];\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction hqr2(nn, e, d, V, H) {\n\t    var n = nn - 1,\n\t        low = 0,\n\t        high = nn - 1,\n\t        eps = Math.pow(2, -52),\n\t        exshift = 0,\n\t        norm = 0,\n\t        p = 0,\n\t        q = 0,\n\t        r = 0,\n\t        s = 0,\n\t        z = 0,\n\t        iter = 0,\n\t        i, j, k, l, m, t, w, x, y,\n\t        ra, sa, vr, vi,\n\t        notlast, cdivres;\n\t\n\t    for (i = 0; i < nn; i++) {\n\t        if (i < low || i > high) {\n\t            d[i] = H[i][i];\n\t            e[i] = 0;\n\t        }\n\t\n\t        for (j = Math.max(i - 1, 0); j < nn; j++) {\n\t            norm = norm + Math.abs(H[i][j]);\n\t        }\n\t    }\n\t\n\t    while (n >= low) {\n\t        l = n;\n\t        while (l > low) {\n\t            s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);\n\t            if (s === 0) {\n\t                s = norm;\n\t            }\n\t            if (Math.abs(H[l][l - 1]) < eps * s) {\n\t                break;\n\t            }\n\t            l--;\n\t        }\n\t\n\t        if (l === n) {\n\t            H[n][n] = H[n][n] + exshift;\n\t            d[n] = H[n][n];\n\t            e[n] = 0;\n\t            n--;\n\t            iter = 0;\n\t        } else if (l === n - 1) {\n\t            w = H[n][n - 1] * H[n - 1][n];\n\t            p = (H[n - 1][n - 1] - H[n][n]) / 2;\n\t            q = p * p + w;\n\t            z = Math.sqrt(Math.abs(q));\n\t            H[n][n] = H[n][n] + exshift;\n\t            H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;\n\t            x = H[n][n];\n\t\n\t            if (q >= 0) {\n\t                z = (p >= 0) ? (p + z) : (p - z);\n\t                d[n - 1] = x + z;\n\t                d[n] = d[n - 1];\n\t                if (z !== 0) {\n\t                    d[n] = x - w / z;\n\t                }\n\t                e[n - 1] = 0;\n\t                e[n] = 0;\n\t                x = H[n][n - 1];\n\t                s = Math.abs(x) + Math.abs(z);\n\t                p = x / s;\n\t                q = z / s;\n\t                r = Math.sqrt(p * p + q * q);\n\t                p = p / r;\n\t                q = q / r;\n\t\n\t                for (j = n - 1; j < nn; j++) {\n\t                    z = H[n - 1][j];\n\t                    H[n - 1][j] = q * z + p * H[n][j];\n\t                    H[n][j] = q * H[n][j] - p * z;\n\t                }\n\t\n\t                for (i = 0; i <= n; i++) {\n\t                    z = H[i][n - 1];\n\t                    H[i][n - 1] = q * z + p * H[i][n];\n\t                    H[i][n] = q * H[i][n] - p * z;\n\t                }\n\t\n\t                for (i = low; i <= high; i++) {\n\t                    z = V[i][n - 1];\n\t                    V[i][n - 1] = q * z + p * V[i][n];\n\t                    V[i][n] = q * V[i][n] - p * z;\n\t                }\n\t            } else {\n\t                d[n - 1] = x + p;\n\t                d[n] = x + p;\n\t                e[n - 1] = z;\n\t                e[n] = -z;\n\t            }\n\t\n\t            n = n - 2;\n\t            iter = 0;\n\t        } else {\n\t            x = H[n][n];\n\t            y = 0;\n\t            w = 0;\n\t            if (l < n) {\n\t                y = H[n - 1][n - 1];\n\t                w = H[n][n - 1] * H[n - 1][n];\n\t            }\n\t\n\t            if (iter === 10) {\n\t                exshift += x;\n\t                for (i = low; i <= n; i++) {\n\t                    H[i][i] -= x;\n\t                }\n\t                s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);\n\t                x = y = 0.75 * s;\n\t                w = -0.4375 * s * s;\n\t            }\n\t\n\t            if (iter === 30) {\n\t                s = (y - x) / 2;\n\t                s = s * s + w;\n\t                if (s > 0) {\n\t                    s = Math.sqrt(s);\n\t                    if (y < x) {\n\t                        s = -s;\n\t                    }\n\t                    s = x - w / ((y - x) / 2 + s);\n\t                    for (i = low; i <= n; i++) {\n\t                        H[i][i] -= s;\n\t                    }\n\t                    exshift += s;\n\t                    x = y = w = 0.964;\n\t                }\n\t            }\n\t\n\t            iter = iter + 1;\n\t\n\t            m = n - 2;\n\t            while (m >= l) {\n\t                z = H[m][m];\n\t                r = x - z;\n\t                s = y - z;\n\t                p = (r * s - w) / H[m + 1][m] + H[m][m + 1];\n\t                q = H[m + 1][m + 1] - z - r - s;\n\t                r = H[m + 2][m + 1];\n\t                s = Math.abs(p) + Math.abs(q) + Math.abs(r);\n\t                p = p / s;\n\t                q = q / s;\n\t                r = r / s;\n\t                if (m === l) {\n\t                    break;\n\t                }\n\t                if (Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) < eps * (Math.abs(p) * (Math.abs(H[m - 1][m - 1]) + Math.abs(z) + Math.abs(H[m + 1][m + 1])))) {\n\t                    break;\n\t                }\n\t                m--;\n\t            }\n\t\n\t            for (i = m + 2; i <= n; i++) {\n\t                H[i][i - 2] = 0;\n\t                if (i > m + 2) {\n\t                    H[i][i - 3] = 0;\n\t                }\n\t            }\n\t\n\t            for (k = m; k <= n - 1; k++) {\n\t                notlast = (k !== n - 1);\n\t                if (k !== m) {\n\t                    p = H[k][k - 1];\n\t                    q = H[k + 1][k - 1];\n\t                    r = (notlast ? H[k + 2][k - 1] : 0);\n\t                    x = Math.abs(p) + Math.abs(q) + Math.abs(r);\n\t                    if (x !== 0) {\n\t                        p = p / x;\n\t                        q = q / x;\n\t                        r = r / x;\n\t                    }\n\t                }\n\t\n\t                if (x === 0) {\n\t                    break;\n\t                }\n\t\n\t                s = Math.sqrt(p * p + q * q + r * r);\n\t                if (p < 0) {\n\t                    s = -s;\n\t                }\n\t\n\t                if (s !== 0) {\n\t                    if (k !== m) {\n\t                        H[k][k - 1] = -s * x;\n\t                    } else if (l !== m) {\n\t                        H[k][k - 1] = -H[k][k - 1];\n\t                    }\n\t\n\t                    p = p + s;\n\t                    x = p / s;\n\t                    y = q / s;\n\t                    z = r / s;\n\t                    q = q / p;\n\t                    r = r / p;\n\t\n\t                    for (j = k; j < nn; j++) {\n\t                        p = H[k][j] + q * H[k + 1][j];\n\t                        if (notlast) {\n\t                            p = p + r * H[k + 2][j];\n\t                            H[k + 2][j] = H[k + 2][j] - p * z;\n\t                        }\n\t\n\t                        H[k][j] = H[k][j] - p * x;\n\t                        H[k + 1][j] = H[k + 1][j] - p * y;\n\t                    }\n\t\n\t                    for (i = 0; i <= Math.min(n, k + 3); i++) {\n\t                        p = x * H[i][k] + y * H[i][k + 1];\n\t                        if (notlast) {\n\t                            p = p + z * H[i][k + 2];\n\t                            H[i][k + 2] = H[i][k + 2] - p * r;\n\t                        }\n\t\n\t                        H[i][k] = H[i][k] - p;\n\t                        H[i][k + 1] = H[i][k + 1] - p * q;\n\t                    }\n\t\n\t                    for (i = low; i <= high; i++) {\n\t                        p = x * V[i][k] + y * V[i][k + 1];\n\t                        if (notlast) {\n\t                            p = p + z * V[i][k + 2];\n\t                            V[i][k + 2] = V[i][k + 2] - p * r;\n\t                        }\n\t\n\t                        V[i][k] = V[i][k] - p;\n\t                        V[i][k + 1] = V[i][k + 1] - p * q;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    if (norm === 0) {\n\t        return;\n\t    }\n\t\n\t    for (n = nn - 1; n >= 0; n--) {\n\t        p = d[n];\n\t        q = e[n];\n\t\n\t        if (q === 0) {\n\t            l = n;\n\t            H[n][n] = 1;\n\t            for (i = n - 1; i >= 0; i--) {\n\t                w = H[i][i] - p;\n\t                r = 0;\n\t                for (j = l; j <= n; j++) {\n\t                    r = r + H[i][j] * H[j][n];\n\t                }\n\t\n\t                if (e[i] < 0) {\n\t                    z = w;\n\t                    s = r;\n\t                } else {\n\t                    l = i;\n\t                    if (e[i] === 0) {\n\t                        H[i][n] = (w !== 0) ? (-r / w) : (-r / (eps * norm));\n\t                    } else {\n\t                        x = H[i][i + 1];\n\t                        y = H[i + 1][i];\n\t                        q = (d[i] - p) * (d[i] - p) + e[i] * e[i];\n\t                        t = (x * s - z * r) / q;\n\t                        H[i][n] = t;\n\t                        H[i + 1][n] = (Math.abs(x) > Math.abs(z)) ? ((-r - w * t) / x) : ((-s - y * t) / z);\n\t                    }\n\t\n\t                    t = Math.abs(H[i][n]);\n\t                    if ((eps * t) * t > 1) {\n\t                        for (j = i; j <= n; j++) {\n\t                            H[j][n] = H[j][n] / t;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        } else if (q < 0) {\n\t            l = n - 1;\n\t\n\t            if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {\n\t                H[n - 1][n - 1] = q / H[n][n - 1];\n\t                H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];\n\t            } else {\n\t                cdivres = cdiv(0, -H[n - 1][n], H[n - 1][n - 1] - p, q);\n\t                H[n - 1][n - 1] = cdivres[0];\n\t                H[n - 1][n] = cdivres[1];\n\t            }\n\t\n\t            H[n][n - 1] = 0;\n\t            H[n][n] = 1;\n\t            for (i = n - 2; i >= 0; i--) {\n\t                ra = 0;\n\t                sa = 0;\n\t                for (j = l; j <= n; j++) {\n\t                    ra = ra + H[i][j] * H[j][n - 1];\n\t                    sa = sa + H[i][j] * H[j][n];\n\t                }\n\t\n\t                w = H[i][i] - p;\n\t\n\t                if (e[i] < 0) {\n\t                    z = w;\n\t                    r = ra;\n\t                    s = sa;\n\t                } else {\n\t                    l = i;\n\t                    if (e[i] === 0) {\n\t                        cdivres = cdiv(-ra, -sa, w, q);\n\t                        H[i][n - 1] = cdivres[0];\n\t                        H[i][n] = cdivres[1];\n\t                    } else {\n\t                        x = H[i][i + 1];\n\t                        y = H[i + 1][i];\n\t                        vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;\n\t                        vi = (d[i] - p) * 2 * q;\n\t                        if (vr === 0 && vi === 0) {\n\t                            vr = eps * norm * (Math.abs(w) + Math.abs(q) + Math.abs(x) + Math.abs(y) + Math.abs(z));\n\t                        }\n\t                        cdivres = cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);\n\t                        H[i][n - 1] = cdivres[0];\n\t                        H[i][n] = cdivres[1];\n\t                        if (Math.abs(x) > (Math.abs(z) + Math.abs(q))) {\n\t                            H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;\n\t                            H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;\n\t                        } else {\n\t                            cdivres = cdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);\n\t                            H[i + 1][n - 1] = cdivres[0];\n\t                            H[i + 1][n] = cdivres[1];\n\t                        }\n\t                    }\n\t\n\t                    t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));\n\t                    if ((eps * t) * t > 1) {\n\t                        for (j = i; j <= n; j++) {\n\t                            H[j][n - 1] = H[j][n - 1] / t;\n\t                            H[j][n] = H[j][n] / t;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    for (i = 0; i < nn; i++) {\n\t        if (i < low || i > high) {\n\t            for (j = i; j < nn; j++) {\n\t                V[i][j] = H[i][j];\n\t            }\n\t        }\n\t    }\n\t\n\t    for (j = nn - 1; j >= low; j--) {\n\t        for (i = low; i <= high; i++) {\n\t            z = 0;\n\t            for (k = low; k <= Math.min(j, high); k++) {\n\t                z = z + V[i][k] * H[k][j];\n\t            }\n\t            V[i][j] = z;\n\t        }\n\t    }\n\t}\n\t\n\tfunction cdiv(xr, xi, yr, yi) {\n\t    var r, d;\n\t    if (Math.abs(yr) > Math.abs(yi)) {\n\t        r = yi / yr;\n\t        d = yr + r * yi;\n\t        return [(xr + r * xi) / d, (xi - r * xr) / d];\n\t    }\n\t    else {\n\t        r = yr / yi;\n\t        d = yi + r * yr;\n\t        return [(r * xr + xi) / d, (r * xi - xr) / d];\n\t    }\n\t}\n\t\n\tmodule.exports = EigenvalueDecomposition;\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(18);\n\t\n\t// https://github.com/lutzroeder/Mapack/blob/master/Source/LuDecomposition.cs\n\tfunction LuDecomposition(matrix) {\n\t    if (!(this instanceof LuDecomposition)) {\n\t        return new LuDecomposition(matrix);\n\t    }\n\t    matrix = Matrix.checkMatrix(matrix);\n\t\n\t    var lu = matrix.clone(),\n\t        rows = lu.rows,\n\t        columns = lu.columns,\n\t        pivotVector = new Array(rows),\n\t        pivotSign = 1,\n\t        i, j, k, p, s, t, v,\n\t        LUrowi, LUcolj, kmax;\n\t\n\t    for (i = 0; i < rows; i++) {\n\t        pivotVector[i] = i;\n\t    }\n\t\n\t    LUcolj = new Array(rows);\n\t\n\t    for (j = 0; j < columns; j++) {\n\t\n\t        for (i = 0; i < rows; i++) {\n\t            LUcolj[i] = lu[i][j];\n\t        }\n\t\n\t        for (i = 0; i < rows; i++) {\n\t            LUrowi = lu[i];\n\t            kmax = Math.min(i, j);\n\t            s = 0;\n\t            for (k = 0; k < kmax; k++) {\n\t                s += LUrowi[k] * LUcolj[k];\n\t            }\n\t            LUrowi[j] = LUcolj[i] -= s;\n\t        }\n\t\n\t        p = j;\n\t        for (i = j + 1; i < rows; i++) {\n\t            if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {\n\t                p = i;\n\t            }\n\t        }\n\t\n\t        if (p !== j) {\n\t            for (k = 0; k < columns; k++) {\n\t                t = lu[p][k];\n\t                lu[p][k] = lu[j][k];\n\t                lu[j][k] = t;\n\t            }\n\t\n\t            v = pivotVector[p];\n\t            pivotVector[p] = pivotVector[j];\n\t            pivotVector[j] = v;\n\t\n\t            pivotSign = -pivotSign;\n\t        }\n\t\n\t        if (j < rows && lu[j][j] !== 0) {\n\t            for (i = j + 1; i < rows; i++) {\n\t                lu[i][j] /= lu[j][j];\n\t            }\n\t        }\n\t    }\n\t\n\t    this.LU = lu;\n\t    this.pivotVector = pivotVector;\n\t    this.pivotSign = pivotSign;\n\t}\n\t\n\tLuDecomposition.prototype = {\n\t    isSingular: function () {\n\t        var data = this.LU,\n\t            col = data.columns;\n\t        for (var j = 0; j < col; j++) {\n\t            if (data[j][j] === 0) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    },\n\t    get determinant() {\n\t        var data = this.LU;\n\t        if (!data.isSquare())\n\t            throw new Error('Matrix must be square');\n\t        var determinant = this.pivotSign, col = data.columns;\n\t        for (var j = 0; j < col; j++)\n\t            determinant *= data[j][j];\n\t        return determinant;\n\t    },\n\t    get lowerTriangularFactor() {\n\t        var data = this.LU,\n\t            rows = data.rows,\n\t            columns = data.columns,\n\t            X = new Matrix(rows, columns);\n\t        for (var i = 0; i < rows; i++) {\n\t            for (var j = 0; j < columns; j++) {\n\t                if (i > j) {\n\t                    X[i][j] = data[i][j];\n\t                } else if (i === j) {\n\t                    X[i][j] = 1;\n\t                } else {\n\t                    X[i][j] = 0;\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    },\n\t    get upperTriangularFactor() {\n\t        var data = this.LU,\n\t            rows = data.rows,\n\t            columns = data.columns,\n\t            X = new Matrix(rows, columns);\n\t        for (var i = 0; i < rows; i++) {\n\t            for (var j = 0; j < columns; j++) {\n\t                if (i <= j) {\n\t                    X[i][j] = data[i][j];\n\t                } else {\n\t                    X[i][j] = 0;\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    },\n\t    get pivotPermutationVector() {\n\t        return this.pivotVector.slice();\n\t    },\n\t    solve: function (value) {\n\t        value = Matrix.checkMatrix(value);\n\t\n\t        var lu = this.LU,\n\t            rows = lu.rows;\n\t\n\t        if (rows !== value.rows)\n\t            throw new Error('Invalid matrix dimensions');\n\t        if (this.isSingular())\n\t            throw new Error('LU matrix is singular');\n\t\n\t        var count = value.columns,\n\t            X = value.subMatrixRow(this.pivotVector, 0, count - 1),\n\t            columns = lu.columns,\n\t            i, j, k;\n\t\n\t        for (k = 0; k < columns; k++) {\n\t            for (i = k + 1; i < columns; i++) {\n\t                for (j = 0; j < count; j++) {\n\t                    X[i][j] -= X[k][j] * lu[i][k];\n\t                }\n\t            }\n\t        }\n\t        for (k = columns - 1; k >= 0; k--) {\n\t            for (j = 0; j < count; j++) {\n\t                X[k][j] /= lu[k][k];\n\t            }\n\t            for (i = 0; i < k; i++) {\n\t                for (j = 0; j < count; j++) {\n\t                    X[i][j] -= X[k][j] * lu[i][k];\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    }\n\t};\n\t\n\tmodule.exports = LuDecomposition;\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(18);\n\tvar hypotenuse = __webpack_require__(21).hypotenuse;\n\t\n\t//https://github.com/lutzroeder/Mapack/blob/master/Source/QrDecomposition.cs\n\tfunction QrDecomposition(value) {\n\t    if (!(this instanceof QrDecomposition)) {\n\t        return new QrDecomposition(value);\n\t    }\n\t    value = Matrix.checkMatrix(value);\n\t\n\t    var qr = value.clone(),\n\t        m = value.rows,\n\t        n = value.columns,\n\t        rdiag = new Array(n),\n\t        i, j, k, s;\n\t\n\t    for (k = 0; k < n; k++) {\n\t        var nrm = 0;\n\t        for (i = k; i < m; i++) {\n\t            nrm = hypotenuse(nrm, qr[i][k]);\n\t        }\n\t        if (nrm !== 0) {\n\t            if (qr[k][k] < 0) {\n\t                nrm = -nrm;\n\t            }\n\t            for (i = k; i < m; i++) {\n\t                qr[i][k] /= nrm;\n\t            }\n\t            qr[k][k] += 1;\n\t            for (j = k + 1; j < n; j++) {\n\t                s = 0;\n\t                for (i = k; i < m; i++) {\n\t                    s += qr[i][k] * qr[i][j];\n\t                }\n\t                s = -s / qr[k][k];\n\t                for (i = k; i < m; i++) {\n\t                    qr[i][j] += s * qr[i][k];\n\t                }\n\t            }\n\t        }\n\t        rdiag[k] = -nrm;\n\t    }\n\t\n\t    this.QR = qr;\n\t    this.Rdiag = rdiag;\n\t}\n\t\n\tQrDecomposition.prototype = {\n\t    solve: function (value) {\n\t        value = Matrix.checkMatrix(value);\n\t\n\t        var qr = this.QR,\n\t            m = qr.rows;\n\t\n\t        if (value.rows !== m)\n\t            throw new Error('Matrix row dimensions must agree');\n\t        if (!this.isFullRank())\n\t            throw new Error('Matrix is rank deficient');\n\t\n\t        var count = value.columns,\n\t            X = value.clone(),\n\t            n = qr.columns,\n\t            i, j, k, s;\n\t\n\t        for (k = 0; k < n; k++) {\n\t            for (j = 0; j < count; j++) {\n\t                s = 0;\n\t                for (i = k; i < m; i++) {\n\t                    s += qr[i][k] * X[i][j];\n\t                }\n\t                s = -s / qr[k][k];\n\t                for (i = k; i < m; i++) {\n\t                    X[i][j] += s * qr[i][k];\n\t                }\n\t            }\n\t        }\n\t        for (k = n - 1; k >= 0; k--) {\n\t            for (j = 0; j < count; j++) {\n\t                X[k][j] /= this.Rdiag[k];\n\t            }\n\t            for (i = 0; i < k; i++) {\n\t                for (j = 0; j < count; j++) {\n\t                    X[i][j] -= X[k][j] * qr[i][k];\n\t                }\n\t            }\n\t        }\n\t\n\t        return X.subMatrix(0, n - 1, 0, count - 1);\n\t    },\n\t    isFullRank: function () {\n\t        var columns = this.QR.columns;\n\t        for (var i = 0; i < columns; i++) {\n\t            if (this.Rdiag[i] === 0) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    },\n\t    get upperTriangularFactor() {\n\t        var qr = this.QR,\n\t            n = qr.columns,\n\t            X = new Matrix(n, n),\n\t            i, j;\n\t        for (i = 0; i < n; i++) {\n\t            for (j = 0; j < n; j++) {\n\t                if (i < j) {\n\t                    X[i][j] = qr[i][j];\n\t                } else if (i === j) {\n\t                    X[i][j] = this.Rdiag[i];\n\t                } else {\n\t                    X[i][j] = 0;\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    },\n\t    get orthogonalFactor() {\n\t        var qr = this.QR,\n\t            rows = qr.rows,\n\t            columns = qr.columns,\n\t            X = new Matrix(rows, columns),\n\t            i, j, k, s;\n\t\n\t        for (k = columns - 1; k >= 0; k--) {\n\t            for (i = 0; i < rows; i++) {\n\t                X[i][k] = 0;\n\t            }\n\t            X[k][k] = 1;\n\t            for (j = k; j < columns; j++) {\n\t                if (qr[k][k] !== 0) {\n\t                    s = 0;\n\t                    for (i = k; i < rows; i++) {\n\t                        s += qr[i][k] * X[i][j];\n\t                    }\n\t\n\t                    s = -s / qr[k][k];\n\t\n\t                    for (i = k; i < rows; i++) {\n\t                        X[i][j] += s * qr[i][k];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    }\n\t};\n\t\n\tmodule.exports = QrDecomposition;\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(18);\n\t\n\t// https://github.com/lutzroeder/Mapack/blob/master/Source/CholeskyDecomposition.cs\n\tfunction CholeskyDecomposition(value) {\n\t    if (!(this instanceof CholeskyDecomposition)) {\n\t        return new CholeskyDecomposition(value);\n\t    }\n\t    value = Matrix.checkMatrix(value);\n\t    if (!value.isSymmetric())\n\t        throw new Error('Matrix is not symmetric');\n\t\n\t    var a = value,\n\t        dimension = a.rows,\n\t        l = new Matrix(dimension, dimension),\n\t        positiveDefinite = true,\n\t        i, j, k;\n\t\n\t    for (j = 0; j < dimension; j++) {\n\t        var Lrowj = l[j];\n\t        var d = 0;\n\t        for (k = 0; k < j; k++) {\n\t            var Lrowk = l[k];\n\t            var s = 0;\n\t            for (i = 0; i < k; i++) {\n\t                s += Lrowk[i] * Lrowj[i];\n\t            }\n\t            Lrowj[k] = s = (a[j][k] - s) / l[k][k];\n\t            d = d + s * s;\n\t        }\n\t\n\t        d = a[j][j] - d;\n\t\n\t        positiveDefinite &= (d > 0);\n\t        l[j][j] = Math.sqrt(Math.max(d, 0));\n\t        for (k = j + 1; k < dimension; k++) {\n\t            l[j][k] = 0;\n\t        }\n\t    }\n\t\n\t    if (!positiveDefinite) {\n\t        throw new Error('Matrix is not positive definite');\n\t    }\n\t\n\t    this.L = l;\n\t}\n\t\n\tCholeskyDecomposition.prototype = {\n\t    get leftTriangularFactor() {\n\t        return this.L;\n\t    },\n\t    solve: function (value) {\n\t        value = Matrix.checkMatrix(value);\n\t\n\t        var l = this.L,\n\t            dimension = l.rows;\n\t\n\t        if (value.rows !== dimension) {\n\t            throw new Error('Matrix dimensions do not match');\n\t        }\n\t\n\t        var count = value.columns,\n\t            B = value.clone(),\n\t            i, j, k;\n\t\n\t        for (k = 0; k < dimension; k++) {\n\t            for (j = 0; j < count; j++) {\n\t                for (i = 0; i < k; i++) {\n\t                    B[k][j] -= B[i][j] * l[k][i];\n\t                }\n\t                B[k][j] /= l[k][k];\n\t            }\n\t        }\n\t\n\t        for (k = dimension - 1; k >= 0; k--) {\n\t            for (j = 0; j < count; j++) {\n\t                for (i = k + 1; i < dimension; i++) {\n\t                    B[k][j] -= B[i][j] * l[i][k];\n\t                }\n\t                B[k][j] /= l[k][k];\n\t            }\n\t        }\n\t\n\t        return B;\n\t    }\n\t};\n\t\n\tmodule.exports = CholeskyDecomposition;\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Created by acastillo on 8/24/15.\n\t */\n\t/**\n\t * Non in-place function definitions, compatible with mathjs code *\n\t */\n\t\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(17);\n\t\n\tfunction matrix(A,B){\n\t    return new Matrix(A,B);\n\t}\n\t\n\tfunction ones(rows, cols){\n\t    return Matrix.ones(rows,cols);\n\t}\n\t\n\tfunction eye(rows, cols){\n\t    return Matrix.eye(rows, cols);\n\t}\n\t\n\tfunction zeros(rows, cols){\n\t    return Matrix.zeros(rows, cols);\n\t}\n\t\n\tfunction random(rows, cols){\n\t    return Matrix.rand(rows,cols);\n\t}\n\t\n\tfunction transpose(A){\n\t    if(typeof A == 'number')\n\t        return A;\n\t    var result = A.clone();\n\t    return result.transpose();\n\t}\n\t\n\tfunction add(A, B){\n\t    if(typeof A == 'number'&&typeof B === 'number')\n\t        return A+B;\n\t    if(typeof A == 'number')\n\t        return this.add(B,A);\n\t\n\t    var result = A.clone();\n\t    return result.add(B);\n\t\n\t}\n\t\n\tfunction subtract(A, B){\n\t    if(typeof A == 'number'&&typeof B === 'number')\n\t        return A-B;\n\t    if(typeof A == 'number')\n\t        return this.subtract(B,A);\n\t    var result = A.clone();\n\t    return result.sub(B);\n\t}\n\t\n\tfunction multiply(A, B){\n\t    if(typeof A == 'number'&&typeof B === 'number')\n\t        return A*B;\n\t    if(typeof A == 'number')\n\t        return this.multiply(B,A);\n\t\n\t    var result = A.clone();\n\t\n\t    if(typeof B === 'number')\n\t        result.mul(B);\n\t    else\n\t        result = result.mmul(B);\n\t\n\t    if(result.rows==1&&result.columns==1)\n\t        return result[0][0];\n\t    else\n\t        return result;\n\t\n\t}\n\t\n\tfunction dotMultiply(A, B){\n\t    var result = A.clone();\n\t    return result.mul(B);\n\t}\n\t\n\tfunction dotDivide(A, B){\n\t    var result = A.clone();\n\t    return result.div(B);\n\t}\n\t\n\tfunction diag(A){\n\t    var diag = null;\n\t    var rows = A.rows, cols = A.columns, j, r;\n\t    //It is an array\n\t    if(typeof cols === \"undefined\" && (typeof A)=='object'){\n\t        if(A[0]&&A[0].length){\n\t            rows = A.length;\n\t            cols = A[0].length;\n\t            r = Math.min(rows,cols);\n\t            diag = Matrix.zeros(cols, cols);\n\t            for (j = 0; j < cols; j++) {\n\t                diag[j][j]=A[j][j];\n\t            }\n\t        }\n\t        else{\n\t            cols = A.length;\n\t            diag = Matrix.zeros(cols, cols);\n\t            for (j = 0; j < cols; j++) {\n\t                diag[j][j]=A[j];\n\t            }\n\t        }\n\t\n\t    }\n\t    if(rows == 1){\n\t        diag = Matrix.zeros(cols, cols);\n\t        for (j = 0; j < cols; j++) {\n\t            diag[j][j]=A[0][j];\n\t        }\n\t    }\n\t    else{\n\t        if(rows>0 && cols > 0){\n\t            r = Math.min(rows,cols);\n\t            diag = new Array(r);\n\t            for (j = 0; j < r; j++) {\n\t                diag[j] = A[j][j];\n\t            }\n\t        }\n\t    }\n\t    return diag;\n\t}\n\t\n\tfunction min(A, B){\n\t    if(typeof A==='number' && typeof B ==='number')\n\t        return Math.min(A,B);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (A[i][j] < B[i][j]) {\n\t                result[i][j] = A[i][j];\n\t            }\n\t            else{\n\t                result[i][j] = B[i][j];\n\t            }\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction max(A, B){\n\t    if(typeof A==='number' && typeof B ==='number')\n\t        return Math.max(A,B);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (A[i][j] > B[i][j]) {\n\t                result[i][j] = A[i][j];\n\t            }\n\t            else{\n\t                result[i][j] = B[i][j];\n\t            }\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction sqrt(A){\n\t    if(typeof A==='number' )\n\t        return Math.sqrt(A);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            result[i][j] = Math.sqrt(A[i][j]);\n\t\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction abs(A){\n\t    if(typeof A==='number' )\n\t        return Math.abs(A);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            result[i][j] = Math.abs(A[i][j]);\n\t\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction exp(A){\n\t    if(typeof A==='number' )\n\t        return Math.sqrt(A);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            result[i][j] = Math.exp(A[i][j]);\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction dotPow(A, b){\n\t    if(typeof A==='number' )\n\t        return Math.pow(A,b);\n\t    //console.log(A);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            result[i][j] = Math.pow(A[i][j],b);\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction solve(A, B){\n\t    return A.solve(B);\n\t}\n\t\n\tfunction inv(A){\n\t    if(typeof A ===\"number\")\n\t        return 1/A;\n\t    return A.inverse();\n\t}\n\t\n\tmodule.exports = {\n\t    transpose:transpose,\n\t    add:add,\n\t    subtract:subtract,\n\t    multiply:multiply,\n\t    dotMultiply:dotMultiply,\n\t    dotDivide:dotDivide,\n\t    diag:diag,\n\t    min:min,\n\t    max:max,\n\t    solve:solve,\n\t    inv:inv,\n\t    sqrt:sqrt,\n\t    exp:exp,\n\t    dotPow:dotPow,\n\t    abs:abs,\n\t    matrix:matrix,\n\t    ones:ones,\n\t    zeros:zeros,\n\t    random:random,\n\t    eye:eye\n\t};\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(28);\n\tmodule.exports.Decompositions = module.exports.DC = __webpack_require__(29);\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar Asplice = Array.prototype.splice,\n\t    Aconcat = Array.prototype.concat;\n\t\n\t// For performance : http://jsperf.com/clone-array-slice-vs-while-vs-for\n\tfunction slice(arr) {\n\t    var i = 0,\n\t        ii = arr.length,\n\t        result = new Array(ii);\n\t    for (; i < ii; i++) {\n\t        result[i] = arr[i];\n\t    }\n\t    return result;\n\t}\n\t\n\t/**\n\t * Real matrix.\n\t * @constructor\n\t * @param {number|Array} nRows - Number of rows of the new matrix or a 2D array containing the data.\n\t * @param {number|boolean} [nColumns] - Number of columns of the new matrix or a boolean specifying if the input array should be cloned\n\t */\n\tfunction Matrix(nRows, nColumns) {\n\t    var i = 0, rows, columns, matrix, newInstance;\n\t    if (Array.isArray(nRows)) {\n\t        newInstance = nColumns;\n\t        matrix = newInstance ? slice(nRows) : nRows;\n\t        nRows = matrix.length;\n\t        nColumns = matrix[0].length;\n\t        if (typeof nColumns === 'undefined') {\n\t            throw new TypeError('Data must be a 2D array');\n\t        }\n\t        if (nRows > 0 && nColumns > 0) {\n\t            for (; i < nRows; i++) {\n\t                if (matrix[i].length !== nColumns) {\n\t                    throw new RangeError('Inconsistent array dimensions');\n\t                } else if (newInstance) {\n\t                    matrix[i] = slice(matrix[i]);\n\t                }\n\t            }\n\t        } else {\n\t            throw new RangeError('Invalid dimensions: ' + nRows + 'x' + nColumns);\n\t        }\n\t    } else if (typeof nRows === 'number') { // Create empty matrix\n\t        if (nRows > 0 && nColumns > 0) {\n\t            matrix = new Array(nRows);\n\t            for (; i < nRows; i++) {\n\t                matrix[i] = new Array(nColumns);\n\t            }\n\t        } else {\n\t            throw new RangeError('Invalid dimensions: ' + nRows + 'x' + nColumns);\n\t        }\n\t    } else {\n\t        throw new TypeError('Invalid arguments');\n\t    }\n\t\n\t    Object.defineProperty(matrix, 'rows', {writable: true, value: nRows});\n\t    Object.defineProperty(matrix, 'columns', {writable: true, value: nColumns});\n\t\n\t    matrix.__proto__ = Matrix.prototype;\n\t\n\t    return matrix;\n\t}\n\t\n\t/**\n\t * Constructs a Matrix with the chosen dimensions from a 1D array.\n\t * @param {number} newRows - Number of rows\n\t * @param {number} newColumns - Number of columns\n\t * @param {Array} newData - A 1D array containing data for the matrix\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.from1DArray = function from1DArray(newRows, newColumns, newData) {\n\t    var length, data, i = 0;\n\t\n\t    length = newRows * newColumns;\n\t    if (length !== newData.length)\n\t        throw new RangeError('Data length does not match given dimensions');\n\t\n\t    data = new Array(newRows);\n\t    for (; i < newRows; i++) {\n\t        data[i] = newData.slice(i * newColumns, (i + 1) * newColumns);\n\t    }\n\t    return new Matrix(data);\n\t};\n\t\n\t/**\n\t * Creates a row vector, a matrix with only one row.\n\t * @param {Array} newData - A 1D array containing data for the vector\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.rowVector = function rowVector(newData) {\n\t    return new Matrix([newData]);\n\t};\n\t\n\t/**\n\t * Creates a column vector, a matrix with only one column.\n\t * @param {Array} newData - A 1D array containing data for the vector\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.columnVector = function columnVector(newData) {\n\t    var l = newData.length, vector = new Array(l);\n\t    for (var i = 0; i < l; i++)\n\t        vector[i] = [newData[i]];\n\t    return new Matrix(vector);\n\t};\n\t\n\t/**\n\t * Creates an empty matrix with the given dimensions. Values will be undefined. Same as using new Matrix(rows, columns).\n\t * @param {number} rows - Number of rows\n\t * @param {number} columns - Number of columns\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.empty = function empty(rows, columns) {\n\t    return new Matrix(rows, columns);\n\t};\n\t\n\t/**\n\t * Creates a matrix with the given dimensions. Values will be set to zero.\n\t * @param {number} rows - Number of rows\n\t * @param {number} columns - Number of columns\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.zeros = function zeros(rows, columns) {\n\t    return Matrix.empty(rows, columns).fill(0);\n\t};\n\t\n\t/**\n\t * Creates a matrix with the given dimensions. Values will be set to one.\n\t * @param {number} rows - Number of rows\n\t * @param {number} columns - Number of columns\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.ones = function ones(rows, columns) {\n\t    return Matrix.empty(rows, columns).fill(1);\n\t};\n\t\n\t/**\n\t * Creates a matrix with the given dimensions. Values will be randomly set using Math.random().\n\t * @param {number} rows - Number of rows\n\t * @param {number} columns - Number of columns\n\t * @returns {Matrix} The new matrix\n\t */\n\tMatrix.rand = function rand(rows, columns) {\n\t    var matrix = Matrix.empty(rows, columns);\n\t    for (var i = 0, ii = matrix.rows; i < ii; i++) {\n\t        for (var j = 0, jj = matrix.columns; j < jj; j++) {\n\t            matrix[i][j] = Math.random();\n\t        }\n\t    }\n\t    return matrix;\n\t};\n\t\n\t/**\n\t * Creates an identity matrix with the given dimension. Values of the diagonal will be 1 and other will be 0.\n\t * @param {number} n - Number of rows and columns\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.eye = function eye(n) {\n\t    var matrix = Matrix.zeros(n, n), l = matrix.rows;\n\t    for (var i = 0; i < l; i++) {\n\t        matrix[i][i] = 1;\n\t    }\n\t    return matrix;\n\t};\n\t\n\t/**\n\t * Creates a diagonal matrix based on the given array.\n\t * @param {Array} data - Array containing the data for the diagonal\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.diag = function diag(data) {\n\t    var l = data.length, matrix = Matrix.zeros(l, l);\n\t    for (var i = 0; i < l; i++) {\n\t        matrix[i][i] = data[i];\n\t    }\n\t    return matrix;\n\t};\n\t\n\t/**\n\t * Creates an array of indices between two values\n\t * @param {number} from\n\t * @param {number} to\n\t * @returns {Array}\n\t */\n\tMatrix.indices = function indices(from, to) {\n\t    var vector = new Array(to - from);\n\t    for (var i = 0; i < vector.length; i++)\n\t        vector[i] = from++;\n\t    return vector;\n\t};\n\t\n\t// TODO DOC\n\tMatrix.stack = function stack(arg1) {\n\t    var i, j, k;\n\t    if (Matrix.isMatrix(arg1)) {\n\t        var rows = 0,\n\t            cols = 0;\n\t        for (i = 0; i < arguments.length; i++) {\n\t            rows += arguments[i].rows;\n\t            if (arguments[i].columns > cols)\n\t                cols = arguments[i].columns;\n\t        }\n\t\n\t        var r = Matrix.zeros(rows, cols);\n\t        var c = 0;\n\t        for (i = 0; i < arguments.length; i++) {\n\t            var current = arguments[i];\n\t            for (j = 0; j < current.rows; j++) {\n\t                for (k = 0; k < current.columns; k++)\n\t                    r[c][k] = current[j][k];\n\t                c++;\n\t            }\n\t        }\n\t        return r;\n\t    }\n\t    else if (Array.isArray(arg1)) {\n\t        var matrix = Matrix.empty(arguments.length, arg1.length);\n\t        for (i = 0; i < arguments.length; i++)\n\t            matrix.setRow(i, arguments[i]);\n\t        return matrix;\n\t    }\n\t};\n\t\n\t// TODO DOC\n\tMatrix.expand = function expand(base, count) {\n\t    var expansion = [];\n\t    for (var i = 0; i < count.length; i++)\n\t        for (var j = 0; j < count[i]; j++)\n\t            expansion.push(base[i]);\n\t    return new Matrix(expansion);\n\t};\n\t\n\t/**\n\t * Check that the provided value is a Matrix and tries to instantiate one if not\n\t * @param value - The value to check\n\t * @returns {Matrix}\n\t * @throws {TypeError}\n\t */\n\tMatrix.checkMatrix = function checkMatrix(value) {\n\t    if (!value) {\n\t        throw new TypeError('Argument has to be a matrix');\n\t    }\n\t    if (value.klass !== 'Matrix') {\n\t        value = new Matrix(value);\n\t    }\n\t    return value;\n\t};\n\t\n\t/**\n\t * Returns true if the argument is a Matrix, false otherwise\n\t * @param value - The value to check\n\t * @returns {boolean}\n\t */\n\tMatrix.isMatrix = function isMatrix(value) {\n\t    return value ? value.klass === 'Matrix' : false;\n\t};\n\t\n\t/**\n\t * @property {string} - The name of this class.\n\t */\n\tObject.defineProperty(Matrix.prototype, 'klass', {\n\t    get: function klass() {\n\t        return 'Matrix';\n\t    }\n\t});\n\t\n\t/**\n\t * @property {number} - The number of elements in the matrix.\n\t */\n\tObject.defineProperty(Matrix.prototype, 'size', {\n\t    get: function size() {\n\t        return this.rows * this.columns;\n\t    }\n\t});\n\t\n\t/**\n\t * @private\n\t * Internal check that a row index is not out of bounds\n\t * @param {number} index\n\t */\n\tMatrix.prototype.checkRowIndex = function checkRowIndex(index) {\n\t    if (index < 0 || index > this.rows - 1)\n\t        throw new RangeError('Row index out of range.');\n\t};\n\t\n\t/**\n\t * @private\n\t * Internal check that a column index is not out of bounds\n\t * @param {number} index\n\t */\n\tMatrix.prototype.checkColumnIndex = function checkColumnIndex(index) {\n\t    if (index < 0 || index > this.columns - 1)\n\t        throw new RangeError('Column index out of range.');\n\t};\n\t\n\t/**\n\t * @private\n\t * Internal check that two matrices have the same dimensions\n\t * @param {Matrix} otherMatrix\n\t */\n\tMatrix.prototype.checkDimensions = function checkDimensions(otherMatrix) {\n\t    if ((this.rows !== otherMatrix.rows) || (this.columns !== otherMatrix.columns))\n\t        throw new RangeError('Matrices dimensions must be equal.');\n\t};\n\t\n\t/**\n\t * Applies a callback for each element of the matrix. The function is called in the matrix (this) context.\n\t * @param {function} callback - Function that will be called with two parameters : i (row) and j (column)\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.apply = function apply(callback) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            callback.call(this, i, j);\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Creates an exact and independent copy of the matrix\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.clone = function clone() {\n\t    return new Matrix(this.to2DArray());\n\t};\n\t\n\t/**\n\t * Returns a new 1D array filled row by row with the matrix values\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.to1DArray = function to1DArray() {\n\t    return Aconcat.apply([], this);\n\t};\n\t\n\t/**\n\t * Returns a 2D array containing a copy of the data\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.to2DArray = function to2DArray() {\n\t    var l = this.rows, copy = new Array(l);\n\t    for (var i = 0; i < l; i++) {\n\t        copy[i] = slice(this[i]);\n\t    }\n\t    return copy;\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix has one row\n\t */\n\tMatrix.prototype.isRowVector = function isRowVector() {\n\t    return this.rows === 1;\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix has one column\n\t */\n\tMatrix.prototype.isColumnVector = function isColumnVector() {\n\t    return this.columns === 1;\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix has one row or one column\n\t */\n\tMatrix.prototype.isVector = function isVector() {\n\t    return (this.rows === 1) || (this.columns === 1);\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix has the same number of rows and columns\n\t */\n\tMatrix.prototype.isSquare = function isSquare() {\n\t    return this.rows === this.columns;\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix is square and has the same values on both sides of the diagonal\n\t */\n\tMatrix.prototype.isSymmetric = function isSymmetric() {\n\t    if (this.isSquare()) {\n\t        var l = this.rows;\n\t        for (var i = 0; i < l; i++) {\n\t            for (var j = 0; j <= i; j++) {\n\t                if (this[i][j] !== this[j][i]) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    return false;\n\t};\n\t\n\t/**\n\t * Sets a given element of the matrix. mat.set(3,4,1) is equivalent to mat[3][4]=1\n\t * @param {number} rowIndex - Index of the row\n\t * @param {number} columnIndex - Index of the column\n\t * @param {number} value - The new value for the element\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.set = function set(rowIndex, columnIndex, value) {\n\t    this[rowIndex][columnIndex] = value;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Returns the given element of the matrix. mat.get(3,4) is equivalent to matrix[3][4]\n\t * @param {number} rowIndex - Index of the row\n\t * @param {number} columnIndex - Index of the column\n\t * @returns {number}\n\t */\n\tMatrix.prototype.get = function get(rowIndex, columnIndex) {\n\t    return this[rowIndex][columnIndex];\n\t};\n\t\n\t/**\n\t * Fills the matrix with a given value. All elements will be set to this value.\n\t * @param {number} value - New value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.fill = function fill(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] = value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Negates the matrix. All elements will be multiplied by (-1)\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.neg = function neg() {\n\t    return this.mulS(-1);\n\t};\n\t\n\t/**\n\t * Adds a scalar or values from another matrix (in place)\n\t * @param {number|Matrix} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.add = function add(value) {\n\t    if (typeof value === 'number')\n\t        return this.addS(value);\n\t    value = Matrix.checkMatrix(value);\n\t        return this.addM(value);\n\t};\n\t\n\t/**\n\t * Adds a scalar to each element of the matrix\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addS = function addS(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] += value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Adds the value of each element of matrix to the corresponding element of this\n\t * @param {Matrix} matrix\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addM = function addM(matrix) {\n\t    this.checkDimensions(matrix);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] += matrix[i][j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Subtracts a scalar or values from another matrix (in place)\n\t * @param {number|Matrix} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.sub = function sub(value) {\n\t    if (typeof value === 'number')\n\t        return this.subS(value);\n\t    value = Matrix.checkMatrix(value);\n\t        return this.subM(value);\n\t};\n\t\n\t/**\n\t * Subtracts a scalar from each element of the matrix\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.subS = function subS(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] -= value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Subtracts the value of each element of matrix from the corresponding element of this\n\t * @param {Matrix} matrix\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.subM = function subM(matrix) {\n\t    this.checkDimensions(matrix);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] -= matrix[i][j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies a scalar or values from another matrix (in place)\n\t * @param {number|Matrix} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mul = function mul(value) {\n\t    if (typeof value === 'number')\n\t        return this.mulS(value);\n\t    value = Matrix.checkMatrix(value);\n\t        return this.mulM(value);\n\t};\n\t\n\t/**\n\t * Multiplies a scalar with each element of the matrix\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulS = function mulS(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] *= value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the value of each element of matrix with the corresponding element of this\n\t * @param {Matrix} matrix\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulM = function mulM(matrix) {\n\t    this.checkDimensions(matrix);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] *= matrix[i][j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Divides by a scalar or values from another matrix (in place)\n\t * @param {number|Matrix} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.div = function div(value) {\n\t    if (typeof value === 'number')\n\t        return this.divS(value);\n\t    value = Matrix.checkMatrix(value);\n\t        return this.divM(value);\n\t};\n\t\n\t/**\n\t * Divides each element of the matrix by a scalar\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.divS = function divS(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] /= value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Divides each element of this by the corresponding element of matrix\n\t * @param {Matrix} matrix\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.divM = function divM(matrix) {\n\t    this.checkDimensions(matrix);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] /= matrix[i][j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Returns a new array from the given row index\n\t * @param {number} index - Row index\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.getRow = function getRow(index) {\n\t    this.checkRowIndex(index);\n\t    return slice(this[index]);\n\t};\n\t\n\t/**\n\t * Returns a new row vector from the given row index\n\t * @param {number} index - Row index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.getRowVector = function getRowVector(index) {\n\t    return Matrix.rowVector(this.getRow(index));\n\t};\n\t\n\t/**\n\t * Sets a row at the given index\n\t * @param {number} index - Row index\n\t * @param {Array|Matrix} array - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.setRow = function setRow(index, array) {\n\t    this.checkRowIndex(index);\n\t    if (Matrix.isMatrix(array)) array = array.to1DArray();\n\t    if (array.length !== this.columns)\n\t        throw new RangeError('Invalid row size');\n\t    this[index] = slice(array);\n\t    return this;\n\t};\n\t\n\t/**\n\t * Removes a row from the given index\n\t * @param {number} index - Row index\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.removeRow = function removeRow(index) {\n\t    this.checkRowIndex(index);\n\t    if (this.rows === 1)\n\t        throw new RangeError('A matrix cannot have less than one row');\n\t    Asplice.call(this, index, 1);\n\t    this.rows -= 1;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Adds a row at the given index\n\t * @param {number} [index = this.rows] - Row index\n\t * @param {Array|Matrix} array - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addRow = function addRow(index, array) {\n\t    if (typeof array === 'undefined') {\n\t        array = index;\n\t        index = this.rows;\n\t    }\n\t    if (index < 0 || index > this.rows)\n\t        throw new RangeError('Row index out of range.');\n\t    if (Matrix.isMatrix(array)) array = array.to1DArray();\n\t    if (array.length !== this.columns)\n\t        throw new RangeError('Invalid row size');\n\t    Asplice.call(this, index, 0, slice(array));\n\t    this.rows += 1;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Swaps two rows\n\t * @param {number} row1 - First row index\n\t * @param {number} row2 - Second row index\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.swapRows = function swapRows(row1, row2) {\n\t    this.checkRowIndex(row1);\n\t    this.checkRowIndex(row2);\n\t    var temp = this[row1];\n\t    this[row1] = this[row2];\n\t    this[row2] = temp;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Returns a new array from the given column index\n\t * @param {number} index - Column index\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.getColumn = function getColumn(index) {\n\t    this.checkColumnIndex(index);\n\t    var l = this.rows, column = new Array(l);\n\t    for (var i = 0; i < l; i++) {\n\t        column[i] = this[i][index];\n\t    }\n\t    return column;\n\t};\n\t\n\t/**\n\t * Returns a new column vector from the given column index\n\t * @param {number} index - Column index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.getColumnVector = function getColumnVector(index) {\n\t    return Matrix.columnVector(this.getColumn(index));\n\t};\n\t\n\t/**\n\t * Sets a column at the given index\n\t * @param {number} index - Column index\n\t * @param {Array|Matrix} array - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.setColumn = function setColumn(index, array) {\n\t    this.checkColumnIndex(index);\n\t    if (Matrix.isMatrix(array)) array = array.to1DArray();\n\t    var l = this.rows;\n\t    if (array.length !== l)\n\t        throw new RangeError('Invalid column size');\n\t    for (var i = 0; i < l; i++) {\n\t        this[i][index] = array[i];\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Removes a column from the given index\n\t * @param {number} index - Column index\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.removeColumn = function removeColumn(index) {\n\t    this.checkColumnIndex(index);\n\t    if (this.columns === 1)\n\t        throw new RangeError('A matrix cannot have less than one column');\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        this[i].splice(index, 1);\n\t    }\n\t    this.columns -= 1;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Adds a column at the given index\n\t * @param {number} [index = this.columns] - Column index\n\t * @param {Array|Matrix} array - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addColumn = function addColumn(index, array) {\n\t    if (typeof array === 'undefined') {\n\t        array = index;\n\t        index = this.columns;\n\t    }\n\t    if (index < 0 || index > this.columns)\n\t        throw new RangeError('Column index out of range.');\n\t    if (Matrix.isMatrix(array)) array = array.to1DArray();\n\t    var l = this.rows;\n\t    if (array.length !== l)\n\t        throw new RangeError('Invalid column size');\n\t    for (var i = 0; i < l; i++) {\n\t        this[i].splice(index, 0, array[i]);\n\t    }\n\t    this.columns += 1;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Swaps two columns\n\t * @param {number} column1 - First column index\n\t * @param {number} column2 - Second column index\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.swapColumns = function swapColumns(column1, column2) {\n\t    this.checkRowIndex(column1);\n\t    this.checkRowIndex(column2);\n\t    var l = this.rows, temp, row;\n\t    for (var i = 0; i < l; i++) {\n\t        row = this[i];\n\t        temp = row[column1];\n\t        row[column1] = row[column2];\n\t        row[column2] = temp;\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * @private\n\t * Internal check that the provided vector is an array with the right length\n\t * @param {Array|Matrix} vector\n\t * @returns {Array}\n\t * @throws {RangeError}\n\t */\n\tMatrix.prototype.checkRowVector = function checkRowVector(vector) {\n\t    if (Matrix.isMatrix(vector))\n\t        vector = vector.to1DArray();\n\t    if (vector.length !== this.columns)\n\t        throw new RangeError('vector size must be the same as the number of columns');\n\t    return vector;\n\t};\n\t\n\t/**\n\t * @private\n\t * Internal check that the provided vector is an array with the right length\n\t * @param {Array|Matrix} vector\n\t * @returns {Array}\n\t * @throws {RangeError}\n\t */\n\tMatrix.prototype.checkColumnVector = function checkColumnVector(vector) {\n\t    if (Matrix.isMatrix(vector))\n\t        vector = vector.to1DArray();\n\t    if (vector.length !== this.rows)\n\t        throw new RangeError('vector size must be the same as the number of rows');\n\t    return vector;\n\t};\n\t\n\t/**\n\t * Adds the values of a vector to each row\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addRowVector = function addRowVector(vector) {\n\t    vector = this.checkRowVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] += vector[j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Subtracts the values of a vector from each row\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.subRowVector = function subRowVector(vector) {\n\t    vector = this.checkRowVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] -= vector[j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the values of a vector with each row\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulRowVector = function mulRowVector(vector) {\n\t    vector = this.checkRowVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] *= vector[j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Divides the values of each row by those of a vector\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.divRowVector = function divRowVector(vector) {\n\t    vector = this.checkRowVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] /= vector[j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Adds the values of a vector to each column\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addColumnVector = function addColumnVector(vector) {\n\t    vector = this.checkColumnVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] += vector[i];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Subtracts the values of a vector from each column\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.subColumnVector = function subColumnVector(vector) {\n\t    vector = this.checkColumnVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] -= vector[i];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the values of a vector with each column\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulColumnVector = function mulColumnVector(vector) {\n\t    vector = this.checkColumnVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] *= vector[i];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Divides the values of each column by those of a vector\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.divColumnVector = function divColumnVector(vector) {\n\t    vector = this.checkColumnVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] /= vector[i];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the values of a row with a scalar\n\t * @param {number} index - Row index\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulRow = function mulRow(index, value) {\n\t    this.checkRowIndex(index);\n\t    var i = 0, l = this.columns;\n\t    for (; i < l; i++) {\n\t        this[index][i] *= value;\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the values of a column with a scalar\n\t * @param {number} index - Column index\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulColumn = function mulColumn(index, value) {\n\t    this.checkColumnIndex(index);\n\t    var i = 0, l = this.rows;\n\t    for (; i < l; i++) {\n\t        this[i][index] *= value;\n\t    }\n\t};\n\t\n\t/**\n\t * A matrix index\n\t * @typedef {Object} MatrixIndex\n\t * @property {number} row\n\t * @property {number} column\n\t */\n\t\n\t/**\n\t * Returns the maximum value of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.max = function max() {\n\t    var v = -Infinity;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (this[i][j] > v) {\n\t                v = this[i][j];\n\t            }\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the maximum value\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.maxIndex = function maxIndex() {\n\t    var v = -Infinity;\n\t    var idx = {};\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (this[i][j] > v) {\n\t                v = this[i][j];\n\t                idx.row = i;\n\t                idx.column = j;\n\t            }\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the minimum value of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.min = function min() {\n\t    var v = Infinity;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (this[i][j] < v) {\n\t                v = this[i][j];\n\t            }\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the minimum value\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.minIndex = function minIndex() {\n\t    var v = Infinity;\n\t    var idx = {};\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (this[i][j] < v) {\n\t                v = this[i][j];\n\t                idx.row = i;\n\t                idx.column = j;\n\t            }\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the maximum value of one row\n\t * @param {number} index - Row index\n\t * @returns {number}\n\t */\n\tMatrix.prototype.maxRow = function maxRow(index) {\n\t    this.checkRowIndex(index);\n\t    var v = -Infinity;\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        if (this[index][i] > v) {\n\t            v = this[index][i];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the maximum value of one row\n\t * @param {number} index - Row index\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.maxRowIndex = function maxRowIndex(index) {\n\t    this.checkRowIndex(index);\n\t    var v = -Infinity;\n\t    var idx = {\n\t            row: index\n\t        };\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        if (this[index][i] > v) {\n\t            v = this[index][i];\n\t            idx.column = i;\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the minimum value of one row\n\t * @param {number} index - Row index\n\t * @returns {number}\n\t */\n\tMatrix.prototype.minRow = function minRow(index) {\n\t    this.checkRowIndex(index);\n\t    var v = Infinity;\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        if (this[index][i] < v) {\n\t            v = this[index][i];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the maximum value of one row\n\t * @param {number} index - Row index\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.minRowIndex = function minRowIndex(index) {\n\t    this.checkRowIndex(index);\n\t    var v = Infinity;\n\t    var idx = {\n\t        row: index,\n\t        column: 0\n\t    };\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        if (this[index][i] < v) {\n\t            v = this[index][i];\n\t            idx.column = i;\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the maximum value of one column\n\t * @param {number} index - Column index\n\t * @returns {number}\n\t */\n\tMatrix.prototype.maxColumn = function maxColumn(index) {\n\t    this.checkColumnIndex(index);\n\t    var v = -Infinity;\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        if (this[i][index] > v) {\n\t            v = this[i][index];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the maximum value of one column\n\t * @param {number} index - Column index\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.maxColumnIndex = function maxColumnIndex(index) {\n\t    this.checkColumnIndex(index);\n\t    var v = -Infinity;\n\t    var idx = {\n\t        row: 0,\n\t        column: index\n\t    };\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        if (this[i][index] > v) {\n\t            v = this[i][index];\n\t            idx.row = i;\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the minimum value of one column\n\t * @param {number} index - Column index\n\t * @returns {number}\n\t */\n\tMatrix.prototype.minColumn = function minColumn(index) {\n\t    this.checkColumnIndex(index);\n\t    var v = Infinity;\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        if (this[i][index] < v) {\n\t            v = this[i][index];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the minimum value of one column\n\t * @param {number} index - Column index\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.minColumnIndex = function minColumnIndex(index) {\n\t    this.checkColumnIndex(index);\n\t    var v = Infinity;\n\t    var idx = {\n\t        row: 0,\n\t        column: index\n\t    };\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        if (this[i][index] < v) {\n\t            v = this[i][index];\n\t            idx.row = i;\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns an array containing the diagonal values of the matrix\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.diag = function diag() {\n\t    if (!this.isSquare())\n\t        throw new TypeError('Only square matrices have a diagonal.');\n\t    var diag = new Array(this.rows);\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        diag[i] = this[i][i];\n\t    }\n\t    return diag;\n\t};\n\t\n\t/**\n\t * Returns the sum of all elements of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.sum = function sum() {\n\t    var v = 0;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            v += this[i][j];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the mean of all elements of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.mean = function mean() {\n\t    return this.sum() / this.size;\n\t};\n\t\n\t/**\n\t * Returns the product of all elements of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.prod = function prod() {\n\t    var prod = 1;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            prod *= this[i][j];\n\t        }\n\t    }\n\t    return prod;\n\t};\n\t\n\t/**\n\t * Computes the cumulative sum of the matrix elements (in place, row by row)\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.cumulativeSum = function cumulativeSum() {\n\t    var sum = 0;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            sum += this[i][j];\n\t            this[i][j] = sum;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Computes the dot (scalar) product between the matrix and another\n\t * @param {Matrix} other vector\n\t * @returns {number}\n\t */\n\tMatrix.prototype.dot = function dot(other) {\n\t    if (this.size !== other.size)\n\t        throw new RangeError('vectors do not have the same size');\n\t    var vector1 = this.to1DArray();\n\t    var vector2 = other.to1DArray();\n\t    var dot = 0, l = vector1.length;\n\t    for (var i = 0; i < l; i++) {\n\t        dot += vector1[i] * vector2[i];\n\t    }\n\t    return dot;\n\t};\n\t\n\t/**\n\t * Returns the matrix product between this and other\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.mmul = function mmul(other) {\n\t    if (!Matrix.isMatrix(other))\n\t        throw new TypeError('parameter \"other\" must be a matrix');\n\t    if (this.columns !== other.rows)\n\t        console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');\n\t\n\t    var m = this.rows, n = this.columns, p = other.columns;\n\t    var result = new Matrix(m, p);\n\t\n\t    var Bcolj = new Array(n);\n\t    var i, j, k;\n\t    for (j = 0; j < p; j++) {\n\t        for (k = 0; k < n; k++)\n\t            Bcolj[k] = other[k][j];\n\t\n\t        for (i = 0; i < m; i++) {\n\t            var Arowi = this[i];\n\t\n\t            var s = 0;\n\t            for (k = 0; k < n; k++)\n\t                s += Arowi[k] * Bcolj[k];\n\t\n\t            result[i][j] = s;\n\t        }\n\t    }\n\t    return result;\n\t};\n\t\n\t/**\n\t * Sorts the rows (in place)\n\t * @param {function} compareFunction - usual Array.prototype.sort comparison function\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.sortRows = function sortRows(compareFunction) {\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        this[i].sort(compareFunction);\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Sorts the columns (in place)\n\t * @param {function} compareFunction - usual Array.prototype.sort comparison function\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.sortColumns = function sortColumns(compareFunction) {\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        this.setColumn(i, this.getColumn(i).sort(compareFunction));\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Transposes the matrix and returns a new one containing the result\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.transpose = function transpose() {\n\t    var result = new Matrix(this.columns, this.rows);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            result[j][i] = this[i][j];\n\t        }\n\t    }\n\t    return result;\n\t};\n\t\n\t/**\n\t * Returns a subset of the matrix\n\t * @param {number} startRow - First row index\n\t * @param {number} endRow - Last row index\n\t * @param {number} startColumn - First column index\n\t * @param {number} endColumn - Last column index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.subMatrix = function subMatrix(startRow, endRow, startColumn, endColumn) {\n\t    if ((startRow > endRow) || (startColumn > endColumn) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns))\n\t        throw new RangeError('Argument out of range');\n\t    var newMatrix = new Matrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\t    for (var i = startRow; i <= endRow; i++) {\n\t        for (var j = startColumn; j <= endColumn; j++) {\n\t            newMatrix[i - startRow][j - startColumn] = this[i][j];\n\t        }\n\t    }\n\t    return newMatrix;\n\t};\n\t\n\t/**\n\t * Returns a subset of the matrix based on an array of row indices\n\t * @param {Array} indices - Array containing the row indices\n\t * @param {number} [startColumn = 0] - First column index\n\t * @param {number} [endColumn = this.columns-1] - Last column index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.subMatrixRow = function subMatrixRow(indices, startColumn, endColumn) {\n\t    if (typeof startColumn === 'undefined') {\n\t        startColumn = 0;\n\t        endColumn = this.columns - 1;\n\t    } else if (typeof endColumn === 'undefined') {\n\t        endColumn = this.columns - 1;\n\t    }\n\t    if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns))\n\t        throw new RangeError('Argument out of range.');\n\t    var l = indices.length, rows = this.rows,\n\t        X = new Matrix(l, endColumn - startColumn + 1);\n\t    for (var i = 0; i < l; i++) {\n\t        for (var j = startColumn; j <= endColumn; j++) {\n\t            if ((indices[i] < 0) || (indices[i] >= rows))\n\t                throw new RangeError('Argument out of range.');\n\t            X[i][j - startColumn] = this[indices[i]][j];\n\t        }\n\t    }\n\t    return X;\n\t};\n\t\n\t/**\n\t * Returns a subset of the matrix based on an array of column indices\n\t * @param {Array} indices - Array containing the column indices\n\t * @param {number} [startRow = 0] - First row index\n\t * @param {number} [endRow = this.rows-1] - Last row index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.subMatrixColumn = function subMatrixColumn(indices, startRow, endRow) {\n\t    if (typeof startRow === 'undefined') {\n\t        startRow = 0;\n\t        endRow = this.rows - 1;\n\t    } else if (typeof endRow === 'undefined') {\n\t        endRow = this.rows - 1;\n\t    }\n\t    if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows))\n\t        throw new RangeError('Argument out of range.');\n\t    var l = indices.length, columns = this.columns,\n\t        X = new Matrix(endRow - startRow + 1, l);\n\t    for (var i = 0; i < l; i++) {\n\t        for (var j = startRow; j <= endRow; j++) {\n\t            if ((indices[i] < 0) || (indices[i] >= columns))\n\t                throw new RangeError('Argument out of range.');\n\t            X[j - startRow][i] = this[j][indices[i]];\n\t        }\n\t    }\n\t    return X;\n\t};\n\t\n\t/**\n\t * Returns the trace of the matrix (sum of the diagonal elements)\n\t * @returns {number}\n\t */\n\tMatrix.prototype.trace = function trace() {\n\t    if (!this.isSquare())\n\t        throw new TypeError('The matrix is not square');\n\t    var trace = 0, i = 0, l = this.rows;\n\t    for (; i < l; i++) {\n\t        trace += this[i][i];\n\t    }\n\t    return trace;\n\t};\n\t\n\t/**\n\t * Sets each element of the matrix to its absolute value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.abs = function abs() {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] = Math.abs(this[i][j]);\n\t        }\n\t    }\n\t};\n\t\n\tmodule.exports = Matrix;\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(28);\n\t\n\tvar SingularValueDecomposition = __webpack_require__(30);\n\tvar EigenvalueDecomposition = __webpack_require__(32);\n\tvar LuDecomposition = __webpack_require__(33);\n\tvar QrDecomposition = __webpack_require__(34);\n\tvar CholeskyDecomposition = __webpack_require__(35);\n\t\n\tfunction inverse(matrix) {\n\t    return solve(matrix, Matrix.eye(matrix.rows));\n\t}\n\t\n\tMatrix.prototype.inverse = function () {\n\t    return inverse(this);\n\t};\n\t\n\tfunction solve(leftHandSide, rightHandSide) {\n\t    return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).solve(rightHandSide);\n\t}\n\t\n\tMatrix.prototype.solve = function (other) {\n\t    return solve(this, other);\n\t};\n\t\n\tmodule.exports = {\n\t    SingularValueDecomposition: SingularValueDecomposition,\n\t    SVD: SingularValueDecomposition,\n\t    EigenvalueDecomposition: EigenvalueDecomposition,\n\t    EVD: EigenvalueDecomposition,\n\t    LuDecomposition: LuDecomposition,\n\t    LU: LuDecomposition,\n\t    QrDecomposition: QrDecomposition,\n\t    QR: QrDecomposition,\n\t    CholeskyDecomposition: CholeskyDecomposition,\n\t    CHO: CholeskyDecomposition,\n\t    inverse: inverse,\n\t    solve: solve\n\t};\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(28);\n\tvar hypotenuse = __webpack_require__(31).hypotenuse;\n\t\n\t// https://github.com/lutzroeder/Mapack/blob/master/Source/SingularValueDecomposition.cs\n\tfunction SingularValueDecomposition(value, options) {\n\t    if (!(this instanceof SingularValueDecomposition)) {\n\t        return new SingularValueDecomposition(value, options);\n\t    }\n\t    value = Matrix.checkMatrix(value);\n\t\n\t    options = options || {};\n\t\n\t    var a = value.clone(),\n\t        m = value.rows,\n\t        n = value.columns,\n\t        nu = Math.min(m, n);\n\t\n\t    var wantu = true, wantv = true;\n\t    if (options.computeLeftSingularVectors === false)\n\t        wantu = false;\n\t    if (options.computeRightSingularVectors === false)\n\t        wantv = false;\n\t    var autoTranspose = options.autoTranspose === true;\n\t\n\t    var swapped = false;\n\t    if (m < n) {\n\t        if (!autoTranspose) {\n\t            console.warn('Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose');\n\t        } else {\n\t            a = a.transpose();\n\t            m = a.rows;\n\t            n = a.columns;\n\t            swapped = true;\n\t            var aux = wantu;\n\t            wantu = wantv;\n\t            wantv = aux;\n\t        }\n\t    }\n\t\n\t    var s = new Array(Math.min(m + 1, n)),\n\t        U = Matrix.zeros(m, nu),\n\t        V = Matrix.zeros(n, n),\n\t        e = new Array(n),\n\t        work = new Array(m);\n\t\n\t    var nct = Math.min(m - 1, n);\n\t    var nrt = Math.max(0, Math.min(n - 2, m));\n\t\n\t    var i, j, k, p, t, ks, f, cs, sn, max, kase,\n\t        scale, sp, spm1, epm1, sk, ek, b, c, shift, g;\n\t\n\t    for (k = 0, max = Math.max(nct, nrt); k < max; k++) {\n\t        if (k < nct) {\n\t            s[k] = 0;\n\t            for (i = k; i < m; i++) {\n\t                s[k] = hypotenuse(s[k], a[i][k]);\n\t            }\n\t            if (s[k] !== 0) {\n\t                if (a[k][k] < 0) {\n\t                    s[k] = -s[k];\n\t                }\n\t                for (i = k; i < m; i++) {\n\t                    a[i][k] /= s[k];\n\t                }\n\t                a[k][k] += 1;\n\t            }\n\t            s[k] = -s[k];\n\t        }\n\t\n\t        for (j = k + 1; j < n; j++) {\n\t            if ((k < nct) && (s[k] !== 0)) {\n\t                t = 0;\n\t                for (i = k; i < m; i++) {\n\t                    t += a[i][k] * a[i][j];\n\t                }\n\t                t = -t / a[k][k];\n\t                for (i = k; i < m; i++) {\n\t                    a[i][j] += t * a[i][k];\n\t                }\n\t            }\n\t            e[j] = a[k][j];\n\t        }\n\t\n\t        if (wantu && (k < nct)) {\n\t            for (i = k; i < m; i++) {\n\t                U[i][k] = a[i][k];\n\t            }\n\t        }\n\t\n\t        if (k < nrt) {\n\t            e[k] = 0;\n\t            for (i = k + 1; i < n; i++) {\n\t                e[k] = hypotenuse(e[k], e[i]);\n\t            }\n\t            if (e[k] !== 0) {\n\t                if (e[k + 1] < 0)\n\t                    e[k] = -e[k];\n\t                for (i = k + 1; i < n; i++) {\n\t                    e[i] /= e[k];\n\t                }\n\t                e[k + 1] += 1;\n\t            }\n\t            e[k] = -e[k];\n\t            if ((k + 1 < m) && (e[k] !== 0)) {\n\t                for (i = k + 1; i < m; i++) {\n\t                    work[i] = 0;\n\t                }\n\t                for (j = k + 1; j < n; j++) {\n\t                    for (i = k + 1; i < m; i++) {\n\t                        work[i] += e[j] * a[i][j];\n\t                    }\n\t                }\n\t                for (j = k + 1; j < n; j++) {\n\t                    t = -e[j] / e[k + 1];\n\t                    for (i = k + 1; i < m; i++) {\n\t                        a[i][j] += t * work[i];\n\t                    }\n\t                }\n\t            }\n\t            if (wantv) {\n\t                for (i = k + 1; i < n; i++) {\n\t                    V[i][k] = e[i];\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    p = Math.min(n, m + 1);\n\t    if (nct < n) {\n\t        s[nct] = a[nct][nct];\n\t    }\n\t    if (m < p) {\n\t        s[p - 1] = 0;\n\t    }\n\t    if (nrt + 1 < p) {\n\t        e[nrt] = a[nrt][p - 1];\n\t    }\n\t    e[p - 1] = 0;\n\t\n\t    if (wantu) {\n\t        for (j = nct; j < nu; j++) {\n\t            for (i = 0; i < m; i++) {\n\t                U[i][j] = 0;\n\t            }\n\t            U[j][j] = 1;\n\t        }\n\t        for (k = nct - 1; k >= 0; k--) {\n\t            if (s[k] !== 0) {\n\t                for (j = k + 1; j < nu; j++) {\n\t                    t = 0;\n\t                    for (i = k; i < m; i++) {\n\t                        t += U[i][k] * U[i][j];\n\t                    }\n\t                    t = -t / U[k][k];\n\t                    for (i = k; i < m; i++) {\n\t                        U[i][j] += t * U[i][k];\n\t                    }\n\t                }\n\t                for (i = k; i < m; i++) {\n\t                    U[i][k] = -U[i][k];\n\t                }\n\t                U[k][k] = 1 + U[k][k];\n\t                for (i = 0; i < k - 1; i++) {\n\t                    U[i][k] = 0;\n\t                }\n\t            } else {\n\t                for (i = 0; i < m; i++) {\n\t                    U[i][k] = 0;\n\t                }\n\t                U[k][k] = 1;\n\t            }\n\t        }\n\t    }\n\t\n\t    if (wantv) {\n\t        for (k = n - 1; k >= 0; k--) {\n\t            if ((k < nrt) && (e[k] !== 0)) {\n\t                for (j = k + 1; j < n; j++) {\n\t                    t = 0;\n\t                    for (i = k + 1; i < n; i++) {\n\t                        t += V[i][k] * V[i][j];\n\t                    }\n\t                    t = -t / V[k + 1][k];\n\t                    for (i = k + 1; i < n; i++) {\n\t                        V[i][j] += t * V[i][k];\n\t                    }\n\t                }\n\t            }\n\t            for (i = 0; i < n; i++) {\n\t                V[i][k] = 0;\n\t            }\n\t            V[k][k] = 1;\n\t        }\n\t    }\n\t\n\t    var pp = p - 1,\n\t        iter = 0,\n\t        eps = Math.pow(2, -52);\n\t    while (p > 0) {\n\t        for (k = p - 2; k >= -1; k--) {\n\t            if (k === -1) {\n\t                break;\n\t            }\n\t            if (Math.abs(e[k]) <= eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {\n\t                e[k] = 0;\n\t                break;\n\t            }\n\t        }\n\t        if (k === p - 2) {\n\t            kase = 4;\n\t        } else {\n\t            for (ks = p - 1; ks >= k; ks--) {\n\t                if (ks === k) {\n\t                    break;\n\t                }\n\t                t = (ks !== p ? Math.abs(e[ks]) : 0) + (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);\n\t                if (Math.abs(s[ks]) <= eps * t) {\n\t                    s[ks] = 0;\n\t                    break;\n\t                }\n\t            }\n\t            if (ks === k) {\n\t                kase = 3;\n\t            } else if (ks === p - 1) {\n\t                kase = 1;\n\t            } else {\n\t                kase = 2;\n\t                k = ks;\n\t            }\n\t        }\n\t\n\t        k++;\n\t\n\t        switch (kase) {\n\t            case 1: {\n\t                f = e[p - 2];\n\t                e[p - 2] = 0;\n\t                for (j = p - 2; j >= k; j--) {\n\t                    t = hypotenuse(s[j], f);\n\t                    cs = s[j] / t;\n\t                    sn = f / t;\n\t                    s[j] = t;\n\t                    if (j !== k) {\n\t                        f = -sn * e[j - 1];\n\t                        e[j - 1] = cs * e[j - 1];\n\t                    }\n\t                    if (wantv) {\n\t                        for (i = 0; i < n; i++) {\n\t                            t = cs * V[i][j] + sn * V[i][p - 1];\n\t                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n\t                            V[i][j] = t;\n\t                        }\n\t                    }\n\t                }\n\t                break;\n\t            }\n\t            case 2 : {\n\t                f = e[k - 1];\n\t                e[k - 1] = 0;\n\t                for (j = k; j < p; j++) {\n\t                    t = hypotenuse(s[j], f);\n\t                    cs = s[j] / t;\n\t                    sn = f / t;\n\t                    s[j] = t;\n\t                    f = -sn * e[j];\n\t                    e[j] = cs * e[j];\n\t                    if (wantu) {\n\t                        for (i = 0; i < m; i++) {\n\t                            t = cs * U[i][j] + sn * U[i][k - 1];\n\t                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n\t                            U[i][j] = t;\n\t                        }\n\t                    }\n\t                }\n\t                break;\n\t            }\n\t            case 3 : {\n\t                scale = Math.max(Math.max(Math.max(Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2])), Math.abs(e[p - 2])), Math.abs(s[k])), Math.abs(e[k]));\n\t                sp = s[p - 1] / scale;\n\t                spm1 = s[p - 2] / scale;\n\t                epm1 = e[p - 2] / scale;\n\t                sk = s[k] / scale;\n\t                ek = e[k] / scale;\n\t                b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;\n\t                c = (sp * epm1) * (sp * epm1);\n\t                shift = 0;\n\t                if ((b !== 0) || (c !== 0)) {\n\t                    shift = Math.sqrt(b * b + c);\n\t                    if (b < 0) {\n\t                        shift = -shift;\n\t                    }\n\t                    shift = c / (b + shift);\n\t                }\n\t                f = (sk + sp) * (sk - sp) + shift;\n\t                g = sk * ek;\n\t                for (j = k; j < p - 1; j++) {\n\t                    t = hypotenuse(f, g);\n\t                    cs = f / t;\n\t                    sn = g / t;\n\t                    if (j !== k) {\n\t                        e[j - 1] = t;\n\t                    }\n\t                    f = cs * s[j] + sn * e[j];\n\t                    e[j] = cs * e[j] - sn * s[j];\n\t                    g = sn * s[j + 1];\n\t                    s[j + 1] = cs * s[j + 1];\n\t                    if (wantv) {\n\t                        for (i = 0; i < n; i++) {\n\t                            t = cs * V[i][j] + sn * V[i][j + 1];\n\t                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n\t                            V[i][j] = t;\n\t                        }\n\t                    }\n\t                    t = hypotenuse(f, g);\n\t                    cs = f / t;\n\t                    sn = g / t;\n\t                    s[j] = t;\n\t                    f = cs * e[j] + sn * s[j + 1];\n\t                    s[j + 1] = -sn * e[j] + cs * s[j + 1];\n\t                    g = sn * e[j + 1];\n\t                    e[j + 1] = cs * e[j + 1];\n\t                    if (wantu && (j < m - 1)) {\n\t                        for (i = 0; i < m; i++) {\n\t                            t = cs * U[i][j] + sn * U[i][j + 1];\n\t                            U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n\t                            U[i][j] = t;\n\t                        }\n\t                    }\n\t                }\n\t                e[p - 2] = f;\n\t                iter = iter + 1;\n\t                break;\n\t            }\n\t            case 4: {\n\t                if (s[k] <= 0) {\n\t                    s[k] = (s[k] < 0 ? -s[k] : 0);\n\t                    if (wantv) {\n\t                        for (i = 0; i <= pp; i++) {\n\t                            V[i][k] = -V[i][k];\n\t                        }\n\t                    }\n\t                }\n\t                while (k < pp) {\n\t                    if (s[k] >= s[k + 1]) {\n\t                        break;\n\t                    }\n\t                    t = s[k];\n\t                    s[k] = s[k + 1];\n\t                    s[k + 1] = t;\n\t                    if (wantv && (k < n - 1)) {\n\t                        for (i = 0; i < n; i++) {\n\t                            t = V[i][k + 1];\n\t                            V[i][k + 1] = V[i][k];\n\t                            V[i][k] = t;\n\t                        }\n\t                    }\n\t                    if (wantu && (k < m - 1)) {\n\t                        for (i = 0; i < m; i++) {\n\t                            t = U[i][k + 1];\n\t                            U[i][k + 1] = U[i][k];\n\t                            U[i][k] = t;\n\t                        }\n\t                    }\n\t                    k++;\n\t                }\n\t                iter = 0;\n\t                p--;\n\t                break;\n\t            }\n\t        }\n\t    }\n\t\n\t    if (swapped) {\n\t        var tmp = V;\n\t        V = U;\n\t        U = tmp;\n\t    }\n\t\n\t    this.m = m;\n\t    this.n = n;\n\t    this.s = s;\n\t    this.U = U;\n\t    this.V = V;\n\t}\n\t\n\tSingularValueDecomposition.prototype = {\n\t    get condition() {\n\t        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];\n\t    },\n\t    get norm2() {\n\t        return this.s[0];\n\t    },\n\t    get rank() {\n\t        var eps = Math.pow(2, -52),\n\t            tol = Math.max(this.m, this.n) * this.s[0] * eps,\n\t            r = 0,\n\t            s = this.s;\n\t        for (var i = 0, ii = s.length; i < ii; i++) {\n\t            if (s[i] > tol) {\n\t                r++;\n\t            }\n\t        }\n\t        return r;\n\t    },\n\t    get diagonal() {\n\t        return this.s;\n\t    },\n\t    // https://github.com/accord-net/framework/blob/development/Sources/Accord.Math/Decompositions/SingularValueDecomposition.cs\n\t    get threshold() {\n\t        return (Math.pow(2, -52) / 2) * Math.max(this.m, this.n) * this.s[0];\n\t    },\n\t    get leftSingularVectors() {\n\t        return this.U;\n\t    },\n\t    get rightSingularVectors() {\n\t        return this.V;\n\t    },\n\t    get diagonalMatrix() {\n\t        return Matrix.diag(this.s);\n\t    },\n\t    solve: function (value) {\n\t\n\t        var Y = value,\n\t            e = this.threshold,\n\t            scols = this.s.length,\n\t            Ls = Matrix.zeros(scols, scols),\n\t            i;\n\t\n\t        for (i = 0; i < scols; i++) {\n\t            if (Math.abs(this.s[i]) <= e) {\n\t                Ls[i][i] = 0;\n\t            } else {\n\t                Ls[i][i] = 1 / this.s[i];\n\t            }\n\t        }\n\t\n\t\n\t        var VL = this.V.mmul(Ls),\n\t            vrows = this.V.rows,\n\t            urows = this.U.rows,\n\t            VLU = Matrix.zeros(vrows, urows),\n\t            j, k, sum;\n\t\n\t        for (i = 0; i < vrows; i++) {\n\t            for (j = 0; j < urows; j++) {\n\t                sum = 0;\n\t                for (k = 0; k < scols; k++) {\n\t                    sum += VL[i][k] * this.U[j][k];\n\t                }\n\t                VLU[i][j] = sum;\n\t            }\n\t        }\n\t\n\t        return VLU.mmul(Y);\n\t    },\n\t    solveForDiagonal: function (value) {\n\t        return this.solve(Matrix.diag(value));\n\t    },\n\t    inverse: function () {\n\t        var e = this.threshold,\n\t            vrows = this.V.rows,\n\t            vcols = this.V.columns,\n\t            X = new Matrix(vrows, this.s.length),\n\t            i, j;\n\t\n\t        for (i = 0; i < vrows; i++) {\n\t            for (j = 0; j < vcols; j++) {\n\t                if (Math.abs(this.s[j]) > e) {\n\t                    X[i][j] = this.V[i][j] / this.s[j];\n\t                } else {\n\t                    X[i][j] = 0;\n\t                }\n\t            }\n\t        }\n\t\n\t        var urows = this.U.rows,\n\t            ucols = this.U.columns,\n\t            Y = new Matrix(vrows, urows),\n\t            k, sum;\n\t\n\t        for (i = 0; i < vrows; i++) {\n\t            for (j = 0; j < urows; j++) {\n\t                sum = 0;\n\t                for (k = 0; k < ucols; k++) {\n\t                    sum += X[i][k] * this.U[j][k];\n\t                }\n\t                Y[i][j] = sum;\n\t            }\n\t        }\n\t\n\t        return Y;\n\t    }\n\t};\n\t\n\tmodule.exports = SingularValueDecomposition;\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.hypotenuse = function hypotenuse(a, b) {\n\t    var r;\n\t    if (Math.abs(a) > Math.abs(b)) {\n\t        r = b / a;\n\t        return Math.abs(a) * Math.sqrt(1 + r * r);\n\t    }\n\t    if (b !== 0) {\n\t        r = a / b;\n\t        return Math.abs(b) * Math.sqrt(1 + r * r);\n\t    }\n\t    return 0;\n\t};\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(28);\n\tvar hypotenuse = __webpack_require__(31).hypotenuse;\n\t\n\t// https://github.com/lutzroeder/Mapack/blob/master/Source/EigenvalueDecomposition.cs\n\tfunction EigenvalueDecomposition(matrix) {\n\t    if (!(this instanceof EigenvalueDecomposition)) {\n\t        return new EigenvalueDecomposition(matrix);\n\t    }\n\t    matrix = Matrix.checkMatrix(matrix);\n\t    if (!matrix.isSquare()) {\n\t        throw new Error('Matrix is not a square matrix');\n\t    }\n\t\n\t    var n = matrix.columns,\n\t        V = Matrix.zeros(n, n),\n\t        d = new Array(n),\n\t        e = new Array(n),\n\t        value = matrix,\n\t        i, j;\n\t\n\t    if (matrix.isSymmetric()) {\n\t        for (i = 0; i < n; i++) {\n\t            for (j = 0; j < n; j++) {\n\t                V[i][j] = value[i][j];\n\t            }\n\t        }\n\t        tred2(n, e, d, V);\n\t        tql2(n, e, d, V);\n\t    }\n\t    else {\n\t        var H = Matrix.zeros(n, n),\n\t            ort = new Array(n);\n\t        for (j = 0; j < n; j++) {\n\t            for (i = 0; i < n; i++) {\n\t                H[i][j] = value[i][j];\n\t            }\n\t        }\n\t        orthes(n, H, ort, V);\n\t        hqr2(n, e, d, V, H);\n\t    }\n\t\n\t    this.n = n;\n\t    this.e = e;\n\t    this.d = d;\n\t    this.V = V;\n\t}\n\t\n\tEigenvalueDecomposition.prototype = {\n\t    get realEigenvalues() {\n\t        return this.d;\n\t    },\n\t    get imaginaryEigenvalues() {\n\t        return this.e;\n\t    },\n\t    get eigenvectorMatrix() {\n\t        return this.V;\n\t    },\n\t    get diagonalMatrix() {\n\t        var n = this.n,\n\t            e = this.e,\n\t            d = this.d,\n\t            X = new Matrix(n, n),\n\t            i, j;\n\t        for (i = 0; i < n; i++) {\n\t            for (j = 0; j < n; j++) {\n\t                X[i][j] = 0;\n\t            }\n\t            X[i][i] = d[i];\n\t            if (e[i] > 0) {\n\t                X[i][i + 1] = e[i];\n\t            }\n\t            else if (e[i] < 0) {\n\t                X[i][i - 1] = e[i];\n\t            }\n\t        }\n\t        return X;\n\t    }\n\t};\n\t\n\tfunction tred2(n, e, d, V) {\n\t\n\t    var f, g, h, i, j, k,\n\t        hh, scale;\n\t\n\t    for (j = 0; j < n; j++) {\n\t        d[j] = V[n - 1][j];\n\t    }\n\t\n\t    for (i = n - 1; i > 0; i--) {\n\t        scale = 0;\n\t        h = 0;\n\t        for (k = 0; k < i; k++) {\n\t            scale = scale + Math.abs(d[k]);\n\t        }\n\t\n\t        if (scale === 0) {\n\t            e[i] = d[i - 1];\n\t            for (j = 0; j < i; j++) {\n\t                d[j] = V[i - 1][j];\n\t                V[i][j] = 0;\n\t                V[j][i] = 0;\n\t            }\n\t        } else {\n\t            for (k = 0; k < i; k++) {\n\t                d[k] /= scale;\n\t                h += d[k] * d[k];\n\t            }\n\t\n\t            f = d[i - 1];\n\t            g = Math.sqrt(h);\n\t            if (f > 0) {\n\t                g = -g;\n\t            }\n\t\n\t            e[i] = scale * g;\n\t            h = h - f * g;\n\t            d[i - 1] = f - g;\n\t            for (j = 0; j < i; j++) {\n\t                e[j] = 0;\n\t            }\n\t\n\t            for (j = 0; j < i; j++) {\n\t                f = d[j];\n\t                V[j][i] = f;\n\t                g = e[j] + V[j][j] * f;\n\t                for (k = j + 1; k <= i - 1; k++) {\n\t                    g += V[k][j] * d[k];\n\t                    e[k] += V[k][j] * f;\n\t                }\n\t                e[j] = g;\n\t            }\n\t\n\t            f = 0;\n\t            for (j = 0; j < i; j++) {\n\t                e[j] /= h;\n\t                f += e[j] * d[j];\n\t            }\n\t\n\t            hh = f / (h + h);\n\t            for (j = 0; j < i; j++) {\n\t                e[j] -= hh * d[j];\n\t            }\n\t\n\t            for (j = 0; j < i; j++) {\n\t                f = d[j];\n\t                g = e[j];\n\t                for (k = j; k <= i - 1; k++) {\n\t                    V[k][j] -= (f * e[k] + g * d[k]);\n\t                }\n\t                d[j] = V[i - 1][j];\n\t                V[i][j] = 0;\n\t            }\n\t        }\n\t        d[i] = h;\n\t    }\n\t\n\t    for (i = 0; i < n - 1; i++) {\n\t        V[n - 1][i] = V[i][i];\n\t        V[i][i] = 1;\n\t        h = d[i + 1];\n\t        if (h !== 0) {\n\t            for (k = 0; k <= i; k++) {\n\t                d[k] = V[k][i + 1] / h;\n\t            }\n\t\n\t            for (j = 0; j <= i; j++) {\n\t                g = 0;\n\t                for (k = 0; k <= i; k++) {\n\t                    g += V[k][i + 1] * V[k][j];\n\t                }\n\t                for (k = 0; k <= i; k++) {\n\t                    V[k][j] -= g * d[k];\n\t                }\n\t            }\n\t        }\n\t\n\t        for (k = 0; k <= i; k++) {\n\t            V[k][i + 1] = 0;\n\t        }\n\t    }\n\t\n\t    for (j = 0; j < n; j++) {\n\t        d[j] = V[n - 1][j];\n\t        V[n - 1][j] = 0;\n\t    }\n\t\n\t    V[n - 1][n - 1] = 1;\n\t    e[0] = 0;\n\t}\n\t\n\tfunction tql2(n, e, d, V) {\n\t\n\t    var g, h, i, j, k, l, m, p, r,\n\t        dl1, c, c2, c3, el1, s, s2,\n\t        iter;\n\t\n\t    for (i = 1; i < n; i++) {\n\t        e[i - 1] = e[i];\n\t    }\n\t\n\t    e[n - 1] = 0;\n\t\n\t    var f = 0,\n\t        tst1 = 0,\n\t        eps = Math.pow(2, -52);\n\t\n\t    for (l = 0; l < n; l++) {\n\t        tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));\n\t        m = l;\n\t        while (m < n) {\n\t            if (Math.abs(e[m]) <= eps * tst1) {\n\t                break;\n\t            }\n\t            m++;\n\t        }\n\t\n\t        if (m > l) {\n\t            iter = 0;\n\t            do {\n\t                iter = iter + 1;\n\t\n\t                g = d[l];\n\t                p = (d[l + 1] - g) / (2 * e[l]);\n\t                r = hypotenuse(p, 1);\n\t                if (p < 0) {\n\t                    r = -r;\n\t                }\n\t\n\t                d[l] = e[l] / (p + r);\n\t                d[l + 1] = e[l] * (p + r);\n\t                dl1 = d[l + 1];\n\t                h = g - d[l];\n\t                for (i = l + 2; i < n; i++) {\n\t                    d[i] -= h;\n\t                }\n\t\n\t                f = f + h;\n\t\n\t                p = d[m];\n\t                c = 1;\n\t                c2 = c;\n\t                c3 = c;\n\t                el1 = e[l + 1];\n\t                s = 0;\n\t                s2 = 0;\n\t                for (i = m - 1; i >= l; i--) {\n\t                    c3 = c2;\n\t                    c2 = c;\n\t                    s2 = s;\n\t                    g = c * e[i];\n\t                    h = c * p;\n\t                    r = hypotenuse(p, e[i]);\n\t                    e[i + 1] = s * r;\n\t                    s = e[i] / r;\n\t                    c = p / r;\n\t                    p = c * d[i] - s * g;\n\t                    d[i + 1] = h + s * (c * g + s * d[i]);\n\t\n\t                    for (k = 0; k < n; k++) {\n\t                        h = V[k][i + 1];\n\t                        V[k][i + 1] = s * V[k][i] + c * h;\n\t                        V[k][i] = c * V[k][i] - s * h;\n\t                    }\n\t                }\n\t\n\t                p = -s * s2 * c3 * el1 * e[l] / dl1;\n\t                e[l] = s * p;\n\t                d[l] = c * p;\n\t\n\t            }\n\t            while (Math.abs(e[l]) > eps * tst1);\n\t        }\n\t        d[l] = d[l] + f;\n\t        e[l] = 0;\n\t    }\n\t\n\t    for (i = 0; i < n - 1; i++) {\n\t        k = i;\n\t        p = d[i];\n\t        for (j = i + 1; j < n; j++) {\n\t            if (d[j] < p) {\n\t                k = j;\n\t                p = d[j];\n\t            }\n\t        }\n\t\n\t        if (k !== i) {\n\t            d[k] = d[i];\n\t            d[i] = p;\n\t            for (j = 0; j < n; j++) {\n\t                p = V[j][i];\n\t                V[j][i] = V[j][k];\n\t                V[j][k] = p;\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction orthes(n, H, ort, V) {\n\t\n\t    var low = 0,\n\t        high = n - 1,\n\t        f, g, h, i, j, m,\n\t        scale;\n\t\n\t    for (m = low + 1; m <= high - 1; m++) {\n\t        scale = 0;\n\t        for (i = m; i <= high; i++) {\n\t            scale = scale + Math.abs(H[i][m - 1]);\n\t        }\n\t\n\t        if (scale !== 0) {\n\t            h = 0;\n\t            for (i = high; i >= m; i--) {\n\t                ort[i] = H[i][m - 1] / scale;\n\t                h += ort[i] * ort[i];\n\t            }\n\t\n\t            g = Math.sqrt(h);\n\t            if (ort[m] > 0) {\n\t                g = -g;\n\t            }\n\t\n\t            h = h - ort[m] * g;\n\t            ort[m] = ort[m] - g;\n\t\n\t            for (j = m; j < n; j++) {\n\t                f = 0;\n\t                for (i = high; i >= m; i--) {\n\t                    f += ort[i] * H[i][j];\n\t                }\n\t\n\t                f = f / h;\n\t                for (i = m; i <= high; i++) {\n\t                    H[i][j] -= f * ort[i];\n\t                }\n\t            }\n\t\n\t            for (i = 0; i <= high; i++) {\n\t                f = 0;\n\t                for (j = high; j >= m; j--) {\n\t                    f += ort[j] * H[i][j];\n\t                }\n\t\n\t                f = f / h;\n\t                for (j = m; j <= high; j++) {\n\t                    H[i][j] -= f * ort[j];\n\t                }\n\t            }\n\t\n\t            ort[m] = scale * ort[m];\n\t            H[m][m - 1] = scale * g;\n\t        }\n\t    }\n\t\n\t    for (i = 0; i < n; i++) {\n\t        for (j = 0; j < n; j++) {\n\t            V[i][j] = (i === j ? 1 : 0);\n\t        }\n\t    }\n\t\n\t    for (m = high - 1; m >= low + 1; m--) {\n\t        if (H[m][m - 1] !== 0) {\n\t            for (i = m + 1; i <= high; i++) {\n\t                ort[i] = H[i][m - 1];\n\t            }\n\t\n\t            for (j = m; j <= high; j++) {\n\t                g = 0;\n\t                for (i = m; i <= high; i++) {\n\t                    g += ort[i] * V[i][j];\n\t                }\n\t\n\t                g = (g / ort[m]) / H[m][m - 1];\n\t                for (i = m; i <= high; i++) {\n\t                    V[i][j] += g * ort[i];\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction hqr2(nn, e, d, V, H) {\n\t    var n = nn - 1,\n\t        low = 0,\n\t        high = nn - 1,\n\t        eps = Math.pow(2, -52),\n\t        exshift = 0,\n\t        norm = 0,\n\t        p = 0,\n\t        q = 0,\n\t        r = 0,\n\t        s = 0,\n\t        z = 0,\n\t        iter = 0,\n\t        i, j, k, l, m, t, w, x, y,\n\t        ra, sa, vr, vi,\n\t        notlast, cdivres;\n\t\n\t    for (i = 0; i < nn; i++) {\n\t        if (i < low || i > high) {\n\t            d[i] = H[i][i];\n\t            e[i] = 0;\n\t        }\n\t\n\t        for (j = Math.max(i - 1, 0); j < nn; j++) {\n\t            norm = norm + Math.abs(H[i][j]);\n\t        }\n\t    }\n\t\n\t    while (n >= low) {\n\t        l = n;\n\t        while (l > low) {\n\t            s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);\n\t            if (s === 0) {\n\t                s = norm;\n\t            }\n\t            if (Math.abs(H[l][l - 1]) < eps * s) {\n\t                break;\n\t            }\n\t            l--;\n\t        }\n\t\n\t        if (l === n) {\n\t            H[n][n] = H[n][n] + exshift;\n\t            d[n] = H[n][n];\n\t            e[n] = 0;\n\t            n--;\n\t            iter = 0;\n\t        } else if (l === n - 1) {\n\t            w = H[n][n - 1] * H[n - 1][n];\n\t            p = (H[n - 1][n - 1] - H[n][n]) / 2;\n\t            q = p * p + w;\n\t            z = Math.sqrt(Math.abs(q));\n\t            H[n][n] = H[n][n] + exshift;\n\t            H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;\n\t            x = H[n][n];\n\t\n\t            if (q >= 0) {\n\t                z = (p >= 0) ? (p + z) : (p - z);\n\t                d[n - 1] = x + z;\n\t                d[n] = d[n - 1];\n\t                if (z !== 0) {\n\t                    d[n] = x - w / z;\n\t                }\n\t                e[n - 1] = 0;\n\t                e[n] = 0;\n\t                x = H[n][n - 1];\n\t                s = Math.abs(x) + Math.abs(z);\n\t                p = x / s;\n\t                q = z / s;\n\t                r = Math.sqrt(p * p + q * q);\n\t                p = p / r;\n\t                q = q / r;\n\t\n\t                for (j = n - 1; j < nn; j++) {\n\t                    z = H[n - 1][j];\n\t                    H[n - 1][j] = q * z + p * H[n][j];\n\t                    H[n][j] = q * H[n][j] - p * z;\n\t                }\n\t\n\t                for (i = 0; i <= n; i++) {\n\t                    z = H[i][n - 1];\n\t                    H[i][n - 1] = q * z + p * H[i][n];\n\t                    H[i][n] = q * H[i][n] - p * z;\n\t                }\n\t\n\t                for (i = low; i <= high; i++) {\n\t                    z = V[i][n - 1];\n\t                    V[i][n - 1] = q * z + p * V[i][n];\n\t                    V[i][n] = q * V[i][n] - p * z;\n\t                }\n\t            } else {\n\t                d[n - 1] = x + p;\n\t                d[n] = x + p;\n\t                e[n - 1] = z;\n\t                e[n] = -z;\n\t            }\n\t\n\t            n = n - 2;\n\t            iter = 0;\n\t        } else {\n\t            x = H[n][n];\n\t            y = 0;\n\t            w = 0;\n\t            if (l < n) {\n\t                y = H[n - 1][n - 1];\n\t                w = H[n][n - 1] * H[n - 1][n];\n\t            }\n\t\n\t            if (iter === 10) {\n\t                exshift += x;\n\t                for (i = low; i <= n; i++) {\n\t                    H[i][i] -= x;\n\t                }\n\t                s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);\n\t                x = y = 0.75 * s;\n\t                w = -0.4375 * s * s;\n\t            }\n\t\n\t            if (iter === 30) {\n\t                s = (y - x) / 2;\n\t                s = s * s + w;\n\t                if (s > 0) {\n\t                    s = Math.sqrt(s);\n\t                    if (y < x) {\n\t                        s = -s;\n\t                    }\n\t                    s = x - w / ((y - x) / 2 + s);\n\t                    for (i = low; i <= n; i++) {\n\t                        H[i][i] -= s;\n\t                    }\n\t                    exshift += s;\n\t                    x = y = w = 0.964;\n\t                }\n\t            }\n\t\n\t            iter = iter + 1;\n\t\n\t            m = n - 2;\n\t            while (m >= l) {\n\t                z = H[m][m];\n\t                r = x - z;\n\t                s = y - z;\n\t                p = (r * s - w) / H[m + 1][m] + H[m][m + 1];\n\t                q = H[m + 1][m + 1] - z - r - s;\n\t                r = H[m + 2][m + 1];\n\t                s = Math.abs(p) + Math.abs(q) + Math.abs(r);\n\t                p = p / s;\n\t                q = q / s;\n\t                r = r / s;\n\t                if (m === l) {\n\t                    break;\n\t                }\n\t                if (Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) < eps * (Math.abs(p) * (Math.abs(H[m - 1][m - 1]) + Math.abs(z) + Math.abs(H[m + 1][m + 1])))) {\n\t                    break;\n\t                }\n\t                m--;\n\t            }\n\t\n\t            for (i = m + 2; i <= n; i++) {\n\t                H[i][i - 2] = 0;\n\t                if (i > m + 2) {\n\t                    H[i][i - 3] = 0;\n\t                }\n\t            }\n\t\n\t            for (k = m; k <= n - 1; k++) {\n\t                notlast = (k !== n - 1);\n\t                if (k !== m) {\n\t                    p = H[k][k - 1];\n\t                    q = H[k + 1][k - 1];\n\t                    r = (notlast ? H[k + 2][k - 1] : 0);\n\t                    x = Math.abs(p) + Math.abs(q) + Math.abs(r);\n\t                    if (x !== 0) {\n\t                        p = p / x;\n\t                        q = q / x;\n\t                        r = r / x;\n\t                    }\n\t                }\n\t\n\t                if (x === 0) {\n\t                    break;\n\t                }\n\t\n\t                s = Math.sqrt(p * p + q * q + r * r);\n\t                if (p < 0) {\n\t                    s = -s;\n\t                }\n\t\n\t                if (s !== 0) {\n\t                    if (k !== m) {\n\t                        H[k][k - 1] = -s * x;\n\t                    } else if (l !== m) {\n\t                        H[k][k - 1] = -H[k][k - 1];\n\t                    }\n\t\n\t                    p = p + s;\n\t                    x = p / s;\n\t                    y = q / s;\n\t                    z = r / s;\n\t                    q = q / p;\n\t                    r = r / p;\n\t\n\t                    for (j = k; j < nn; j++) {\n\t                        p = H[k][j] + q * H[k + 1][j];\n\t                        if (notlast) {\n\t                            p = p + r * H[k + 2][j];\n\t                            H[k + 2][j] = H[k + 2][j] - p * z;\n\t                        }\n\t\n\t                        H[k][j] = H[k][j] - p * x;\n\t                        H[k + 1][j] = H[k + 1][j] - p * y;\n\t                    }\n\t\n\t                    for (i = 0; i <= Math.min(n, k + 3); i++) {\n\t                        p = x * H[i][k] + y * H[i][k + 1];\n\t                        if (notlast) {\n\t                            p = p + z * H[i][k + 2];\n\t                            H[i][k + 2] = H[i][k + 2] - p * r;\n\t                        }\n\t\n\t                        H[i][k] = H[i][k] - p;\n\t                        H[i][k + 1] = H[i][k + 1] - p * q;\n\t                    }\n\t\n\t                    for (i = low; i <= high; i++) {\n\t                        p = x * V[i][k] + y * V[i][k + 1];\n\t                        if (notlast) {\n\t                            p = p + z * V[i][k + 2];\n\t                            V[i][k + 2] = V[i][k + 2] - p * r;\n\t                        }\n\t\n\t                        V[i][k] = V[i][k] - p;\n\t                        V[i][k + 1] = V[i][k + 1] - p * q;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    if (norm === 0) {\n\t        return;\n\t    }\n\t\n\t    for (n = nn - 1; n >= 0; n--) {\n\t        p = d[n];\n\t        q = e[n];\n\t\n\t        if (q === 0) {\n\t            l = n;\n\t            H[n][n] = 1;\n\t            for (i = n - 1; i >= 0; i--) {\n\t                w = H[i][i] - p;\n\t                r = 0;\n\t                for (j = l; j <= n; j++) {\n\t                    r = r + H[i][j] * H[j][n];\n\t                }\n\t\n\t                if (e[i] < 0) {\n\t                    z = w;\n\t                    s = r;\n\t                } else {\n\t                    l = i;\n\t                    if (e[i] === 0) {\n\t                        H[i][n] = (w !== 0) ? (-r / w) : (-r / (eps * norm));\n\t                    } else {\n\t                        x = H[i][i + 1];\n\t                        y = H[i + 1][i];\n\t                        q = (d[i] - p) * (d[i] - p) + e[i] * e[i];\n\t                        t = (x * s - z * r) / q;\n\t                        H[i][n] = t;\n\t                        H[i + 1][n] = (Math.abs(x) > Math.abs(z)) ? ((-r - w * t) / x) : ((-s - y * t) / z);\n\t                    }\n\t\n\t                    t = Math.abs(H[i][n]);\n\t                    if ((eps * t) * t > 1) {\n\t                        for (j = i; j <= n; j++) {\n\t                            H[j][n] = H[j][n] / t;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        } else if (q < 0) {\n\t            l = n - 1;\n\t\n\t            if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {\n\t                H[n - 1][n - 1] = q / H[n][n - 1];\n\t                H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];\n\t            } else {\n\t                cdivres = cdiv(0, -H[n - 1][n], H[n - 1][n - 1] - p, q);\n\t                H[n - 1][n - 1] = cdivres[0];\n\t                H[n - 1][n] = cdivres[1];\n\t            }\n\t\n\t            H[n][n - 1] = 0;\n\t            H[n][n] = 1;\n\t            for (i = n - 2; i >= 0; i--) {\n\t                ra = 0;\n\t                sa = 0;\n\t                for (j = l; j <= n; j++) {\n\t                    ra = ra + H[i][j] * H[j][n - 1];\n\t                    sa = sa + H[i][j] * H[j][n];\n\t                }\n\t\n\t                w = H[i][i] - p;\n\t\n\t                if (e[i] < 0) {\n\t                    z = w;\n\t                    r = ra;\n\t                    s = sa;\n\t                } else {\n\t                    l = i;\n\t                    if (e[i] === 0) {\n\t                        cdivres = cdiv(-ra, -sa, w, q);\n\t                        H[i][n - 1] = cdivres[0];\n\t                        H[i][n] = cdivres[1];\n\t                    } else {\n\t                        x = H[i][i + 1];\n\t                        y = H[i + 1][i];\n\t                        vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;\n\t                        vi = (d[i] - p) * 2 * q;\n\t                        if (vr === 0 && vi === 0) {\n\t                            vr = eps * norm * (Math.abs(w) + Math.abs(q) + Math.abs(x) + Math.abs(y) + Math.abs(z));\n\t                        }\n\t                        cdivres = cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);\n\t                        H[i][n - 1] = cdivres[0];\n\t                        H[i][n] = cdivres[1];\n\t                        if (Math.abs(x) > (Math.abs(z) + Math.abs(q))) {\n\t                            H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;\n\t                            H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;\n\t                        } else {\n\t                            cdivres = cdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);\n\t                            H[i + 1][n - 1] = cdivres[0];\n\t                            H[i + 1][n] = cdivres[1];\n\t                        }\n\t                    }\n\t\n\t                    t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));\n\t                    if ((eps * t) * t > 1) {\n\t                        for (j = i; j <= n; j++) {\n\t                            H[j][n - 1] = H[j][n - 1] / t;\n\t                            H[j][n] = H[j][n] / t;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    for (i = 0; i < nn; i++) {\n\t        if (i < low || i > high) {\n\t            for (j = i; j < nn; j++) {\n\t                V[i][j] = H[i][j];\n\t            }\n\t        }\n\t    }\n\t\n\t    for (j = nn - 1; j >= low; j--) {\n\t        for (i = low; i <= high; i++) {\n\t            z = 0;\n\t            for (k = low; k <= Math.min(j, high); k++) {\n\t                z = z + V[i][k] * H[k][j];\n\t            }\n\t            V[i][j] = z;\n\t        }\n\t    }\n\t}\n\t\n\tfunction cdiv(xr, xi, yr, yi) {\n\t    var r, d;\n\t    if (Math.abs(yr) > Math.abs(yi)) {\n\t        r = yi / yr;\n\t        d = yr + r * yi;\n\t        return [(xr + r * xi) / d, (xi - r * xr) / d];\n\t    }\n\t    else {\n\t        r = yr / yi;\n\t        d = yi + r * yr;\n\t        return [(r * xr + xi) / d, (r * xi - xr) / d];\n\t    }\n\t}\n\t\n\tmodule.exports = EigenvalueDecomposition;\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(28);\n\t\n\t// https://github.com/lutzroeder/Mapack/blob/master/Source/LuDecomposition.cs\n\tfunction LuDecomposition(matrix) {\n\t    if (!(this instanceof LuDecomposition)) {\n\t        return new LuDecomposition(matrix);\n\t    }\n\t    matrix = Matrix.checkMatrix(matrix);\n\t\n\t    var lu = matrix.clone(),\n\t        rows = lu.rows,\n\t        columns = lu.columns,\n\t        pivotVector = new Array(rows),\n\t        pivotSign = 1,\n\t        i, j, k, p, s, t, v,\n\t        LUrowi, LUcolj, kmax;\n\t\n\t    for (i = 0; i < rows; i++) {\n\t        pivotVector[i] = i;\n\t    }\n\t\n\t    LUcolj = new Array(rows);\n\t\n\t    for (j = 0; j < columns; j++) {\n\t\n\t        for (i = 0; i < rows; i++) {\n\t            LUcolj[i] = lu[i][j];\n\t        }\n\t\n\t        for (i = 0; i < rows; i++) {\n\t            LUrowi = lu[i];\n\t            kmax = Math.min(i, j);\n\t            s = 0;\n\t            for (k = 0; k < kmax; k++) {\n\t                s += LUrowi[k] * LUcolj[k];\n\t            }\n\t            LUrowi[j] = LUcolj[i] -= s;\n\t        }\n\t\n\t        p = j;\n\t        for (i = j + 1; i < rows; i++) {\n\t            if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {\n\t                p = i;\n\t            }\n\t        }\n\t\n\t        if (p !== j) {\n\t            for (k = 0; k < columns; k++) {\n\t                t = lu[p][k];\n\t                lu[p][k] = lu[j][k];\n\t                lu[j][k] = t;\n\t            }\n\t\n\t            v = pivotVector[p];\n\t            pivotVector[p] = pivotVector[j];\n\t            pivotVector[j] = v;\n\t\n\t            pivotSign = -pivotSign;\n\t        }\n\t\n\t        if (j < rows && lu[j][j] !== 0) {\n\t            for (i = j + 1; i < rows; i++) {\n\t                lu[i][j] /= lu[j][j];\n\t            }\n\t        }\n\t    }\n\t\n\t    this.LU = lu;\n\t    this.pivotVector = pivotVector;\n\t    this.pivotSign = pivotSign;\n\t}\n\t\n\tLuDecomposition.prototype = {\n\t    isSingular: function () {\n\t        var data = this.LU,\n\t            col = data.columns;\n\t        for (var j = 0; j < col; j++) {\n\t            if (data[j][j] === 0) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    },\n\t    get determinant() {\n\t        var data = this.LU;\n\t        if (!data.isSquare())\n\t            throw new Error('Matrix must be square');\n\t        var determinant = this.pivotSign, col = data.columns;\n\t        for (var j = 0; j < col; j++)\n\t            determinant *= data[j][j];\n\t        return determinant;\n\t    },\n\t    get lowerTriangularFactor() {\n\t        var data = this.LU,\n\t            rows = data.rows,\n\t            columns = data.columns,\n\t            X = new Matrix(rows, columns);\n\t        for (var i = 0; i < rows; i++) {\n\t            for (var j = 0; j < columns; j++) {\n\t                if (i > j) {\n\t                    X[i][j] = data[i][j];\n\t                } else if (i === j) {\n\t                    X[i][j] = 1;\n\t                } else {\n\t                    X[i][j] = 0;\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    },\n\t    get upperTriangularFactor() {\n\t        var data = this.LU,\n\t            rows = data.rows,\n\t            columns = data.columns,\n\t            X = new Matrix(rows, columns);\n\t        for (var i = 0; i < rows; i++) {\n\t            for (var j = 0; j < columns; j++) {\n\t                if (i <= j) {\n\t                    X[i][j] = data[i][j];\n\t                } else {\n\t                    X[i][j] = 0;\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    },\n\t    get pivotPermutationVector() {\n\t        return this.pivotVector.slice();\n\t    },\n\t    solve: function (value) {\n\t        value = Matrix.checkMatrix(value);\n\t\n\t        var lu = this.LU,\n\t            rows = lu.rows;\n\t\n\t        if (rows !== value.rows)\n\t            throw new Error('Invalid matrix dimensions');\n\t        if (this.isSingular())\n\t            throw new Error('LU matrix is singular');\n\t\n\t        var count = value.columns,\n\t            X = value.subMatrixRow(this.pivotVector, 0, count - 1),\n\t            columns = lu.columns,\n\t            i, j, k;\n\t\n\t        for (k = 0; k < columns; k++) {\n\t            for (i = k + 1; i < columns; i++) {\n\t                for (j = 0; j < count; j++) {\n\t                    X[i][j] -= X[k][j] * lu[i][k];\n\t                }\n\t            }\n\t        }\n\t        for (k = columns - 1; k >= 0; k--) {\n\t            for (j = 0; j < count; j++) {\n\t                X[k][j] /= lu[k][k];\n\t            }\n\t            for (i = 0; i < k; i++) {\n\t                for (j = 0; j < count; j++) {\n\t                    X[i][j] -= X[k][j] * lu[i][k];\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    }\n\t};\n\t\n\tmodule.exports = LuDecomposition;\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(28);\n\tvar hypotenuse = __webpack_require__(31).hypotenuse;\n\t\n\t//https://github.com/lutzroeder/Mapack/blob/master/Source/QrDecomposition.cs\n\tfunction QrDecomposition(value) {\n\t    if (!(this instanceof QrDecomposition)) {\n\t        return new QrDecomposition(value);\n\t    }\n\t    value = Matrix.checkMatrix(value);\n\t\n\t    var qr = value.clone(),\n\t        m = value.rows,\n\t        n = value.columns,\n\t        rdiag = new Array(n),\n\t        i, j, k, s;\n\t\n\t    for (k = 0; k < n; k++) {\n\t        var nrm = 0;\n\t        for (i = k; i < m; i++) {\n\t            nrm = hypotenuse(nrm, qr[i][k]);\n\t        }\n\t        if (nrm !== 0) {\n\t            if (qr[k][k] < 0) {\n\t                nrm = -nrm;\n\t            }\n\t            for (i = k; i < m; i++) {\n\t                qr[i][k] /= nrm;\n\t            }\n\t            qr[k][k] += 1;\n\t            for (j = k + 1; j < n; j++) {\n\t                s = 0;\n\t                for (i = k; i < m; i++) {\n\t                    s += qr[i][k] * qr[i][j];\n\t                }\n\t                s = -s / qr[k][k];\n\t                for (i = k; i < m; i++) {\n\t                    qr[i][j] += s * qr[i][k];\n\t                }\n\t            }\n\t        }\n\t        rdiag[k] = -nrm;\n\t    }\n\t\n\t    this.QR = qr;\n\t    this.Rdiag = rdiag;\n\t}\n\t\n\tQrDecomposition.prototype = {\n\t    solve: function (value) {\n\t        value = Matrix.checkMatrix(value);\n\t\n\t        var qr = this.QR,\n\t            m = qr.rows;\n\t\n\t        if (value.rows !== m)\n\t            throw new Error('Matrix row dimensions must agree');\n\t        if (!this.isFullRank())\n\t            throw new Error('Matrix is rank deficient');\n\t\n\t        var count = value.columns,\n\t            X = value.clone(),\n\t            n = qr.columns,\n\t            i, j, k, s;\n\t\n\t        for (k = 0; k < n; k++) {\n\t            for (j = 0; j < count; j++) {\n\t                s = 0;\n\t                for (i = k; i < m; i++) {\n\t                    s += qr[i][k] * X[i][j];\n\t                }\n\t                s = -s / qr[k][k];\n\t                for (i = k; i < m; i++) {\n\t                    X[i][j] += s * qr[i][k];\n\t                }\n\t            }\n\t        }\n\t        for (k = n - 1; k >= 0; k--) {\n\t            for (j = 0; j < count; j++) {\n\t                X[k][j] /= this.Rdiag[k];\n\t            }\n\t            for (i = 0; i < k; i++) {\n\t                for (j = 0; j < count; j++) {\n\t                    X[i][j] -= X[k][j] * qr[i][k];\n\t                }\n\t            }\n\t        }\n\t\n\t        return X.subMatrix(0, n - 1, 0, count - 1);\n\t    },\n\t    isFullRank: function () {\n\t        var columns = this.QR.columns;\n\t        for (var i = 0; i < columns; i++) {\n\t            if (this.Rdiag[i] === 0) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    },\n\t    get upperTriangularFactor() {\n\t        var qr = this.QR,\n\t            n = qr.columns,\n\t            X = new Matrix(n, n),\n\t            i, j;\n\t        for (i = 0; i < n; i++) {\n\t            for (j = 0; j < n; j++) {\n\t                if (i < j) {\n\t                    X[i][j] = qr[i][j];\n\t                } else if (i === j) {\n\t                    X[i][j] = this.Rdiag[i];\n\t                } else {\n\t                    X[i][j] = 0;\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    },\n\t    get orthogonalFactor() {\n\t        var qr = this.QR,\n\t            rows = qr.rows,\n\t            columns = qr.columns,\n\t            X = new Matrix(rows, columns),\n\t            i, j, k, s;\n\t\n\t        for (k = columns - 1; k >= 0; k--) {\n\t            for (i = 0; i < rows; i++) {\n\t                X[i][k] = 0;\n\t            }\n\t            X[k][k] = 1;\n\t            for (j = k; j < columns; j++) {\n\t                if (qr[k][k] !== 0) {\n\t                    s = 0;\n\t                    for (i = k; i < rows; i++) {\n\t                        s += qr[i][k] * X[i][j];\n\t                    }\n\t\n\t                    s = -s / qr[k][k];\n\t\n\t                    for (i = k; i < rows; i++) {\n\t                        X[i][j] += s * qr[i][k];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    }\n\t};\n\t\n\tmodule.exports = QrDecomposition;\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(28);\n\t\n\t// https://github.com/lutzroeder/Mapack/blob/master/Source/CholeskyDecomposition.cs\n\tfunction CholeskyDecomposition(value) {\n\t    if (!(this instanceof CholeskyDecomposition)) {\n\t        return new CholeskyDecomposition(value);\n\t    }\n\t    value = Matrix.checkMatrix(value);\n\t    if (!value.isSymmetric())\n\t        throw new Error('Matrix is not symmetric');\n\t\n\t    var a = value,\n\t        dimension = a.rows,\n\t        l = new Matrix(dimension, dimension),\n\t        positiveDefinite = true,\n\t        i, j, k;\n\t\n\t    for (j = 0; j < dimension; j++) {\n\t        var Lrowj = l[j];\n\t        var d = 0;\n\t        for (k = 0; k < j; k++) {\n\t            var Lrowk = l[k];\n\t            var s = 0;\n\t            for (i = 0; i < k; i++) {\n\t                s += Lrowk[i] * Lrowj[i];\n\t            }\n\t            Lrowj[k] = s = (a[j][k] - s) / l[k][k];\n\t            d = d + s * s;\n\t        }\n\t\n\t        d = a[j][j] - d;\n\t\n\t        positiveDefinite &= (d > 0);\n\t        l[j][j] = Math.sqrt(Math.max(d, 0));\n\t        for (k = j + 1; k < dimension; k++) {\n\t            l[j][k] = 0;\n\t        }\n\t    }\n\t\n\t    if (!positiveDefinite) {\n\t        throw new Error('Matrix is not positive definite');\n\t    }\n\t\n\t    this.L = l;\n\t}\n\t\n\tCholeskyDecomposition.prototype = {\n\t    get leftTriangularFactor() {\n\t        return this.L;\n\t    },\n\t    solve: function (value) {\n\t        value = Matrix.checkMatrix(value);\n\t\n\t        var l = this.L,\n\t            dimension = l.rows;\n\t\n\t        if (value.rows !== dimension) {\n\t            throw new Error('Matrix dimensions do not match');\n\t        }\n\t\n\t        var count = value.columns,\n\t            B = value.clone(),\n\t            i, j, k;\n\t\n\t        for (k = 0; k < dimension; k++) {\n\t            for (j = 0; j < count; j++) {\n\t                for (i = 0; i < k; i++) {\n\t                    B[k][j] -= B[i][j] * l[k][i];\n\t                }\n\t                B[k][j] /= l[k][k];\n\t            }\n\t        }\n\t\n\t        for (k = dimension - 1; k >= 0; k--) {\n\t            for (j = 0; j < count; j++) {\n\t                for (i = k + 1; i < dimension; i++) {\n\t                    B[k][j] -= B[i][j] * l[i][k];\n\t                }\n\t                B[k][j] /= l[k][k];\n\t            }\n\t        }\n\t\n\t        return B;\n\t    }\n\t};\n\t\n\tmodule.exports = CholeskyDecomposition;\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Opt = __webpack_require__(14);\n\tvar stats = __webpack_require__(37);\n\tvar extend = __webpack_require__(1);\n\tvar SG = __webpack_require__(39);\n\t\n\tvar sgDefOptions = {\n\t    windowSize: 9,\n\t    polynomial: 3\n\t};\n\t\n\t\n\tfunction gsd(x, y, options){\n\t    //options = extend({}, defaultOptions, options);\n\t    var options=Object.create(options || {});\n\t    if (options.minMaxRatio===undefined) options.minMaxRatio=0.00025;\n\t    if (options.broadRatio===undefined) options.broadRatio=0.00;\n\t    if (options.noiseLevel===undefined) options.noiseLevel=undefined;\n\t    if (options.noiseFactor===undefined) options.noiseFactor=3;\n\t    if (options.maxCriteria===undefined) options.maxCriteria=true;\n\t    if (options.smoothY===undefined) options.smoothY=true;\n\t    if (options.realTopDetection===undefined) options.realTopDetection=false;\n\t\n\t    var sgOptions = extend({}, sgDefOptions, options.sgOptions);\n\t\n\t    //console.log(JSON.stringify(stats.array.minMax(y)));\n\t    if(options.noiseLevel===undefined){\n\t        //We have to know if x is equally spaced\n\t        var maxDx=0, minDx=Number.MAX_VALUE,tmp;\n\t        for(var i=0;i< x.length-1;i++){\n\t            var tmp = Math.abs(x[i+1]-x[i]);\n\t            if(tmp<minDx){\n\t                minDx = tmp;\n\t            }\n\t            if(tmp>maxDx){\n\t                maxDx = tmp;\n\t            }\n\t        }\n\t\n\t        if((maxDx-minDx)/maxDx<0.05){\n\t\n\t            options.noiseLevel = getNoiseLevel(y);\n\t            //console.log(options.noiseLevel+\" \"+stats.array.median(y));\n\t        }\n\t        else{\n\t            options.noiseLevel = 0;\n\t        }\n\t    }\n\t    //console.log(\"options.noiseLevel \"+options.noiseLevel);\n\t    y=[].concat(y);\n\t    var yCorrection = {m:1, b:options.noiseLevel};\n\t    if(!options.maxCriteria){\n\t        yCorrection.m =-1;\n\t        yCorrection.b*=-1;\n\t    }\n\t\n\t    for (var i=0; i<y.length; i++){\n\t        y[i]=yCorrection.m*y[i]-yCorrection.b;\n\t    }\n\t\n\t    for (var i=0; i<y.length; i++) {\n\t        if (y[i] < 0) {\n\t            y[i] = 0;\n\t        }\n\t    }\n\t\n\t    //If the max difference between delta x is less than 5%, then, we can assume it to be equally spaced variable\n\t    var Y = y;\n\t    if((maxDx-minDx)/maxDx<0.05){\n\t        if(options.smoothY)\n\t            Y = SG(y, x[1]-x[0], {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:0});\n\t        var dY = SG(y, x[1]-x[0], {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:1});\n\t        var ddY = SG(y, x[1]-x[0], {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:2});\n\t    }\n\t    else{\n\t        if(options.smoothY)\n\t            Y = SG(y, x, {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:0});\n\t        var dY = SG(y, x, {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:1});\n\t        var ddY = SG(y, x, {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:2});\n\t    }\n\t\n\t    var X = x;\n\t    var dx = x[1]-x[0];\n\t    var maxDdy=0;\n\t    var maxY = 0;\n\t    //console.log(Y.length);\n\t    for (var i = 0; i < Y.length ; i++){\n\t        if(Math.abs(ddY[i])>maxDdy){\n\t            maxDdy = Math.abs(ddY[i]);\n\t        }\n\t        if(Math.abs(Y[i])>maxY){\n\t            maxY = Math.abs(Y[i]);\n\t        }\n\t    }\n\t    //console.log(maxY+\"x\"+maxDy+\"x\"+maxDdy);\n\t\n\t    var minddY = [];\n\t    var intervalL = [];\n\t    var intervalR = [];\n\t    var lastMax = null;\n\t    var lastMin = null;\n\t    var broadMask = new Array();\n\t    //console.log(dx);\n\t    //By the intermediate value theorem We cannot find 2 consecutive maxima or minima\n\t    for (var i = 1; i < Y.length -1 ; i++){\n\t        //console.log(dY[i]);\n\t        if ((dY[i] < dY[i-1]) && (dY[i] <= dY[i+1])||\n\t            (dY[i] <= dY[i-1]) && (dY[i] < dY[i+1])) {\n\t            lastMin = X[i];\n\t            //console.log(\"min \"+lastMin);\n\t            if(dx>0&&lastMax!=null){\n\t                intervalL.push(lastMax);\n\t                intervalR.push(lastMin);\n\t\n\t            }\n\t        }\n\t\n\t        if ((dY[i] >= dY[i-1]) && (dY[i] > dY[i+1])||\n\t            (dY[i] > dY[i-1]) && (dY[i] >= dY[i+1])) {\n\t            lastMax = X[i];\n\t            //console.log(\"max \"+lastMax);\n\t            if(dx<0&&lastMin!=null){\n\t                intervalL.push(lastMax);\n\t                intervalR.push(lastMin);\n\t            }\n\t        }\n\t        if ((ddY[i] < ddY[i-1]) && (ddY[i] < ddY[i+1])) {\n\t            minddY.push(i);//( [X[i], Y[i], i] );  // TODO should we change this to have 3 arrays ? Huge overhead creating arrays\n\t            if(Math.abs(ddY[i])>options.broadRatio*maxDdy){ // TODO should this be a parameter =\n\t                broadMask.push(false);\n\t            }\n\t            else{\n\t                broadMask.push(true);\n\t            }\n\t        }\n\t    }\n\t    //\n\t    //console.log(intervalL.length+\" \"+minddY.length+\" \"+broadMask.length);\n\t    var signals = [];\n\t    var lastK = 0,possible, k, f,frequency, distanceJ, minDistance, gettingCloser;\n\t    for (var j = 0; j < minddY.length; j++){\n\t        frequency = X[minddY[j]];//minddY[j][0];\n\t        possible = -1;\n\t        k=lastK+1;\n\t        minDistance = Number.MAX_VALUE;\n\t        distanceJ = 0;\n\t        gettingCloser=true;\n\t        while(possible==-1&&k<intervalL.length&&gettingCloser){\n\t            distanceJ = Math.abs(frequency-(intervalL[k]+intervalR[k])/2);\n\t            //Still getting closer?\n\t            if(distanceJ<minDistance){\n\t                minDistance = distanceJ;\n\t            }\n\t            else{\n\t                gettingCloser = false;\n\t            }\n\t            if( distanceJ <Math.abs(intervalL[k]-intervalR[k])/2){\n\t                possible=k;\n\t                lastK = k;\n\t            }\n\t            k++;\n\t        }\n\t        //console.log(lastK+\" \"+intervalL.length+\" possible \"+k);\n\t        if (possible!=-1){\n\t            //console.log(height);\n\t            if (Math.abs(Y[minddY[j]]) > options.minMaxRatio*maxY) {\n\t                signals.push({\n\t                    i:minddY[j],\n\t                    x: frequency,\n\t                    y: (Y[minddY[j]]-yCorrection.b)/yCorrection.m,\n\t                    width:Math.abs(intervalR[possible] - intervalL[possible]),//widthCorrection\n\t                    soft:broadMask[j]\n\t                })\n\t            }\n\t        }\n\t    }\n\t\n\t\n\t    if(options.realTopDetection){\n\t        realTopDetection(signals,X,Y);\n\t    }\n\t\n\t    //Correct the values to fit the original spectra data\n\t    for(var j=0;j<signals.length;j++){\n\t        signals[j].base=options.noiseLevel;\n\t    }\n\t\n\t    signals.sort(function (a, b) {\n\t        return a.x - b.x;\n\t    });\n\t\n\t    return signals;\n\t\n\t}\n\t\n\tfunction getNoiseLevel(y){\n\t    var mean = 0,stddev=0;\n\t    var length = y.length,i=0;\n\t    for(i = 0; i < length; i++){\n\t        mean+=y[i];\n\t    }\n\t    mean/=length;\n\t    var averageDeviations = new Array(length);\n\t    for (i = 0; i < length; i++)\n\t        averageDeviations[i] = Math.abs(y[i] - mean);\n\t    averageDeviations.sort();\n\t    if (length % 2 == 1) {\n\t        stddev = averageDeviations[(length-1)/2] / 0.6745;\n\t    } else {\n\t        stddev = 0.5*(averageDeviations[length/2]+averageDeviations[length/2-1]) / 0.6745;\n\t    }\n\t\n\t    return stddev;\n\t}\n\t\n\tfunction realTopDetection(peakList, x, y){\n\t    //console.log(peakList);\n\t    //console.log(x);\n\t    //console.log(y);\n\t    var listP = [];\n\t    var alpha, beta, gamma, p,currentPoint;\n\t    for(var j=0;j<peakList.length;j++){\n\t        currentPoint = peakList[j].i;//peakList[j][2];\n\t        var tmp = currentPoint;\n\t        //The detected peak could be moved 1 or 2 unit to left or right.\n\t        if(y[currentPoint-1]>=y[currentPoint-2]\n\t            &&y[currentPoint-1]>=y[currentPoint]) {\n\t            currentPoint--;\n\t        }\n\t        else{\n\t            if(y[currentPoint+1]>=y[currentPoint]\n\t                &&y[currentPoint+1]>=y[currentPoint+2]) {\n\t                currentPoint++;\n\t            }\n\t            else{\n\t                if(y[currentPoint-2]>=y[currentPoint-3]\n\t                    &&y[currentPoint-2]>=y[currentPoint-1]) {\n\t                    currentPoint-=2;\n\t                }\n\t                else{\n\t                    if(y[currentPoint+2]>=y[currentPoint+1]\n\t                        &&y[currentPoint+2]>=y[currentPoint+3]) {\n\t                        currentPoint+=2;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        if(y[currentPoint-1]>0&&y[currentPoint+1]>0\n\t            &&y[currentPoint]>=y[currentPoint-1]\n\t            &&y[currentPoint]>=y[currentPoint+1]) {\n\t            alpha = 20 * Math.log10(y[currentPoint - 1]);\n\t            beta = 20 * Math.log10(y[currentPoint]);\n\t            gamma = 20 * Math.log10(y[currentPoint + 1]);\n\t            p = 0.5 * (alpha - gamma) / (alpha - 2 * beta + gamma);\n\t            //console.log(\"p: \"+p);\n\t            //console.log(x[currentPoint]+\" \"+tmp+\" \"+currentPoint);\n\t            peakList[j].x = x[currentPoint] + (x[currentPoint]-x[currentPoint-1])*p;\n\t            peakList[j].y = y[currentPoint] - 0.25 * (y[currentPoint - 1]\n\t                - y[currentPoint + 1]) * p;//signal.peaks[j].intensity);\n\t            //console.log(y[tmp]+\" \"+peakList[j].y);\n\t        }\n\t    }\n\t}\n\t\n\tmodule.exports=gsd;\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.array = __webpack_require__(4);\n\texports.matrix = __webpack_require__(38);\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar arrayStat = __webpack_require__(4);\n\t\n\t// https://github.com/accord-net/framework/blob/development/Sources/Accord.Statistics/Tools.cs\n\t\n\tfunction entropy(matrix, eps) {\n\t    if (typeof(eps) === 'undefined') {\n\t        eps = 0;\n\t    }\n\t    var sum = 0,\n\t        l1 = matrix.length,\n\t        l2 = matrix[0].length;\n\t    for (var i = 0; i < l1; i++) {\n\t        for (var j = 0; j < l2; j++) {\n\t            sum += matrix[i][j] * Math.log(matrix[i][j] + eps);\n\t        }\n\t    }\n\t    return -sum;\n\t}\n\t\n\tfunction mean(matrix, dimension) {\n\t    if (typeof(dimension) === 'undefined') {\n\t        dimension = 0;\n\t    }\n\t    var rows = matrix.length,\n\t        cols = matrix[0].length,\n\t        theMean, N, i, j;\n\t\n\t    if (dimension === -1) {\n\t        theMean = [0];\n\t        N = rows * cols;\n\t        for (i = 0; i < rows; i++) {\n\t            for (j = 0; j < cols; j++) {\n\t                theMean[0] += matrix[i][j];\n\t            }\n\t        }\n\t        theMean[0] /= N;\n\t    } else if (dimension === 0) {\n\t        theMean = new Array(cols);\n\t        N = rows;\n\t        for (j = 0; j < cols; j++) {\n\t            theMean[j] = 0;\n\t            for (i = 0; i < rows; i++) {\n\t                theMean[j] += matrix[i][j];\n\t            }\n\t            theMean[j] /= N;\n\t        }\n\t    } else if (dimension === 1) {\n\t        theMean = new Array(rows);\n\t        N = cols;\n\t        for (j = 0; j < rows; j++) {\n\t            theMean[j] = 0;\n\t            for (i = 0; i < cols; i++) {\n\t                theMean[j] += matrix[j][i];\n\t            }\n\t            theMean[j] /= N;\n\t        }\n\t    } else {\n\t        throw new Error('Invalid dimension');\n\t    }\n\t    return theMean;\n\t}\n\t\n\tfunction standardDeviation(matrix, means, unbiased) {\n\t    var vari = variance(matrix, means, unbiased), l = vari.length;\n\t    for (var i = 0; i < l; i++) {\n\t        vari[i] = Math.sqrt(vari[i]);\n\t    }\n\t    return vari;\n\t}\n\t\n\tfunction variance(matrix, means, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') {\n\t        unbiased = true;\n\t    }\n\t    means = means || mean(matrix);\n\t    var rows = matrix.length;\n\t    if (rows === 0) return [];\n\t    var cols = matrix[0].length;\n\t    var vari = new Array(cols);\n\t\n\t    for (var j = 0; j < cols; j++) {\n\t        var sum1 = 0, sum2 = 0, x = 0;\n\t        for (var i = 0; i < rows; i++) {\n\t            x = matrix[i][j] - means[j];\n\t            sum1 += x;\n\t            sum2 += x * x;\n\t        }\n\t        if (unbiased) {\n\t            vari[j] = (sum2 - ((sum1 * sum1) / rows)) / (rows - 1);\n\t        } else {\n\t            vari[j] = (sum2 - ((sum1 * sum1) / rows)) / rows;\n\t        }\n\t    }\n\t    return vari;\n\t}\n\t\n\tfunction median(matrix) {\n\t    var rows = matrix.length, cols = matrix[0].length;\n\t    var medians = new Array(cols);\n\t\n\t    for (var i = 0; i < cols; i++) {\n\t        var data = new Array(rows);\n\t        for (var j = 0; j < rows; j++) {\n\t            data[j] = matrix[j][i];\n\t        }\n\t        data.sort();\n\t        var N = data.length;\n\t        if (N % 2 === 0) {\n\t            medians[i] = (data[N / 2] + data[(N / 2) - 1]) * 0.5;\n\t        } else {\n\t            medians[i] = data[Math.floor(N / 2)];\n\t        }\n\t    }\n\t    return medians;\n\t}\n\t\n\tfunction mode(matrix) {\n\t    var rows = matrix.length,\n\t        cols = matrix[0].length,\n\t        modes = new Array(cols),\n\t        i, j;\n\t    for (i = 0; i < cols; i++) {\n\t        var itemCount = new Array(rows);\n\t        for (var k = 0; k < rows; k++) {\n\t            itemCount[k] = 0;\n\t        }\n\t        var itemArray = new Array(rows);\n\t        var count = 0;\n\t\n\t        for (j = 0; j < rows; j++) {\n\t            var index = itemArray.indexOf(matrix[j][i]);\n\t            if (index >= 0) {\n\t                itemCount[index]++;\n\t            } else {\n\t                itemArray[count] = matrix[j][i];\n\t                itemCount[count] = 1;\n\t                count++;\n\t            }\n\t        }\n\t\n\t        var maxValue = 0, maxIndex = 0;\n\t        for (j = 0; j < count; j++) {\n\t            if (itemCount[j] > maxValue) {\n\t                maxValue = itemCount[j];\n\t                maxIndex = j;\n\t            }\n\t        }\n\t\n\t        modes[i] = itemArray[maxIndex];\n\t    }\n\t    return modes;\n\t}\n\t\n\tfunction skewness(matrix, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') unbiased = true;\n\t    var means = mean(matrix);\n\t    var n = matrix.length, l = means.length;\n\t    var skew = new Array(l);\n\t\n\t    for (var j = 0; j < l; j++) {\n\t        var s2 = 0, s3 = 0;\n\t        for (var i = 0; i < n; i++) {\n\t            var dev = matrix[i][j] - means[j];\n\t            s2 += dev * dev;\n\t            s3 += dev * dev * dev;\n\t        }\n\t\n\t        var m2 = s2 / n;\n\t        var m3 = s3 / n;\n\t        var g = m3 / Math.pow(m2, 3 / 2);\n\t\n\t        if (unbiased) {\n\t            var a = Math.sqrt(n * (n - 1));\n\t            var b = n - 2;\n\t            skew[j] = (a / b) * g;\n\t        } else {\n\t            skew[j] = g;\n\t        }\n\t    }\n\t    return skew;\n\t}\n\t\n\tfunction kurtosis(matrix, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') unbiased = true;\n\t    var means = mean(matrix);\n\t    var n = matrix.length, m = matrix[0].length;\n\t    var kurt = new Array(m);\n\t\n\t    for (var j = 0; j < m; j++) {\n\t        var s2 = 0, s4 = 0;\n\t        for (var i = 0; i < n; i++) {\n\t            var dev = matrix[i][j] - means[j];\n\t            s2 += dev * dev;\n\t            s4 += dev * dev * dev * dev;\n\t        }\n\t        var m2 = s2 / n;\n\t        var m4 = s4 / n;\n\t\n\t        if (unbiased) {\n\t            var v = s2 / (n - 1);\n\t            var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n\t            var b = s4 / (v * v);\n\t            var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n\t            kurt[j] = a * b - 3 * c;\n\t        } else {\n\t            kurt[j] = m4 / (m2 * m2) - 3;\n\t        }\n\t    }\n\t    return kurt;\n\t}\n\t\n\tfunction standardError(matrix) {\n\t    var samples = matrix.length;\n\t    var standardDeviations = standardDeviation(matrix), l = standardDeviations.length;\n\t    var standardErrors = new Array(l);\n\t    var sqrtN = Math.sqrt(samples);\n\t\n\t    for (var i = 0; i < l; i++) {\n\t        standardErrors[i] = standardDeviations[i] / sqrtN;\n\t    }\n\t    return standardErrors;\n\t}\n\t\n\tfunction covariance(matrix, dimension) {\n\t    return scatter(matrix, undefined, dimension);\n\t}\n\t\n\tfunction scatter(matrix, divisor, dimension) {\n\t    if (typeof(dimension) === 'undefined') {\n\t        dimension = 0;\n\t    }\n\t    if (typeof(divisor) === 'undefined') {\n\t        if (dimension === 0) {\n\t            divisor = matrix.length - 1;\n\t        } else if (dimension === 1) {\n\t            divisor = matrix[0].length - 1;\n\t        }\n\t    }\n\t    var means = mean(matrix, dimension),\n\t        rows = matrix.length;\n\t    if (rows === 0) {\n\t        return [[]];\n\t    }\n\t    var cols = matrix[0].length,\n\t        cov, i, j, s, k;\n\t\n\t    if (dimension === 0) {\n\t        cov = new Array(cols);\n\t        for (i = 0; i < cols; i++) {\n\t            cov[i] = new Array(cols);\n\t        }\n\t        for (i = 0; i < cols; i++) {\n\t            for (j = i; j < cols; j++) {\n\t                s = 0;\n\t                for (k = 0; k < rows; k++) {\n\t                    s += (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);\n\t                }\n\t                s /= divisor;\n\t                cov[i][j] = s;\n\t                cov[j][i] = s;\n\t            }\n\t        }\n\t    } else if (dimension === 1) {\n\t        cov = new Array(rows);\n\t        for (i = 0; i < rows; i++) {\n\t            cov[i] = new Array(rows);\n\t        }\n\t        for (i = 0; i < rows; i++) {\n\t            for (j = i; j < rows; j++) {\n\t                s = 0;\n\t                for (k = 0; k < cols; k++) {\n\t                    s += (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);\n\t                }\n\t                s /= divisor;\n\t                cov[i][j] = s;\n\t                cov[j][i] = s;\n\t            }\n\t        }\n\t    } else {\n\t        throw new Error('Invalid dimension');\n\t    }\n\t\n\t    return cov;\n\t}\n\t\n\tfunction correlation(matrix) {\n\t    var means = mean(matrix),\n\t        standardDeviations = standardDeviation(matrix, true, means),\n\t        scores = zScores(matrix, means, standardDeviations),\n\t        rows = matrix.length,\n\t        cols = matrix[0].length,\n\t        i, j;\n\t\n\t    var cor = new Array(cols);\n\t    for (i = 0; i < cols; i++) {\n\t        cor[i] = new Array(cols);\n\t    }\n\t    for (i = 0; i < cols; i++) {\n\t        for (j = i; j < cols; j++) {\n\t            var c = 0;\n\t            for (var k = 0, l = scores.length; k < l; k++) {\n\t                c += scores[k][j] * scores[k][i];\n\t            }\n\t            c /= rows - 1;\n\t            cor[i][j] = c;\n\t            cor[j][i] = c;\n\t        }\n\t    }\n\t    return cor;\n\t}\n\t\n\tfunction zScores(matrix, means, standardDeviations) {\n\t    means = means || mean(matrix);\n\t    if (typeof(standardDeviations) === 'undefined') standardDeviations = standardDeviation(matrix, true, means);\n\t    return standardize(center(matrix, means, false), standardDeviations, true);\n\t}\n\t\n\tfunction center(matrix, means, inPlace) {\n\t    means = means || mean(matrix);\n\t    var result = matrix,\n\t        l = matrix.length,\n\t        i, j, jj;\n\t\n\t    if (!inPlace) {\n\t        result = new Array(l);\n\t        for (i = 0; i < l; i++) {\n\t            result[i] = new Array(matrix[i].length);\n\t        }\n\t    }\n\t\n\t    for (i = 0; i < l; i++) {\n\t        var row = result[i];\n\t        for (j = 0, jj = row.length; j < jj; j++) {\n\t            row[j] = matrix[i][j] - means[j];\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction standardize(matrix, standardDeviations, inPlace) {\n\t    if (typeof(standardDeviations) === 'undefined') standardDeviations = standardDeviation(matrix);\n\t    var result = matrix,\n\t        l = matrix.length,\n\t        i, j, jj;\n\t\n\t    if (!inPlace) {\n\t        result = new Array(l);\n\t        for (i = 0; i < l; i++) {\n\t            result[i] = new Array(matrix[i].length);\n\t        }\n\t    }\n\t\n\t    for (i = 0; i < l; i++) {\n\t        var resultRow = result[i];\n\t        var sourceRow = matrix[i];\n\t        for (j = 0, jj = resultRow.length; j < jj; j++) {\n\t            if (standardDeviations[j] !== 0 && !isNaN(standardDeviations[j])) {\n\t                resultRow[j] = sourceRow[j] / standardDeviations[j];\n\t            }\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction weightedVariance(matrix, weights) {\n\t    var means = mean(matrix);\n\t    var rows = matrix.length;\n\t    if (rows === 0) return [];\n\t    var cols = matrix[0].length;\n\t    var vari = new Array(cols);\n\t\n\t    for (var j = 0; j < cols; j++) {\n\t        var sum = 0;\n\t        var a = 0, b = 0;\n\t\n\t        for (var i = 0; i < rows; i++) {\n\t            var z = matrix[i][j] - means[j];\n\t            var w = weights[i];\n\t\n\t            sum += w * (z * z);\n\t            b += w;\n\t            a += w * w;\n\t        }\n\t\n\t        vari[j] = sum * (b / (b * b - a));\n\t    }\n\t\n\t    return vari;\n\t}\n\t\n\tfunction weightedMean(matrix, weights, dimension) {\n\t    if (typeof(dimension) === 'undefined') {\n\t        dimension = 0;\n\t    }\n\t    var rows = matrix.length;\n\t    if (rows === 0) return [];\n\t    var cols = matrix[0].length,\n\t        means, i, ii, j, w, row;\n\t\n\t    if (dimension === 0) {\n\t        means = new Array(cols);\n\t        for (i = 0; i < cols; i++) {\n\t            means[i] = 0;\n\t        }\n\t        for (i = 0; i < rows; i++) {\n\t            row = matrix[i];\n\t            w = weights[i];\n\t            for (j = 0; j < cols; j++) {\n\t                means[j] += row[j] * w;\n\t            }\n\t        }\n\t    } else if (dimension === 1) {\n\t        means = new Array(rows);\n\t        for (i = 0; i < rows; i++) {\n\t            means[i] = 0;\n\t        }\n\t        for (j = 0; j < rows; j++) {\n\t            row = matrix[j];\n\t            w = weights[j];\n\t            for (i = 0; i < cols; i++) {\n\t                means[j] += row[i] * w;\n\t            }\n\t        }\n\t    } else {\n\t        throw new Error('Invalid dimension');\n\t    }\n\t\n\t    var weightSum = arrayStat.sum(weights);\n\t    if (weightSum !== 0) {\n\t        for (i = 0, ii = means.length; i < ii; i++) {\n\t            means[i] /= weightSum;\n\t        }\n\t    }\n\t    return means;\n\t}\n\t\n\tfunction weightedCovariance(matrix, weights, means, dimension) {\n\t    dimension = dimension || 0;\n\t    means = means || weightedMean(matrix, weights, dimension);\n\t    var s1 = 0, s2 = 0;\n\t    for (var i = 0, ii = weights.length; i < ii; i++) {\n\t        s1 += weights[i];\n\t        s2 += weights[i] * weights[i];\n\t    }\n\t    var factor = s1 / (s1 * s1 - s2);\n\t    return weightedScatter(matrix, weights, means, factor, dimension);\n\t}\n\t\n\tfunction weightedScatter(matrix, weights, means, factor, dimension) {\n\t    dimension = dimension || 0;\n\t    means = means || weightedMean(matrix, weights, dimension);\n\t    if (typeof(factor) === 'undefined') {\n\t        factor = 1;\n\t    }\n\t    var rows = matrix.length;\n\t    if (rows === 0) {\n\t        return [[]];\n\t    }\n\t    var cols = matrix[0].length,\n\t        cov, i, j, k, s;\n\t\n\t    if (dimension === 0) {\n\t        cov = new Array(cols);\n\t        for (i = 0; i < cols; i++) {\n\t            cov[i] = new Array(cols);\n\t        }\n\t        for (i = 0; i < cols; i++) {\n\t            for (j = i; j < cols; j++) {\n\t                s = 0;\n\t                for (k = 0; k < rows; k++) {\n\t                    s += weights[k] * (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);\n\t                }\n\t                cov[i][j] = s * factor;\n\t                cov[j][i] = s * factor;\n\t            }\n\t        }\n\t    } else if (dimension === 1) {\n\t        cov = new Array(rows);\n\t        for (i = 0; i < rows; i++) {\n\t            cov[i] = new Array(rows);\n\t        }\n\t        for (i = 0; i < rows; i++) {\n\t            for (j = i; j < rows; j++) {\n\t                s = 0;\n\t                for (k = 0; k < cols; k++) {\n\t                    s += weights[k] * (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);\n\t                }\n\t                cov[i][j] = s * factor;\n\t                cov[j][i] = s * factor;\n\t            }\n\t        }\n\t    } else {\n\t        throw new Error('Invalid dimension');\n\t    }\n\t\n\t    return cov;\n\t}\n\t\n\tmodule.exports = {\n\t    entropy: entropy,\n\t    mean: mean,\n\t    standardDeviation: standardDeviation,\n\t    variance: variance,\n\t    median: median,\n\t    mode: mode,\n\t    skewness: skewness,\n\t    kurtosis: kurtosis,\n\t    standardError: standardError,\n\t    covariance: covariance,\n\t    scatter: scatter,\n\t    correlation: correlation,\n\t    zScores: zScores,\n\t    center: center,\n\t    standardize: standardize,\n\t    weightedVariance: weightedVariance,\n\t    weightedMean: weightedMean,\n\t    weightedCovariance: weightedCovariance,\n\t    weightedScatter: weightedScatter\n\t};\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//Code translate from Pascal source in http://pubs.acs.org/doi/pdf/10.1021/ac00205a007\n\tvar extend = __webpack_require__(1);\n\tvar stat = __webpack_require__(37);\n\t\n\tvar defaultOptions = {\n\t    windowSize: 9,\n\t    derivative: 0,\n\t    polynomial: 3,\n\t};\n\t\n\t\n\tfunction SavitzkyGolay(data, h, options) {\n\t    options = extend({}, defaultOptions, options);\n\t\n\t    if ((options.windowSize % 2 === 0) || (options.windowSize < 5) || !(Number.isInteger(options.windowSize)))\n\t            throw new RangeError('Invalid window size (should be odd and at least 5 integer number)')\n\t\n\t\n\t    if (options.windowSize>data.length)\n\t        throw new RangeError('Window size is higher than the data length '+options.windowSize+\">\"+data.length);\n\t    if ((options.derivative < 0) || !(Number.isInteger(options.derivative)))\n\t        throw new RangeError('Derivative should be a positive integer');\n\t    if ((options.polynomial < 1) || !(Number.isInteger(options.polynomial)))\n\t        throw new RangeError('Polynomial should be a positive integer');\n\t    if (options.polynomial >= 6)\n\t        console.warn('You should not use polynomial grade higher than 5 if you are' +\n\t            ' not sure that your data arises from such a model. Possible polynomial oscillation problems');\n\t\n\t    var windowSize = options.windowSize;\n\t\n\t    var half = Math.floor(windowSize/2);\n\t    var np = data.length;\n\t    var ans = new Array(np);\n\t    var weights = fullWeights(windowSize,options.polynomial,options.derivative);\n\t    var hs = 0;\n\t    var constantH = true;\n\t    if( Object.prototype.toString.call( h ) === '[object Array]' ) {\n\t        constantH = false;\n\t    }\n\t    else{\n\t        hs = Math.pow(h, options.derivative);\n\t    }\n\t    //console.log(\"Constant h: \"+constantH);\n\t    //For the borders\n\t    for(var i=0;i<half;i++){\n\t        var wg1=weights[half-i-1];\n\t        var wg2=weights[half+i+1];\n\t        var d1 = 0,d2=0;\n\t        for (var l = 0; l < windowSize; l++){\n\t            d1 += wg1[l] * data[l];\n\t            d2 += wg2[l] * data[np-windowSize+l-1];\n\t        }\n\t        if(constantH){\n\t            ans[half-i-1] = d1/hs;\n\t            ans[np-half+i] = d2/hs;\n\t        }\n\t        else{\n\t            hs = getHs(h,half-i-1,half, options.derivative);\n\t            ans[half-i-1] = d1/hs;\n\t            hs = getHs(h,np-half+i,half, options.derivative);\n\t            ans[np-half+i] = d2/hs;\n\t        }\n\t    }\n\t    //For the internal points\n\t    var wg = weights[half];\n\t    for(var i=windowSize;i<np+1;i++){\n\t        var d = 0;\n\t        for (var l = 0; l < windowSize; l++)\n\t            d += wg[l] * data[l+i-windowSize];\n\t        if(!constantH)\n\t            hs = getHs(h,i-half-1,half, options.derivative);\n\t        ans[i-half-1] = d/hs;\n\t    }\n\t    return ans;\n\t}\n\t\n\tfunction getHs(h,center,half,derivative){\n\t    var hs = 0;\n\t    var count = 0;\n\t    for(var i=center-half;i<center+half;i++){\n\t        if(i>=0 && i < h.length-1){\n\t            hs+= (h[i+1]-h[i]);\n\t            count++;\n\t        }\n\t    }\n\t    return Math.pow(hs/count,derivative);\n\t}\n\t\n\tfunction GramPoly(i,m,k,s){\n\t    var Grampoly = 0;\n\t    if(k>0){\n\t        Grampoly = (4*k-2)/(k*(2*m-k+1))*(i*GramPoly(i,m,k-1,s) +\n\t            s*GramPoly(i,m,k-1,s-1)) - ((k-1)*(2*m+k))/(k*(2*m-k+1))*GramPoly(i,m,k-2,s);\n\t    }\n\t    else{\n\t        if(k==0&&s==0){\n\t            Grampoly=1;\n\t        }\n\t        else{\n\t            Grampoly=0;\n\t        }\n\t    }\n\t    //console.log(Grampoly);\n\t    return Grampoly;\n\t}\n\t\n\tfunction GenFact(a,b){\n\t    var gf=1;\n\t    if(a>=b){\n\t        for(var j=a-b+1;j<=a;j++){\n\t            gf*=j;\n\t        }\n\t    }\n\t    return gf;\n\t}\n\t\n\tfunction Weight(i,t,m,n,s){\n\t    var sum=0;\n\t    for(var k=0;k<=n;k++){\n\t        //console.log(k);\n\t        sum+=(2*k+1)*(GenFact(2*m,k)/GenFact(2*m+k+1,k+1))*GramPoly(i,m,k,0)*GramPoly(t,m,k,s)\n\t    }\n\t    return sum;\n\t}\n\t\n\t/**\n\t *\n\t * @param m  Number of points\n\t * @param n  Polynomial grade\n\t * @param s  Derivative\n\t */\n\tfunction fullWeights(m,n,s){\n\t    var weights = new Array(m);\n\t    var np = Math.floor(m/2);\n\t    for(var t=-np;t<=np;t++){\n\t        weights[t+np] = new Array(m);\n\t        for(var j=-np;j<=np;j++){\n\t            weights[t+np][j+np]=Weight(j,t,np,n,s);\n\t        }\n\t    }\n\t    return weights;\n\t}\n\t\n\t/*function entropy(data,h,options){\n\t    var trend = SavitzkyGolay(data,h,trendOptions);\n\t    var copy = new Array(data.length);\n\t    var sum = 0;\n\t    var max = 0;\n\t    for(var i=0;i<data.length;i++){\n\t        copy[i] = data[i]-trend[i];\n\t    }\n\t\n\t    sum/=data.length;\n\t    console.log(sum+\" \"+max);\n\t    console.log(stat.array.standardDeviation(copy));\n\t    console.log(Math.abs(stat.array.mean(copy))/stat.array.standardDeviation(copy));\n\t    return sum;\n\t\n\t}\n\t\n\t\n\t\n\tfunction guessWindowSize(data, h){\n\t    console.log(\"entropy \"+entropy(data,h,trendOptions));\n\t    return 5;\n\t}\n\t*/\n\tmodule.exports = SavitzkyGolay;\n\t \n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar impuritiesList = [\n\t    {\"solvent\":\"CDCl3\",\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"ds\",\"shift\":7.26}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"bs\",\"shift\":1.56}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.1}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.17}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.1}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.36}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.28}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.19},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.22}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.98},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.01},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.27},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.43}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.26}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.43}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.73}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.3}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.21},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.48}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.65},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.57},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.39}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.4},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.55}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.09},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.02},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.94}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":8.02},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.96},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.88}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.62}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.71}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.25},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.72},{\"proton\":\"OH\",\"coupling\":5,\"multiplicity\":\"s,t\",\"shift\":1.32}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.05},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.12},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.26}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.14},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.46},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.06}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.76}],\"name\":\"ethylene_glycol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":0.86},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"br_s\",\"shift\":1.26}],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.88},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.26}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.65}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.49},{\"proton\":\"OH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.09}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.33}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":7},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.27}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.22},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":4.04}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.62},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.29},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.68}],\"name\":\"pyridine\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.07}],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.85},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.76}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.36},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.17},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.25}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.03},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.53}],\"name\":\"triethylamine\"}]},\n\t    {\"solvent\":\"(CD3)2CO\",\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":2.05}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.84}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.96}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.09}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.05}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.36}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.18}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.13},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.13}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.96},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.22},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.41}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":8.02}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.43}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.87}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.63}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.11},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.41}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.56},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.47},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.28}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.28},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.46}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.97},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.83}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.96},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.94},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.78}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.52}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.59}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.12},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.57},{\"proton\":\"OH\",\"coupling\":5,\"multiplicity\":\"s,t\",\"shift\":3.39}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.97},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.05},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.2}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.07},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.45},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.28}],\"name\":\"ethylene_glycol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":0.87},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"br_s\",\"shift\":1.29}],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.88},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.28}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.59}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.31},{\"proton\":\"OH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.12}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.43}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.88},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.27}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.1},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":3.9}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.58},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.35},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.76}],\"name\":\"pyridine\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.13}],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.79},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.63}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.32},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.5},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.5}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.45}],\"name\":\"triethylamine\"}]},\n\t    {\"solvent\":\"(CD3)2SO/DMSO\",\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"quint\",\"shift\":2.5}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.33}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.91}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.09}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.07}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.37}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.11},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.19}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.11},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.08}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.87},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.65},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.18},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.36}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":8.32}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.4}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.9}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.76}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.09},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.38}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.51},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.38},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.24}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.24},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.43}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.96},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.94},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.78}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.95},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.89},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.73}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.54}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.57}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.06},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.44},{\"proton\":\"OH\",\"coupling\":5,\"multiplicity\":\"s,t\",\"shift\":4.63}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.99},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.03},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.17}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.07},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.43},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.91}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.34}],\"name\":\"ethylene_glycol\"},{\"shifts\":[],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.86},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.25}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.53}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.16},{\"proton\":\"OH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.01}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.42}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.88},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.27}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.04},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":3.78}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.58},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.39},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.79}],\"name\":\"pyridine\"},{\"shifts\":[],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.76},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.6}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.3},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.18},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.25}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.93},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.43}],\"name\":\"triethylamine\"}]},\n\t    {\"solvent\":\"C6D6\",\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":7.16}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.4}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.55}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.55}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.55}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.15}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.05},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.55}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.07},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.04}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.05},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.79},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.24},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.38}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.15}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.4}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.9}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.27}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.11},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.26}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.46},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.34},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.11}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.12},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.33}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.6},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.57},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.05}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.63},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.36},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.86}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.68}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.35}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.34}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.65},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.89},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.92}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.58},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":1.81},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.85}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.41}],\"name\":\"ethylene_glycol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":0.92},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"br_s\",\"shift\":1.36}],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.89},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.24}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.4}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.07}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.94}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.86},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.23}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":0.95},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":3.67}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.53},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":6.66},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":6.98}],\"name\":\"pyridine\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.29}],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.4},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.57}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.11},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.02},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.13}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.4}],\"name\":\"triethylamine\"}]},\n\t    {\"solvent\":\"CD3CN\",\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":1.94}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.13}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.96}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.08}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.96}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.37}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.16},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.18}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.14},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.13}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.97},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.2},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.22},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.39}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.58}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.44}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.81}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.44}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.12},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.42}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.53},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.45},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.29}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.28},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.45}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.97},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.96},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.83}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.92},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.89},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.77}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.5}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.6}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.12},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.54},{\"proton\":\"OH\",\"coupling\":5,\"multiplicity\":\"s,t\",\"shift\":2.47}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.97},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.06},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.2}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.06},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.43},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.51}],\"name\":\"ethylene_glycol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":0.86},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"br_s\",\"shift\":1.27}],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.89},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.28}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.57}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.28},{\"proton\":\"OH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.16}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.31}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.87},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.29}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.09},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":3.87}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.57},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.33},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.73}],\"name\":\"pyridine\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.08}],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.8},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.64}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.33},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.2},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.2}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.45}],\"name\":\"triethylamine\"}]},\n\t    {\"solvent\":\"CD3OD\",\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":3.31}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.87}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.99}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.15}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.03}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.33}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.4}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.15},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.2}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.92},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.21},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.4}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.9}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.45}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.78}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.49}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.18},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.49}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.61},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.58},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.35}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.35},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.52}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.07},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.31},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.92}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.97},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.99},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.86}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.65}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.66}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.19},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.6}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.01},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.09},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.24}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.12},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.5},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.01}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.59}],\"name\":\"ethylene_glycol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":0.88},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"br_s\",\"shift\":1.29}],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.9},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.29}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.64}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.34}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.34}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.89},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.29}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.5},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":3.92}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.53},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.44},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.85}],\"name\":\"pyridine\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.1}],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.87},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.71}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.32},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.16},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.16}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.05},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.58}],\"name\":\"triethylamine\"}]},\n\t    {\"solvent\":\"D2O\",\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":4.79}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.08}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.22}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.06}],\"name\":\"acetonitrile\"},{\"shifts\":[],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.24}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.21},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.22}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[],\"name\":\"BHTb\"},{\"shifts\":[],\"name\":\"chloroform\"},{\"shifts\":[],\"name\":\"cyclohexane\"},{\"shifts\":[],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.17},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.56}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.67},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.61},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.37}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.37},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.6}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.08},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.06},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.9}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.92},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.01},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.85}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.71}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.75}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.17},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.65}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.07},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.14},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.24}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.19},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.18},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.26}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.65}],\"name\":\"ethylene_glycol\"},{\"shifts\":[],\"name\":\"grease^f\"},{\"shifts\":[],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.61}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.34}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.4}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.9}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.17},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":4.02}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.52},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.45},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.87}],\"name\":\"pyridine\"},{\"shifts\":[],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.88},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.74}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.99},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.57}],\"name\":\"triethylamine\"}]}];\n\t\n\tvar look4 = \"solvent_residual_peak\"+\"H2O\"+\"TMS\";\n\tvar pascalTriangle = [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]];\n\tvar patterns = [\"s\",\"d\",\"t\",\"q\",\"quint\",\"h\",\"sept\",\"o\",\"n\"];\n\t\n\tfunction removeSignal(peak, noiseSignal){\n\t\n\t}\n\t\n\tfunction checkImpurity(peakList, impurity){\n\t    var error = 0.025,i;\n\t    var found = false;\n\t    var indexes = new Array(impurity.length);\n\t    for(i=0;i<impurity.length;i++){\n\t        found=false;\n\t        for(var j=0;j<peakList.length;j++){\n\t            if(Math.abs(impurity[i].shift-peakList[j].delta1)<\n\t                (error+Math.abs(peakList[j].startX-peakList[j].stopX)/2)&&\n\t                (impurity[i].multiplicity===\"\"||\n\t                (impurity[i].multiplicity.indexOf(peakList[j].multiplicity)>=0&&!peakList[j].asymmetric))){\n\t                found = true;\n\t                indexes[i]=j;\n\t                break;\n\t            }\n\t        }\n\t        if(!found)\n\t            break;\n\t    }\n\t\n\t    var toRemove = [];\n\t    if(found){\n\t        for(i=0;i<impurity.length;i++){\n\t            toRemove.push(indexes[i]);\n\t        }\n\t    }\n\t    else\n\t        return 0;\n\t    for(i=0;i<toRemove.length;i++){\n\t        peakList[toRemove[i]].integralData.value = 0;\n\t    }\n\t    return 1;\n\t}\n\t\n\tfunction removeImpurities(peakList, solvent, nH){\n\t    var impurities = null, i;\n\t    for(i=0;i<impuritiesList.length;i++){\n\t        if(impuritiesList[i].solvent.indexOf(solvent)>=0){\n\t            impurities = impuritiesList[i].impurities;\n\t            break;\n\t        }\n\t    }\n\t    impurities.push({\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":0.0}],\"name\":\"TMS\"});\n\t    var nCols = peakList.length;\n\t    var nRows = impurities.length;\n\t    var scores = new Array(nRows);\n\t    for(i=0;i<nRows;i++){\n\t        if( look4.indexOf(impurities[i].name)>=0){\n\t            scores[i]=checkImpurity(peakList, impurities[i].shifts);\n\t        }\n\t    }\n\t    //Recompute the integrals\n\t    var sumObserved=0;\n\t    for(i=0;i<peakList.length;i++){\n\t        sumObserved+=peakList[i].integralData.value;\n\t    }\n\t    if(sumObserved!=nH){\n\t        sumObserved=nH/sumObserved;\n\t        for(i=0;i<peakList.length;i++){\n\t            peakList[i].integralData.value*=sumObserved;\n\t        }\n\t    }\n\t}\n\t\n\tmodule.exports = removeImpurities;\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.FFTUtils = __webpack_require__(42);\n\texports.FFT = __webpack_require__(43);\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar FFT = __webpack_require__(43);\n\t\n\tvar FFTUtils= {\n\t    DEBUG : false,\n\t\n\t    /**\n\t     * Calculates the inverse of a 2D Fourier transform\n\t     *\n\t     * @param ft\n\t     * @param ftRows\n\t     * @param ftCols\n\t     * @return\n\t     */\n\t    ifft2DArray : function(ft, ftRows, ftCols){\n\t        var tempTransform = new Array(ftRows * ftCols);\n\t        var nRows = ftRows / 2;\n\t        var nCols = (ftCols - 1) * 2;\n\t        // reverse transform columns\n\t        FFT.init(nRows);\n\t        var tmpCols = {re: new Array(nRows), im: new Array(nRows)};\n\t        for (var iCol = 0; iCol < ftCols; iCol++) {\n\t            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n\t                tmpCols.re[iRow] = ft[(iRow * 2) * ftCols + iCol];\n\t                tmpCols.im[iRow] = ft[(iRow * 2 + 1) * ftCols + iCol];\n\t            }\n\t            //Unnormalized inverse transform\n\t            FFT.bt(tmpCols.re, tmpCols.im);\n\t            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n\t                tempTransform[(iRow * 2) * ftCols + iCol] = tmpCols.re[iRow];\n\t                tempTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n\t            }\n\t        }\n\t\n\t        // reverse row transform\n\t        var finalTransform = new Array(nRows * nCols);\n\t        FFT.init(nCols);\n\t        var tmpRows = {re: new Array(nCols), im: new Array(nCols)};\n\t        var scale = nCols * nRows;\n\t        for (var iRow = 0; iRow < ftRows; iRow += 2) {\n\t            tmpRows.re[0] = tempTransform[iRow * ftCols];\n\t            tmpRows.im[0] = tempTransform[(iRow + 1) * ftCols];\n\t            for (var iCol = 1; iCol < ftCols; iCol++) {\n\t                tmpRows.re[iCol] = tempTransform[iRow * ftCols + iCol];\n\t                tmpRows.im[iCol] = tempTransform[(iRow + 1) * ftCols + iCol];\n\t                tmpRows.re[nCols - iCol] = tempTransform[iRow * ftCols + iCol];\n\t                tmpRows.im[nCols - iCol] = -tempTransform[(iRow + 1) * ftCols + iCol];\n\t            }\n\t            //Unnormalized inverse transform\n\t            FFT.bt(tmpRows.re, tmpRows.im);\n\t\n\t            var indexB = (iRow / 2) * nCols;\n\t            for (var iCol = nCols - 1; iCol >= 0; iCol--) {\n\t                finalTransform[indexB + iCol] = tmpRows.re[iCol] / scale;\n\t            }\n\t        }\n\t        return finalTransform;\n\t    },\n\t    /**\n\t     * Calculates the fourier transform of a matrix of size (nRows,nCols) It is\n\t     * assumed that both nRows and nCols are a power of two\n\t     *\n\t     * On exit the matrix has dimensions (nRows * 2, nCols / 2 + 1) where the\n\t     * even rows contain the real part and the odd rows the imaginary part of the\n\t     * transform\n\t     * @param data\n\t     * @param nRows\n\t     * @param nCols\n\t     * @return\n\t     */\n\t    fft2DArray:function(data, nRows, nCols) {\n\t        var ftCols = (nCols / 2 + 1);\n\t        var ftRows = nRows * 2;\n\t        var tempTransform = new Array(ftRows * ftCols);\n\t        FFT.init(nCols);\n\t        // transform rows\n\t        var tmpRows = {re: new Array(nCols), im: new Array(nCols)};\n\t        var row1 = {re: new Array(nCols), im: new Array(nCols)}\n\t        var row2 = {re: new Array(nCols), im: new Array(nCols)}\n\t        var index, iRow0, iRow1, iRow2, iRow3;\n\t        for (var iRow = 0; iRow < nRows / 2; iRow++) {\n\t            index = (iRow * 2) * nCols;\n\t            tmpRows.re = data.slice(index, index + nCols);\n\t\n\t            index = (iRow * 2 + 1) * nCols;\n\t            tmpRows.im = data.slice(index, index + nCols);\n\t\n\t            FFT.fft1d(tmpRows.re, tmpRows.im);\n\t\n\t            this.reconstructTwoRealFFT(tmpRows, row1, row2);\n\t            //Now lets put back the result into the output array\n\t            iRow0 = (iRow * 4) * ftCols;\n\t            iRow1 = (iRow * 4 + 1) * ftCols;\n\t            iRow2 = (iRow * 4 + 2) * ftCols;\n\t            iRow3 = (iRow * 4 + 3) * ftCols;\n\t            for (var k = ftCols - 1; k >= 0; k--) {\n\t                tempTransform[iRow0 + k] = row1.re[k];\n\t                tempTransform[iRow1 + k] = row1.im[k];\n\t                tempTransform[iRow2 + k] = row2.re[k];\n\t                tempTransform[iRow3 + k] = row2.im[k];\n\t            }\n\t        }\n\t\n\t        //console.log(tempTransform);\n\t        row1 = null;\n\t        row2 = null;\n\t        // transform columns\n\t        var finalTransform = new Array(ftRows * ftCols);\n\t        FFT.init(nRows);\n\t        var tmpCols = {re: new Array(nRows), im: new Array(nRows)};\n\t        for (var iCol = ftCols - 1; iCol >= 0; iCol--) {\n\t            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n\t                tmpCols.re[iRow] = tempTransform[(iRow * 2) * ftCols + iCol];\n\t                tmpCols.im[iRow] = tempTransform[(iRow * 2 + 1) * ftCols + iCol];\n\t            }\n\t            FFT.fft1d(tmpCols.re, tmpCols.im);\n\t            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n\t                finalTransform[(iRow * 2) * ftCols + iCol] = tmpCols.re[iRow];\n\t                finalTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n\t            }\n\t        }\n\t\n\t        //console.log(finalTransform);\n\t        return finalTransform;\n\t\n\t    },\n\t    /**\n\t     *\n\t     * @param fourierTransform\n\t     * @param realTransform1\n\t     * @param realTransform2\n\t     *\n\t     * Reconstructs the individual Fourier transforms of two simultaneously\n\t     * transformed series. Based on the Symmetry relationships (the asterisk\n\t     * denotes the complex conjugate)\n\t     *\n\t     * F_{N-n} = F_n^{*} for a purely real f transformed to F\n\t     *\n\t     * G_{N-n} = G_n^{*} for a purely imaginary g transformed to G\n\t     *\n\t     */\n\t    reconstructTwoRealFFT:function(fourierTransform, realTransform1, realTransform2) {\n\t        var length = fourierTransform.re.length;\n\t\n\t        // the components n=0 are trivial\n\t        realTransform1.re[0] = fourierTransform.re[0];\n\t        realTransform1.im[0] = 0.0;\n\t        realTransform2.re[0] = fourierTransform.im[0];\n\t        realTransform2.im[0] = 0.0;\n\t        var rm, rp, im, ip, j;\n\t        for (var i = length / 2; i > 0; i--) {\n\t            j = length - i;\n\t            rm = 0.5 * (fourierTransform.re[i] - fourierTransform.re[j]);\n\t            rp = 0.5 * (fourierTransform.re[i] + fourierTransform.re[j]);\n\t            im = 0.5 * (fourierTransform.im[i] - fourierTransform.im[j]);\n\t            ip = 0.5 * (fourierTransform.im[i] + fourierTransform.im[j]);\n\t            realTransform1.re[i] = rp;\n\t            realTransform1.im[i] = im;\n\t            realTransform1.re[j] = rp;\n\t            realTransform1.im[j] = -im;\n\t            realTransform2.re[i] = ip;\n\t            realTransform2.im[i] = -rm;\n\t            realTransform2.re[j] = ip;\n\t            realTransform2.im[j] = rm;\n\t        }\n\t    },\n\t\n\t    /**\n\t     * In place version of convolute 2D\n\t     *\n\t     * @param ftSignal\n\t     * @param ftFilter\n\t     * @param ftRows\n\t     * @param ftCols\n\t     * @return\n\t     */\n\t    convolute2DI:function(ftSignal, ftFilter, ftRows, ftCols) {\n\t        var re, im;\n\t        for (var iRow = 0; iRow < ftRows / 2; iRow++) {\n\t            for (var iCol = 0; iCol < ftCols; iCol++) {\n\t                //\n\t                re = ftSignal[(iRow * 2) * ftCols + iCol]\n\t                * ftFilter[(iRow * 2) * ftCols + iCol]\n\t                - ftSignal[(iRow * 2 + 1) * ftCols + iCol]\n\t                * ftFilter[(iRow * 2 + 1) * ftCols + iCol];\n\t                im = ftSignal[(iRow * 2) * ftCols + iCol]\n\t                * ftFilter[(iRow * 2 + 1) * ftCols + iCol]\n\t                + ftSignal[(iRow * 2 + 1) * ftCols + iCol]\n\t                * ftFilter[(iRow * 2) * ftCols + iCol];\n\t                //\n\t                ftSignal[(iRow * 2) * ftCols + iCol] = re;\n\t                ftSignal[(iRow * 2 + 1) * ftCols + iCol] = im;\n\t            }\n\t        }\n\t    },\n\t    /**\n\t     *\n\t     * @param data\n\t     * @param kernel\n\t     * @param nRows\n\t     * @param nCols\n\t     * @returns {*}\n\t     */\n\t    convolute:function(data, kernel, nRows, nCols){\n\t        var ftSpectrum = new Array(nCols * nRows);\n\t        for (var i = 0; i<nRows * nCols; i++){\n\t            ftSpectrum[i] = data[i];\n\t        }\n\t\n\t        ftSpectrum = this.fft2DArray(ftSpectrum, nRows, nCols);\n\t\n\t        var dim = kernel.length;\n\t        var ftFilterData = new Array(nCols * nRows);\n\t        for(var i=0;i<nCols * nRows;i++){\n\t            ftFilterData[i]=0;\n\t        }\n\t\n\t        var iRow, iCol;\n\t        var shift = (dim - 1) / 2;\n\t        //console.log(dim);\n\t        for (var ir = 0; ir < dim; ir++) {\n\t            iRow = (ir - shift + nRows) % nRows;\n\t            for (var ic = 0; ic < dim; ic++) {\n\t                iCol = (ic - shift + nCols) % nCols;\n\t                ftFilterData[iRow * nCols + iCol] = kernel[ir][ic];\n\t            }\n\t        }\n\t\n\t        ftFilterData = this.fft2DArray(ftFilterData, nRows, nCols);\n\t\n\t        var ftRows = nRows * 2;\n\t        var ftCols = nCols / 2 + 1;\n\t        this.convolute2DI(ftSpectrum, ftFilterData, ftRows, ftCols);\n\t\n\t        return  this.ifft2DArray(ftSpectrum, ftRows, ftCols);\n\t    }\n\t}\n\t\n\tmodule.exports = FFTUtils;\n\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Fast Fourier Transform module\n\t * 1D-FFT/IFFT, 2D-FFT/IFFT (radix-2)\n\t */\n\tvar FFT = (function(){\n\t  var FFT;  \n\t  \n\t  if(true) {\n\t    FFT = exports;   // for CommonJS\n\t  } else {\n\t    FFT = {};\n\t  }\n\t  \n\t  var version = {\n\t    release: '0.3.0',\n\t    date: '2013-03'\n\t  };\n\t  FFT.toString = function() {\n\t    return \"version \" + version.release + \", released \" + version.date;\n\t  };\n\t\n\t  // core operations\n\t  var _n = 0,          // order\n\t      _bitrev = null,  // bit reversal table\n\t      _cstb = null;    // sin/cos table\n\t\n\t  var core = {\n\t    init : function(n) {\n\t      if(n !== 0 && (n & (n - 1)) === 0) {\n\t        _n = n;\n\t        core._initArray();\n\t        core._makeBitReversalTable();\n\t        core._makeCosSinTable();\n\t      } else {\n\t        throw new Error(\"init: radix-2 required\");\n\t      }\n\t    },\n\t    // 1D-FFT\n\t    fft1d : function(re, im) {\n\t      core.fft(re, im, 1);\n\t    },\n\t    // 1D-IFFT\n\t    ifft1d : function(re, im) {\n\t      var n = 1/_n;\n\t      core.fft(re, im, -1);\n\t      for(var i=0; i<_n; i++) {\n\t        re[i] *= n;\n\t        im[i] *= n;\n\t      }\n\t    },\n\t     // 1D-IFFT\n\t    bt1d : function(re, im) {\n\t      core.fft(re, im, -1);\n\t    },\n\t    // 2D-FFT Not very useful if the number of rows have to be equal to cols\n\t    fft2d : function(re, im) {\n\t      var tre = [],\n\t          tim = [],\n\t          i = 0;\n\t      // x-axis\n\t      for(var y=0; y<_n; y++) {\n\t        i = y*_n;\n\t        for(var x1=0; x1<_n; x1++) {\n\t          tre[x1] = re[x1 + i];\n\t          tim[x1] = im[x1 + i];\n\t        }\n\t        core.fft1d(tre, tim);\n\t        for(var x2=0; x2<_n; x2++) {\n\t          re[x2 + i] = tre[x2];\n\t          im[x2 + i] = tim[x2];\n\t        }\n\t      }\n\t      // y-axis\n\t      for(var x=0; x<_n; x++) {\n\t        for(var y1=0; y1<_n; y1++) {\n\t          i = x + y1*_n;\n\t          tre[y1] = re[i];\n\t          tim[y1] = im[i];\n\t        }\n\t        core.fft1d(tre, tim);\n\t        for(var y2=0; y2<_n; y2++) {\n\t          i = x + y2*_n;\n\t          re[i] = tre[y2];\n\t          im[i] = tim[y2];\n\t        }\n\t      }\n\t    },\n\t    // 2D-IFFT\n\t    ifft2d : function(re, im) {\n\t      var tre = [],\n\t          tim = [],\n\t          i = 0;\n\t      // x-axis\n\t      for(var y=0; y<_n; y++) {\n\t        i = y*_n;\n\t        for(var x1=0; x1<_n; x1++) {\n\t          tre[x1] = re[x1 + i];\n\t          tim[x1] = im[x1 + i];\n\t        }\n\t        core.ifft1d(tre, tim);\n\t        for(var x2=0; x2<_n; x2++) {\n\t          re[x2 + i] = tre[x2];\n\t          im[x2 + i] = tim[x2];\n\t        }\n\t      }\n\t      // y-axis\n\t      for(var x=0; x<_n; x++) {\n\t        for(var y1=0; y1<_n; y1++) {\n\t          i = x + y1*_n;\n\t          tre[y1] = re[i];\n\t          tim[y1] = im[i];\n\t        }\n\t        core.ifft1d(tre, tim);\n\t        for(var y2=0; y2<_n; y2++) {\n\t          i = x + y2*_n;\n\t          re[i] = tre[y2];\n\t          im[i] = tim[y2];\n\t        }\n\t      }\n\t    },\n\t    // core operation of FFT\n\t    fft : function(re, im, inv) {\n\t      var d, h, ik, m, tmp, wr, wi, xr, xi,\n\t          n4 = _n >> 2;\n\t      // bit reversal\n\t      for(var l=0; l<_n; l++) {\n\t        m = _bitrev[l];\n\t        if(l < m) {\n\t          tmp = re[l];\n\t          re[l] = re[m];\n\t          re[m] = tmp;\n\t          tmp = im[l];\n\t          im[l] = im[m];\n\t          im[m] = tmp;\n\t        }\n\t      }\n\t      // butterfly operation\n\t      for(var k=1; k<_n; k<<=1) {\n\t        h = 0;\n\t        d = _n/(k << 1);\n\t        for(var j=0; j<k; j++) {\n\t          wr = _cstb[h + n4];\n\t          wi = inv*_cstb[h];\n\t          for(var i=j; i<_n; i+=(k<<1)) {\n\t            ik = i + k;\n\t            xr = wr*re[ik] + wi*im[ik];\n\t            xi = wr*im[ik] - wi*re[ik];\n\t            re[ik] = re[i] - xr;\n\t            re[i] += xr;\n\t            im[ik] = im[i] - xi;\n\t            im[i] += xi;\n\t          }\n\t          h += d;\n\t        }\n\t      }\n\t    },\n\t    // initialize the array (supports TypedArray)\n\t    _initArray : function() {\n\t      if(typeof Uint32Array !== 'undefined') {\n\t        _bitrev = new Uint32Array(_n);\n\t      } else {\n\t        _bitrev = [];\n\t      }\n\t      if(typeof Float64Array !== 'undefined') {\n\t        _cstb = new Float64Array(_n*1.25);\n\t      } else {\n\t        _cstb = [];\n\t      }\n\t    },\n\t    // zero padding\n\t    _paddingZero : function() {\n\t      // TODO\n\t    },\n\t    // makes bit reversal table\n\t    _makeBitReversalTable : function() {\n\t      var i = 0,\n\t          j = 0,\n\t          k = 0;\n\t      _bitrev[0] = 0;\n\t      while(++i < _n) {\n\t        k = _n >> 1;\n\t        while(k <= j) {\n\t          j -= k;\n\t          k >>= 1;\n\t        }\n\t        j += k;\n\t        _bitrev[i] = j;\n\t      }\n\t    },\n\t    // makes trigonometiric function table\n\t    _makeCosSinTable : function() {\n\t      var n2 = _n >> 1,\n\t          n4 = _n >> 2,\n\t          n8 = _n >> 3,\n\t          n2p4 = n2 + n4,\n\t          t = Math.sin(Math.PI/_n),\n\t          dc = 2*t*t,\n\t          ds = Math.sqrt(dc*(2 - dc)),\n\t          c = _cstb[n4] = 1,\n\t          s = _cstb[0] = 0;\n\t      t = 2*dc;\n\t      for(var i=1; i<n8; i++) {\n\t        c -= dc;\n\t        dc += t*c;\n\t        s += ds;\n\t        ds -= t*s;\n\t        _cstb[i] = s;\n\t        _cstb[n4 - i] = c;\n\t      }\n\t      if(n8 !== 0) {\n\t        _cstb[n8] = Math.sqrt(0.5);\n\t      }\n\t      for(var j=0; j<n4; j++) {\n\t        _cstb[n2 - j]  = _cstb[j];\n\t      }\n\t      for(var k=0; k<n2p4; k++) {\n\t        _cstb[k + n2] = -_cstb[k];\n\t      }\n\t    }\n\t  };\n\t  // aliases (public APIs)\n\t  var apis = ['init', 'fft1d', 'ifft1d', 'fft2d', 'ifft2d'];\n\t  for(var i=0; i<apis.length; i++) {\n\t    FFT[apis[i]] = core[apis[i]];\n\t  }\n\t  FFT.bt = core.bt1d;\n\t  FFT.fft = core.fft1d;\n\t  FFT.ifft = core.ifft1d;\n\t  \n\t  return FFT;\n\t}).call(this);\n\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Created by abol on 4/20/16.\n\t */\n\tmodule.exports.fourierTransform = __webpack_require__(45);\n\tmodule.exports.zeroFilling = __webpack_require__(46);\n\tmodule.exports.apodization = __webpack_require__(47);\n\tmodule.exports.phaseCorrection = __webpack_require__(48);\n\tmodule.exports.digitalFilter = __webpack_require__(49);\n\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Created by abol on 4/20/16.\n\t */\n\tvar fft = __webpack_require__(41);\n\t\n\tfunction fourierTransform(spectraData){\n\t    //console.log(spectraData);\n\t\n\t    var nbPoints = spectraData.getNbPoints();\n\t    var nSubSpectra = spectraData.getNbSubSpectra() / 2;\n\t    var spectraType = \"NMR SPECTRUM\";//spectraData.TYPE_NMR_SPECTRUM;\n\t    var FFT = fft.FFT;\n\t    if (nSubSpectra > 1)\n\t        spectraType = \"nD NMR SPECTRUM\";//spectraData.TYPE_2DNMR_SPECTRUM;\n\t\n\t    FFT.init(nbPoints);\n\t\n\t\n\t    var fcor = spectraData.getParamDouble(\"$FCOR\", 0.0);\n\t    //var tempArray = new Array(nbPoints / 2);\n\t    for (var iSubSpectra = 0; iSubSpectra < nSubSpectra; iSubSpectra++)\n\t    {\n\t        var re = spectraData.getYData(2 * iSubSpectra);\n\t        var im = spectraData.getYData(2 * iSubSpectra + 1);\n\t        if (false) {\n\t            console.log(\"firstPoint: (\" + re[0] + \",\" + im[0] + \")\");\n\t            console.log(\"fcor: \" + fcor);\n\t        }\n\t        re[0] *= fcor;\n\t        im[0] *= fcor;\n\t\n\t        FFT.fft(re, im);\n\t        re = re.concat(re.slice(0,(nbPoints+1)/2));\n\t        re.splice(0, (nbPoints+1)/2);\n\t        im = im.concat(im.slice(0,(nbPoints+1)/2));\n\t        im.splice(0, (nbPoints+1)/2);\n\t\n\t        spectraData.setActiveElement(2 * iSubSpectra);\n\t        updateSpectra(spectraData, spectraType);\n\t\n\t        spectraData.setActiveElement(2 * iSubSpectra + 1);\n\t        updateSpectra(spectraData, spectraType);\n\t    }\n\t    //TODO For Alejandro\n\t    //Now we can try to apply the FFt on the second dimension\n\t    if(spectraData.is2D()){\n\t        var mode = spectraData.getParam(\".ACQUISITION SCHEME\");\n\t        switch(mode){\n\t            case 1://\"State-TPP\"\n\t                break;\n\t            case 2://State\n\t                break;\n\t            case 3://Echo-Antiecho\n\t                break;\n\t            defaut:\n\t                //QF\n\t                //Does not transform in the indirect dimension\n\t            break;\n\t\n\t        }\n\t    }\n\t    spectraData.setActiveElement(0);\n\t    return spectraData;\n\t}\n\t\n\tfunction updateSpectra(spectraData, spectraType){\n\t    var baseFrequency = spectraData.getParamDouble(\"$BF1\", NaN);\n\t    var spectralFrequency = spectraData.getParamDouble(\"$SFO1\", NaN);\n\t    var spectralWidth = spectraData.getParamDouble(\"$SW\", NaN);\n\t    var xMiddle = ((spectralFrequency - baseFrequency) / baseFrequency )* 1e6;\n\t    var dx = 0.5 * spectralWidth * spectralFrequency / baseFrequency;\n\t\n\t    spectraData.setDataType(spectraType);\n\t    spectraData.setFirstX(xMiddle + dx);\n\t    spectraData.setLastX(xMiddle - dx);\n\t    spectraData.setXUnits(\"PPM\");\n\t\n\t    var x = spectraData.getXData();\n\t    var tmp = xMiddle + dx;\n\t    dx = -2*dx/(x.length-1);\n\t    for(var i=0;i< x.length;i++){\n\t        x[i]= tmp;\n\t        tmp+=dx;\n\t    }\n\t\n\t    //TODO update minmax in Y axis\n\t}\n\t\n\tmodule.exports = fourierTransform;\n\n/***/ },\n/* 46 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t/**\n\t * Created by abol on 4/20/16.\n\t */\n\t\n\tfunction zeroFilling(spectraData, zeroFillingX, zeroFillingY){\n\t    var nbSubSpectra = spectraData.getNbSubSpectra();\n\t    //var zeroPadding = spectraData.getParamDouble(\"$$ZEROPADDING\", 0);\n\t    var nbXPoints, lastX, deltaX, k, x, y;\n\t    if (zeroFillingX != 0){\n\t        for (var iSubSpectra = 0 ; iSubSpectra < nbSubSpectra; iSubSpectra++){\n\t            spectraData.setActiveElement(iSubSpectra);\n\t            nbXPoints = spectraData.getNbPoints();\n\t            y = spectraData.getYData();\n\t            x = spectraData.getXData();\n\t            lastX = spectraData.getLastX();\n\t            deltaX = (lastX-x[0])/(nbXPoints-1);\n\t            for (k = nbXPoints; k < zeroFillingX; k++){\n\t                y.push(0);\n\t                x.push(lastX+deltaX);\n\t            }\n\t            if (zeroFillingX < nbXPoints){\n\t                y.splice(zeroFillingX, y.length-1);\n\t                x.splice(zeroFillingX, x.length-1);\n\t            }\n\t            spectraData.setFirstX(x[0]);\n\t            spectraData.setLastX(x[x.length-1]);\n\t        }\n\t    }\n\t    spectraData.setActiveElement(0);\n\t    return spectraData;\n\t    // @TODO implement zeroFillingY\n\t}\n\tmodule.exports = zeroFilling;\n\n/***/ },\n/* 47 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t/**\n\t * Created by acastillo on 4/26/16.\n\t */\n\t\n\tfunction apodization(spectraData, parameters){\n\t    //org.cheminfo.hook.nemo.filters.ApodizationFilter\n\t\n\t    /*public String toString() {\n\t     switch (this) {\n\t     case NONE:\n\t     return \"None\";\n\t     case EXPONENTIAL:\n\t     return \"Exponential\";\n\t     case GAUSSIAN:\n\t     return \"Gaussian\";\n\t     case TRAF:\n\t     return \"TRAF\";\n\t     case SINE_BELL:\n\t     return \"Sine Bell\";\n\t     case SINE_BELL_SQUARED:\n\t     return \"Sine Bell Squared\";\n\t     default:\n\t     return \"\";\n\t     }\n\t     }*/\n\t}\n\t\n\tmodule.exports = apodization;\n\n/***/ },\n/* 48 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t/**\n\t * Created by acastillo on 4/26/16.\n\t */\n\tfunction phaseCorrection(spectraData, phi0, phi1){\n\t    //System.out.println(spectraData.toString());\n\t    var nbPoints = spectraData.getNbPoints();\n\t    var reData = spectraData.getYData(0);\n\t    var imData = spectraData.getYData(1);\n\t    //var corrections = spectraData.getParam(\"corrections\");\n\t\n\t    //for(var k=0;k<corrections.length;k++){\n\t    //    Point2D phi = corrections.elementAt(k);\n\t\n\t        //double phi0 = phi.getX();\n\t        //double phi1 = phi.getY();\n\t\n\t    if(false) System.out.println(\" ph0 = \"+phi0);\n\t    if(false) System.out.println(\" ph1 = \"+phi1);\n\t\n\t    var delta = phi1 / nbPoints;\n\t    var alpha = 2 * Math.pow(Math.sin(delta / 2), 2);\n\t    var beta = Math.sin(delta);\n\t    var cosTheta = Math.cos(phi0);\n\t    var sinTheta = Math.sin(phi0);\n\t    var cosThetaNew, sinThetaNew;\n\t\n\t    var reTmp, imTmp;\n\t    var index;\n\t        for (var i = 0; i < nbPoints; i++) {\n\t            index = nbPoints - i - 1;\n\t            index = i;\n\t            reTmp = reData[index] * cosTheta - imData[index] * sinTheta;\n\t            imTmp = reData[index] * sinTheta + imData[index] * cosTheta;\n\t            reData[index] = reTmp;\n\t            imData[index] = imTmp;\n\t            // calculate angles i+1 from i\n\t            cosThetaNew = cosTheta - (alpha * cosTheta + beta * sinTheta);\n\t            sinThetaNew = sinTheta - (alpha * sinTheta - beta * cosTheta);\n\t            cosTheta = cosThetaNew;\n\t            sinTheta = sinThetaNew;\n\t        }\n\t        //toApply--;\n\t    //}\n\t\n\t    spectraData.resetMinMax();\n\t    //spectraData.updateDefaults();\n\t    //spectraData.updateY();\n\t    spectraData.putParam(\"PHC0\", phi0);\n\t    spectraData.putParam(\"PHC1\", phi1);\n\t}\n\t\n\tmodule.exports = phaseCorrection;\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Created by acastillo on 4/26/16.\n\t */\n\tvar rotate = __webpack_require__(50);\n\t\n\tfunction digitalFilter(spectraData, options){\n\t    var nbPoints = 0;\n\t    if(options.nbPoints){\n\t        nbPoints = options.nbPoints;\n\t    }\n\t    else{\n\t        if(options.brukerFilter){\n\t            //TODO Determine the number of points to shift, or the ph1 correction\n\t            //based on DECIM and DSPSVF parameters\n\t            nbPoints = 0;\n\t        }\n\t    }\n\t\n\t    var nbSubSpectra = spectraData.getNbSubSpectra();\n\t    if (nbPoints != 0){\n\t        for (var iSubSpectra = 0 ; iSubSpectra < nbSubSpectra; iSubSpectra++){\n\t            spectraData.setActiveElement(iSubSpectra);\n\t            rotate(spectraData.getYData(),nbPoints);\n\t            if(options.rotateX){\n\t                rotate(spectraData.getXData(),nbPoints);\n\t                spectraData.setFirstX(spectraData.getX(0));\n\t                spectraData.setLastX(spectraData.getX(spectraData.getNbPoints()-1));\n\t            }\n\t        }\n\t    }\n\t    spectraData.setActiveElement(0);\n\t    return spectraData;\n\t}\n\t\n\tmodule.exports = digitalFilter;\n\n/***/ },\n/* 50 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t/**\n\t * Created by acastillo on 4/26/16.\n\t */\n\t/**\n\t * This function performs a circular shift of the input object without realocating memory.\n\t * Positive values of shifts will shift to the right and negative values will do to the left\n\t * @example rotate([1,2,3,4],1) -> [4,1,2,3]\n\t * @example rotate([1,2,3,4],-1) -> [2,3,4,1]\n\t * @param array\n\t */\n\tfunction rotate(array,shift){\n\t    var nbPoints = array.length;\n\t    //Lets calculate the lest amount of points to shift.\n\t    //It decreases the amount of validations in the loop\n\t    shift = shift%nbPoints;\n\t\n\t    if(Math.abs(shift)>nbPoints/2){\n\t        shift = shift>0?shift-nbPoints:shift+nbPoints;\n\t    }\n\t\n\t    if(shift!=0){\n\t        var currentIndex=0, nextIndex=shift;\n\t        var toMove = nbPoints;\n\t        var current = array[currentIndex], next;\n\t        var lastFirstIndex = shift;\n\t        var direction = shift>0?1:-1;\n\t\n\t        while(toMove>0){\n\t            nextIndex = putInRange(nextIndex,nbPoints);\n\t            next = array[nextIndex];\n\t            array[nextIndex] = current;\n\t            nextIndex+=shift;\n\t            current = next;\n\t            toMove--;\n\t\n\t            if(nextIndex==lastFirstIndex){\n\t                nextIndex = putInRange(nextIndex+direction,nbPoints);\n\t                lastFirstIndex = nextIndex;\n\t                currentIndex = putInRange(nextIndex-shift,nbPoints);\n\t                current = array[currentIndex];\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction putInRange(value, nbPoints){\n\t    if(value<0)\n\t        value+=nbPoints;\n\t    if(value>=nbPoints)\n\t        value-=nbPoints;\n\t    return value;\n\t}\n\t\n\tmodule.exports = rotate;\n\t\n\t\n\t/*var foo = [1,2,3,4,5,6];\n\trotate(foo,-4);\n\tconsole.log(foo);*/\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar SD = __webpack_require__(3);\n\tvar PeakPicking2D = __webpack_require__(52);\n\tvar PeakOptimizer = __webpack_require__(53);\n\tvar JcampConverter=__webpack_require__(5);\n\tvar stat = __webpack_require__(37);\n\t\n\t/**\n\t * Construct the object from the given sd object(output of the jcampconverter or brukerconverter filter)\n\t * @param sd\n\t * @constructor\n\t */\n\tfunction NMR2D(sd) {\n\t    SD.call(this, sd); // Héritage\n\t}\n\t\n\tNMR2D.prototype = Object.create(SD.prototype);\n\tNMR2D.prototype.constructor = NMR2D;\n\t\n\t/**\n\t * @function fromJcamp(jcamp,options)\n\t * Construct the object from the given jcamp.\n\t * @param jcamp\n\t * @param options\n\t * @option xy\n\t * @option keepSpectra\n\t * @option keepRecordsRegExp\n\t * @returns {NMR2D}\n\t */\n\tNMR2D.fromJcamp = function(jcamp,options) {\n\t    options = options || {xy:true,keepSpectra:true,keepRecordsRegExp:/^.+$/};\n\t    var spectrum= JcampConverter.convert(jcamp,options);\n\t    return new NMR2D(spectrum);\n\t}\n\t\n\t/**\n\t * @function isHomoNuclear()\n\t * Returns true if the it is an homo-nuclear experiment\n\t * @returns {boolean}\n\t */\n\tNMR2D.prototype.isHomoNuclear=function(){\n\t    return this.sd.xType==this.sd.yType;\n\t}\n\t\n\t/**\n\t * @function observeFrequencyX()\n\t * Returns the observe frequency in the direct dimension\n\t * @returns {*}\n\t */\n\tNMR2D.prototype.observeFrequencyX=function(){\n\t    return this.sd.spectra[0].observeFrequency;\n\t}\n\t/**\n\t * @function observeFrequencyY()\n\t * Returns the observe frequency in the indirect dimension\n\t * @returns {*}\n\t */\n\tNMR2D.prototype.observeFrequencyY=function(){\n\t    return this.sd.indirectFrequency;\n\t}\n\t\n\t/**\n\t * @function getSolventName()\n\t * Returns the solvent name.\n\t * @returns {string|XML}\n\t */\n\tNMR2D.prototype.getSolventName=function(){\n\t    return (this.sd.info[\".SOLVENTNAME\"]||this.sd.info[\"$SOLVENT\"]).replace(\"<\",\"\").replace(\">\",\"\");\n\t}\n\t\n\t/**\n\t * @function getXUnits()\n\t * This function returns the units of the direct dimension. It overrides the SD getXUnits function\n\t * @returns {ntuples.units|*|b.units}\n\t */\n\tNMR2D.prototype.getXUnits = function(){\n\t    return this.sd.ntuples[1].units;\n\t}\n\t/**\n\t * @function getYUnits()\n\t * This function returns the units of the indirect dimension. It overrides the SD getYUnits function\n\t * @returns {ntuples.units|*|b.units}\n\t */\n\tNMR2D.prototype.getYUnits = function(){\n\t    return this.sd.ntuples[0].units;\n\t}\n\t/**\n\t * @function getZUnits()\n\t * Returns the units of the dependent variable\n\t * @returns {ntuples.units|*|b.units}\n\t */\n\tNMR2D.prototype.getZUnits = function(){\n\t    return this.sd.ntuples[2].units;\n\t}\n\t/**\n\t * @function getLastY()\n\t * Returns the min value in the indirect dimension.\n\t * @returns {sd.minMax.maxY}\n\t */\n\tNMR2D.prototype.getLastY = function(){\n\t    return this.sd.minMax.maxY;\n\t}\n\t/**\n\t * @function getFirstY()\n\t * Returns the min value in the indirect dimension.\n\t * @returns {sd.minMax.minY}\n\t */\n\tNMR2D.prototype.getFirstY = function(){\n\t    return this.sd.minMax.minY;\n\t}\n\t/**\n\t * @function getDeltaY()\n\t * Returns the separation between 2 consecutive points in the indirect domain\n\t * @returns {number}\n\t */\n\tNMR2D.prototype.getDeltaY=function(){\n\t    return ( this.getLastY()-this.getFirstY()) / (this.getNbSubSpectra()-1);\n\t}\n\t\n\t/**\n\t * @function nmrPeakDetection2D(options)\n\t * This function process the given spectraData and tries to determine the NMR signals. \n\t + Returns an NMRSignal2D array containing all the detected 2D-NMR Signals\n\t * @param\toptions:+Object\t\t\tObject containing the options\n\t * @option\tthresholdFactor:number\tA factor to scale the automatically determined noise threshold.\n\t * @returns [*]\tset of NMRSignal2D\n\t */\n\tNMR2D.prototype.nmrPeakDetection2D=function(options){\n\t    options = options||{};\n\t    if(!options.thresholdFactor)\n\t        options.thresholdFactor=1;\n\t    var id = Math.round(Math.random()*255);\n\t    if(options.idPrefix){\n\t        id=options.idPrefix;\n\t    }\n\t    var peakList = PeakPicking2D.findPeaks2D(this, options.thresholdFactor);\n\t\n\t    //lets add an unique ID for each peak.\n\t    for(var i=0;i<peakList.length;i++){\n\t        peakList[i]._highlight=[id+\"_\"+i];\n\t        peakList[i].signalID = id+\"_\"+i;\n\t    }\n\t    if(options.references)\n\t        PeakOptimizer.alignDimensions(peakList,options.references);\n\t\n\t    if(options.format===\"new\"){\n\t        var newSignals = new Array(peakList.length);\n\t        var minMax1, minMax2;\n\t        for(var k=peakList.length-1;k>=0;k--){\n\t            var signal = peakList[k];\n\t            newSignals[k]={\n\t                fromTo:signal.fromTo,\n\t                integral:signal.intensity||1,\n\t                remark:\"\",\n\t                signal:[{\n\t                    peak:signal.peaks,\n\t                    delta:[signal.shiftX, signal.shiftY]\n\t                }],\n\t                _highlight:signal._highlight,\n\t                signalID:signal.signalID,\n\t            };\n\t        }\n\t        peakList = newSignals;\n\t    }\n\t\n\t\n\t    return peakList;\n\t}\n\t\n\t/**\n\t * @function getNMRPeakThreshold(nucleus)\n\t * Returns the noise factor depending on the nucleus.\n\t * @param nucleus\n\t * @returns {number}\n\t */\n\tNMR2D.prototype.getNMRPeakThreshold=function(nucleus) {\n\t    if (nucleus == \"1H\")\n\t        return 3.0;\n\t    if (nucleus ==\"13C\")\n\t        return 5.0;\n\t    return 1.0;\n\t}\n\t\n\t/**\n\t * @function getNucleus(dim)\n\t * Returns the observed nucleus in the specified dimension\n\t * @param dim\n\t * @returns {string}\n\t */\n\tNMR2D.prototype.getNucleus=function(dim){\n\t    if(dim==1)\n\t        return this.sd.xType;\n\t    if(dim==2)\n\t        return this.sd.yType;\n\t    return this.sd.xType;\n\t}\n\t\n\t\n\t/**\n\t * @function zeroFilling(nPointsX [,nPointsY])\n\t * This function increase the size of the spectrum, filling the new positions with zero values. Doing it one\n\t * could increase artificially the spectral resolution.\n\t * @param nPointsX Number of new zero points in the direct dimension\n\t * @param nPointsY Number of new zero points in the indirect dimension\n\t * @returns this object\n\t */\n\tNMR2D.prototype.zeroFilling=function(nPointsX, nPointsY) {\n\t    return Filters.zeroFilling(this,nPointsX, nPointsY);\n\t}\n\t\n\t/**\n\t * @function brukerFilter()\n\t * This filter applies a circular shift(phase 1 correction in the time domain) to an NMR FID spectrum that\n\t * have been obtained on spectrometers using the Bruker digital filters. The amount of shift depends on the\n\t * parameters DECIM and DSPFVS. This spectraData have to be of type NMR_FID\n\t * @returns this object\n\t */\n\tNMR2D.prototype.brukerFilter=function() {\n\t    return Filters.digitalFilter(this, {\"brukerFilter\":true});\n\t}\n\t\n\t/**\n\t * @function digitalFilter(options)\n\t * This filter applies a circular shift(phase 1 correction in the time domain) to an NMR FID spectrum that\n\t * have been obtained on spectrometers using the Bruker digital filters. The amount of shift depends on the\n\t * parameters DECIM and DSPFVS. This spectraData have to be of type NMR_FID\n\t * @option nbPoints: The number of points to shift. Positive values will shift the values to the rigth\n\t * and negative values will do to the left.\n\t * @option brukerSpectra\n\t * @returns this object\n\t */\n\tNMR2D.prototype.digitalFilter=function(options) {\n\t    return Filters.digitalFilter(this, options);\n\t}\n\t\n\t\n\t/**\n\t * @function fourierTransform()\n\t * Fourier transforms the given spectraData (Note. no 2D handling yet) this spectraData have to be of type NMR_FID or 2DNMR_FID\n\t * @returns this object\n\t */\n\tNMR2D.prototype.fourierTransform=function( ) {\n\t    return Filters.fourierTransform(this);\n\t}\n\t\n\t/**\n\t * @function postFourierTransform(ph1corr)\n\t * This filter makes an phase 1 correction that corrects the problem of the spectra that has been obtained\n\t * on spectrometers using the Bruker digital filters. This method is used in cases when the BrukerSpectra\n\t * filter could not find the correct number of points to perform a circular shift.\n\t * The actual problem is that not all of the spectra has the necessary parameters for use only one method for\n\t * correcting the problem of the Bruker digital filters.\n\t * @param spectraData A fourier transformed spectraData.\n\t * @param ph1corr Phase 1 correction value in radians.\n\t * @returns this object\n\t */\n\tNMR2D.prototype.postFourierTransform=function(ph1corr) {\n\t    return Filters.phaseCorrection(0,ph1corr);\n\t}\n\t\n\tmodule.exports = NMR2D;\n\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar lib = __webpack_require__(41);\n\tvar PeakOptimizer = __webpack_require__(53);\n\tvar SimpleClustering =  __webpack_require__(54);\n\tvar StatArray = __webpack_require__(4);\n\tvar FFTUtils = lib.FFTUtils;\n\t\n\tvar PeakPicking2D= {\n\t    DEBUG : false,\n\t    smallFilter : [\n\t        [0, 0, 1, 2, 2, 2, 1, 0, 0],\n\t        [0, 1, 4, 7, 7, 7, 4, 1, 0],\n\t        [1, 4, 5, 3, 0, 3, 5, 4, 1],\n\t        [2, 7, 3, -12, -23, -12, 3, 7, 2],\n\t        [2, 7, 0, -23, -40, -23, 0, 7, 2],\n\t        [2, 7, 3, -12, -23, -12, 3, 7, 2],\n\t        [1, 4, 5, 3, 0, 3, 5, 4, 1],\n\t        [0, 1, 3, 7, 7, 7, 3, 1, 0],\n\t        [0, 0, 1, 2, 2, 2, 1, 0, 0]],\n\t\n\t\n\t    //How noisy is the spectrum depending on the kind of experiment.\n\t    getLoGnStdDevNMR : function(spectraData) {\n\t    if (spectraData.isHomoNuclear())\n\t        return 1.5\n\t    else\n\t        return 3;\n\t    },\n\t\n\t    findPeaks2D : function(spectraData, thresholdFactor){\n\t        if(thresholdFactor==0)\n\t            thresholdFactor=1;\n\t        if(thresholdFactor<0)\n\t            thresholdFactor=-thresholdFactor;\n\t        var nbPoints = spectraData.getNbPoints();\n\t        var nbSubSpectra = spectraData.getNbSubSpectra();\n\t\n\t        var data = new Array(nbPoints * nbSubSpectra);\n\t        //var data = new Array(nbPoints * nbSubSpectra/2);\n\t\n\t        var isHomonuclear = spectraData.isHomoNuclear();\n\t\n\t        //var sum = new Array(nbPoints);\n\t\n\t        for (var iSubSpectra = 0; iSubSpectra < nbSubSpectra; iSubSpectra++) {\n\t            var spectrum = spectraData.getYData(iSubSpectra);\n\t            for (var iCol = 0; iCol < nbPoints; iCol++) {\n\t                if(isHomonuclear){\n\t                    data[iSubSpectra * nbPoints + iCol] =(spectrum[iCol]>0?spectrum[iCol]:0);\n\t                }\n\t                else{\n\t                    data[iSubSpectra * nbPoints + iCol] =Math.abs(spectrum[iCol]);\n\t                }\n\t            }\n\t        }\n\t\n\t        var nStdDev = this.getLoGnStdDevNMR(spectraData);\n\t        if(isHomonuclear){\n\t            var convolutedSpectrum = this.convoluteWithLoG(data, nbSubSpectra, nbPoints);\n\t            var peaksMC1 = this.findPeaks2DLoG(data, convolutedSpectrum, nbSubSpectra, nbPoints, nStdDev*thresholdFactor);//)1.5);\n\t            var peaksMax1 = this.findPeaks2DMax(data, convolutedSpectrum, nbSubSpectra, nbPoints, (nStdDev+0.5)*thresholdFactor);//2.0);\n\t            for(var i=0;i<peaksMC1.length;i++)\n\t                peaksMax1.push(peaksMC1[i]);\n\t            //console.log(peaksMax1);\n\t            return PeakOptimizer.enhanceSymmetry(this.createSignals2D(peaksMax1,spectraData,24));\n\t\n\t        }\n\t        else{\n\t            var convolutedSpectrum = this.convoluteWithLoG(data, nbSubSpectra, nbPoints);\n\t            var peaksMC1 = this.findPeaks2DLoG(data, convolutedSpectrum, nbSubSpectra, nbPoints, nStdDev*thresholdFactor);\n\t            //Peak2D[] peaksMC1 = PeakPicking2D.findPeaks2DMax(data, nbSubSpectra, nbPoints, (nStdDev+0.5)*thresholdFactor);\n\t            //Remove peaks with less than 3% of the intensity of the highest peak\n\t            return this.createSignals2D(PeakOptimizer.clean(peaksMC1, 0.05), spectraData,24);\n\t        }\n\t\n\t    },\n\t    /**\n\t     Calculates the 1st derivative of the 2D matrix, using the LoG kernel approximation\n\t     */\n\t    convoluteWithLoG : function(inputSpectrum, nRows, nCols){\n\t        var ftSpectrum = new Array(nCols * nRows);\n\t        for (var i = nRows * nCols-1; i >=0; i--){\n\t            ftSpectrum[i] = inputSpectrum[i];\n\t        }\n\t\n\t        ftSpectrum = FFTUtils.fft2DArray(ftSpectrum, nRows, nCols);\n\t\n\t        var dim = this.smallFilter.length;\n\t        var ftFilterData = new Array(nCols * nRows);\n\t        for(var i=nCols * nRows-1;i>=0;i--){\n\t            ftFilterData[i]=0;\n\t        }\n\t\n\t        var iRow, iCol;\n\t        var shift = (dim - 1) / 2;\n\t        //console.log(dim);\n\t        for (var ir = 0; ir < dim; ir++) {\n\t            iRow = (ir - shift + nRows) % nRows;\n\t            for (var ic = 0; ic < dim; ic++) {\n\t                iCol = (ic - shift + nCols) % nCols;\n\t                ftFilterData[iRow * nCols + iCol] = this.smallFilter[ir][ic];\n\t            }\n\t        }\n\t\n\t        ftFilterData = FFTUtils.fft2DArray(ftFilterData, nRows, nCols);\n\t\n\t        var ftRows = nRows * 2;\n\t        var ftCols = nCols / 2 + 1;\n\t        FFTUtils.convolute2DI(ftSpectrum, ftFilterData, ftRows, ftCols);\n\t\n\t        return  FFTUtils.ifft2DArray(ftSpectrum, ftRows, ftCols);\n\t    },\n\t    /**\n\t     Detects all the 2D-peaks in the given spectrum based on center of mass logic.\n\t     */\n\t    findPeaks2DLoG : function(inputSpectrum, convolutedSpectrum, nRows, nCols, nStdDev) {\n\t        var threshold = 0;\n\t        for(var i=nCols*nRows-2;i>=0;i--)\n\t            threshold+=Math.pow(convolutedSpectrum[i]-convolutedSpectrum[i+1],2);\n\t        threshold=-Math.sqrt(threshold);\n\t        threshold*=nStdDev/nRows;\n\t\n\t        var bitmask = new Array(nCols * nRows);\n\t        for(var i=nCols * nRows-1;i>=0;i--){\n\t            bitmask[i]=0;\n\t        }\n\t        var nbDetectedPoints = 0;\n\t        var lasti=-1;\n\t        for (var i = convolutedSpectrum.length-1; i >=0 ; i--) {\n\t            if (convolutedSpectrum[i] < threshold) {\n\t                bitmask[i] = 1;\n\t                nbDetectedPoints++;\n\t            }\n\t        }\n\t        var iStart = 0;\n\t        //int ranges = 0;\n\t        var peakList = [];\n\t\n\t        while (nbDetectedPoints != 0) {\n\t            for (iStart; iStart < bitmask.length && bitmask[iStart]==0; iStart++){};\n\t            //\n\t            if (iStart == bitmask.length)\n\t                break;\n\t\n\t            nbDetectedPoints -= this.extractArea(inputSpectrum, convolutedSpectrum,\n\t                bitmask, iStart, nRows, nCols, peakList, threshold);\n\t        }\n\t\n\t        if (peakList.length > 0&&this.DEBUG) {\n\t            console.log(\"No peak found\");\n\t        }\n\t        return peakList;\n\t    },\n\t    /**\n\t     Detects all the 2D-peaks in the given spectrum based on the Max logic.\n\t     */\n\t    findPeaks2DMax : function(inputSpectrum, cs, nRows, nCols, nStdDev) {\n\t        var threshold = 0;\n\t        for(var i=nCols*nRows-2;i>=0;i--)\n\t            threshold+=Math.pow(cs[i]-cs[i+1],2);\n\t        threshold=-Math.sqrt(threshold);\n\t        threshold*=nStdDev/nRows;\n\t\n\t        var rowI,colI;\n\t        var peakListMax = [];\n\t        var tmpIndex = 0;\n\t        for (var i = 0; i < cs.length; i++) {\n\t            if (cs[i] < threshold) {\n\t                //It is a peak?\n\t                rowI=Math.floor(i/nCols);\n\t                colI=i%nCols;\n\t                //Verifies if this point is a peak;\n\t                if(rowI>0&&rowI+1<nRows&&colI+1<nCols&&colI>0){\n\t                    //It is the minimum in the same row\n\t                    if(cs[i]<cs[i+1]&&cs[i]<cs[i-1]){\n\t                        //It is the minimum in the previous row\n\t                        tmpIndex=(rowI-1)*nCols+colI;\n\t                        if(cs[i]<cs[tmpIndex-1]&&cs[i]<cs[tmpIndex]&&cs[i]<cs[tmpIndex+1]){\n\t                            //It is the minimum in the next row\n\t                            tmpIndex=(rowI+1)*nCols+colI;\n\t                            if(cs[i]<cs[tmpIndex-1]&&cs[i]<cs[tmpIndex]&&cs[i]<cs[tmpIndex+1]){\n\t                                peakListMax.push({x:colI,y:rowI,z:inputSpectrum[i]});\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return peakListMax;\n\t    },\n\t    /*\n\t     This function detects the peaks\n\t     */\n\t    extractArea : function(spectrum, convolutedSpectrum, bitmask, iStart,\n\t                                                   nRows, nCols, peakList, threshold) {\n\t        var iRow = Math.floor(iStart / nCols);\n\t        var iCol = iStart % nCols;\n\t        var peakPoints =[];\n\t        //console.log(iStart+\" \"+iRow+\" \"+iCol);\n\t        // scanBitmask(bitmask, convolutedSpectrum, nRows, nCols, iRow, iCol,\n\t        // peakPoints);\n\t        this.scanBitmask(bitmask, nRows, nCols, iRow, iCol, peakPoints);\n\t        //console.log(\"extractArea.lng \"+peakPoints.length);\n\t        var x = new Array(peakPoints.length);\n\t        var y = new Array(peakPoints.length);\n\t        var z = new Array(peakPoints.length);\n\t        var nValues = peakPoints.length;\n\t        var xAverage = 0.0;\n\t        var yAverage = 0.0;\n\t        var zSum = 0.0;\n\t        if (nValues >= 9) {\n\t            if (this.DEBUG)\n\t                console.log(\"nValues=\" + nValues);\n\t            var maxValue = Number.NEGATIVE_INFINITY;\n\t            var maxIndex = -1;\n\t            for (var i = 0; i < nValues; i++) {\n\t                var pt = (peakPoints.splice(0,1))[0];\n\t                x[i] = pt[0];\n\t                y[i] = pt[1];\n\t                z[i] = spectrum[pt[1] * nCols + pt[0]];\n\t                xAverage += x[i] * z[i];\n\t                yAverage += y[i] * z[i];\n\t                zSum += z[i];\n\t                if (z[i] > maxValue) {\n\t                    maxValue = z[i];\n\t                    maxIndex = i;\n\t                }\n\t            }\n\t            if (maxIndex != -1) {\n\t                xAverage /= zSum;\n\t                yAverage /= zSum;\n\t                var newPeak = {x:xAverage, y:yAverage, z:zSum};\n\t                var minmax;\n\t                minmax =StatArray.minMax(x);\n\t                newPeak.minX=minmax.min;\n\t                newPeak.maxX=minmax.max;\n\t                minmax = StatArray.minMax(y);\n\t                newPeak.minY=minmax.min;\n\t                newPeak.maxY=minmax.max;\n\t                peakList.push(newPeak);\n\t            }\n\t        }\n\t        return nValues;\n\t    },\n\t    /*\n\t     Return all the peaks(x,y points) that composes a signal.\n\t     */\n\t    scanBitmask : function(bitmask, nRows, nCols, iRow, iCol, peakPoints) {\n\t        //console.log(nRows+\" \"+iRow+\" \"+nCols+\" \"+iCol);\n\t        if (iRow < 0 || iCol < 0 || iCol == nCols || iRow == nRows)\n\t            return;\n\t        if (bitmask[iRow * nCols + iCol]) {\n\t            bitmask[iRow * nCols + iCol] = 0;\n\t            peakPoints.push([iCol, iRow]);\n\t            this.scanBitmask(bitmask, nRows, nCols, iRow + 1, iCol, peakPoints);\n\t            this.scanBitmask(bitmask, nRows, nCols, iRow - 1, iCol, peakPoints);\n\t            this.scanBitmask(bitmask, nRows, nCols, iRow, iCol + 1, peakPoints);\n\t            this.scanBitmask(bitmask, nRows, nCols, iRow, iCol - 1, peakPoints);\n\t        }\n\t    },\n\t    /**\n\t     This function converts a set of 2D-peaks in 2D-signals. Each signal could be composed\n\t     of many 2D-peaks, and it has some additional information related to the NMR spectrum.\n\t     */\n\t    createSignals2D : function(peaks, spectraData, tolerance){\n\t        //console.log(peaks.length);\n\t        var signals=[];\n\t        var nbSubSpectra = spectraData.getNbSubSpectra();\n\t\n\t        var bf1=spectraData.observeFrequencyX();\n\t        var bf2=spectraData.observeFrequencyY();\n\t\n\t        var firstY = spectraData.getFirstY();\n\t        var lastY = spectraData.getLastY();\n\t        var dy = spectraData.getDeltaY();\n\t\n\t        //console.log(firstY+\" \"+lastY+\" \"+dy+\" \"+nbSubSpectra);\n\t        //spectraData.setActiveElement(0);\n\t        var noValid=0;\n\t        for (var i = peaks.length-1; i >=0 ; i--) {\n\t            //console.log(peaks[i].x+\" \"+spectraData.arrayPointToUnits(peaks[i].x));\n\t            //console.log(peaks[i].y+\" \"+(firstY + dy * (peaks[i].y)));\n\t            peaks[i].x=(spectraData.arrayPointToUnits(peaks[i].x));\n\t            peaks[i].y=(firstY + dy * (peaks[i].y));\n\t\n\t            //console.log(peaks[i])\n\t            //Still having problems to correctly detect peaks on those areas. So I'm removing everything there.\n\t            if(peaks[i].y<-1||peaks[i].y>=210){\n\t                peaks.splice(i,1);\n\t            }\n\t        }\n\t        //console.log(peaks);\n\t        //The connectivity matrix is an square and symmetric matrix, so we'll only store the upper diagonal in an\n\t        //array like form\n\t        var connectivity = [];\n\t        var tmp=0;\n\t        tolerance*=tolerance;\n\t        //console.log(tolerance);\n\t        for (var i = 0; i < peaks.length; i++) {\n\t            for (var j = i; j < peaks.length; j++) {\n\t                tmp=Math.pow((peaks[i].x-peaks[j].x)*bf1,2)+Math.pow((peaks[i].y-peaks[j].y)*bf2,2);\n\t                //Console.log(peaks[i].getX()+\" \"+peaks[j].getX()+\" \"+tmp);\n\t                if(tmp<tolerance){//30*30Hz We cannot distinguish peaks with less than 20 Hz of separation\n\t                    connectivity.push(1);\n\t                }\n\t                else{\n\t                    connectivity.push(0);\n\t                }\n\t            }\n\t        }\n\t\n\t        //console.log(connectivity);\n\t\n\t        var clusters = SimpleClustering.fullClusterGenerator(connectivity);\n\t\n\t        //console.log(clusters)\n\t\n\t        var signals = [];\n\t        if (peaks != null) {\n\t            var xValue, yValue;\n\t            for (var iCluster = 0; iCluster < clusters.length; iCluster++) {\n\t                var signal={nucleusX:spectraData.getNucleus(1),nucleusY:spectraData.getNucleus(2)};\n\t                signal.resolutionX=( spectraData.getLastX()-spectraData.getFirstX()) / spectraData.getNbPoints();\n\t                signal.resolutionY=dy;\n\t                var peaks2D = [];\n\t                signal.shiftX = 0;\n\t                signal.shiftY = 0;\n\t                var minMax1 = [Number.MAX_VALUE,0];\n\t                var minMax2 = [Number.MAX_VALUE,0];\n\t                var sumZ = 0;\n\t                for(var jPeak = clusters[iCluster].length-1;jPeak>=0;jPeak--){\n\t                    if(clusters[iCluster][jPeak]==1){\n\t                        peaks2D.push({\n\t                            x: peaks[jPeak].x,\n\t                            y: peaks[jPeak].y,\n\t                            z: peaks[jPeak].z\n\t\n\t                        }  );\n\t                        signal.shiftX+=peaks[jPeak].x*peaks[jPeak].z;\n\t                        signal.shiftY+=peaks[jPeak].y*peaks[jPeak].z;\n\t                        sumZ+=peaks[jPeak].z;\n\t                        if(peaks[jPeak].x<minMax1[0]){\n\t                            minMax1[0]=peaks[jPeak].x;\n\t                        }\n\t                        if(peaks[jPeak].x>minMax1[1]){\n\t                            minMax1[1]=peaks[jPeak].x;\n\t                        }\n\t                        if(peaks[jPeak].y<minMax2[0]){\n\t                            minMax2[0]=peaks[jPeak].y\n\t                        }\n\t                        if(peaks[jPeak].y>minMax2[1]){\n\t                            minMax2[1]=peaks[jPeak].y;\n\t                        }\n\t\n\t                    }\n\t                }\n\t                signal.fromTo = [{from:minMax1[0],to:minMax1[1]},\n\t                                {from:minMax2[0],to:minMax2[1]}];\n\t                signal.shiftX/=sumZ;\n\t                signal.shiftY/=sumZ;\n\t                signal.peaks = peaks2D;\n\t                signals.push(signal);\n\t            }\n\t        }\n\t        //console.log(signals);\n\t        return signals;\n\t    }\n\t}\n\t\n\tmodule.exports = PeakPicking2D;\n\n/***/ },\n/* 53 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar PeakOptimizer={\n\t\tdiagonalError:0.05,\n\t\ttolerance:0.05,\n\t\tDEBUG:false,\n\t    toleranceX : 0.025,\n\t    toleranceY : 0.5,\n\t\n\t    clean: function(peaks, threshold){\n\t        var max = Number.NEGATIVE_INFINITY;\n\t        var i,peak;\n\t        //double min = Double.MAX_VALUE;\n\t        for(i=peaks.length-1;i>=0;i--){\n\t            if(Math.abs(peaks[i].z)>max)\n\t                max=Math.abs(peaks[i].z);\n\t        }\n\t        max*=threshold;\n\t        for(i=peaks.length-1;i>=0;i--){\n\t            if(Math.abs(peaks[i].z)<max)\n\t                peaks.splice(i,1);\n\t        }\n\t        return peaks;\n\t    },\n\t\t\n\t\tenhanceSymmetry: function(signals){\n\t\t\t\n\t\t\tvar properties = this.initializeProperties(signals);\n\t\t\tvar output = signals;\n\t\n\t\t\tif(this.DEBUG)\n\t\t\t\tconsole.log(\"Before optimization size: \"+output.size());\n\t\t\t\n\t\t\t//First step of the optimization: Symmetry validation\n\t\t\tvar i,hits,index;\n\t\t\tvar signal;\n\t\t\tfor(i=output.length-1;i>=0;i--){\n\t\t\t\tsignal = output[i];\n\t\t\t\tif(signal.peaks.length>1)\n\t\t\t\t\tproperties[i][1]++;\n\t\t\t\tif(properties[i][0]==1){\n\t\t\t\t\tindex = this.exist(output, properties, signal,-1,true);\n\t\t\t\t\tif(index>=0){\n\t\t\t\t\t\tproperties[i][1]+=2;\n\t\t\t\t\t\tproperties[index][1]+=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//Second step of the optimization: Diagonal image existence\n\t\t\tfor(i=output.length-1;i>=0;i--){\n\t\t\t\tsignal = output[i];\n\t\t\t\tif(properties[i][0]==0){\n\t\t\t\t\thits = this.checkCrossPeaks(output, properties, signal, true);\n\t\t\t\t\tproperties[i][1]+=hits;\n\t\t\t\t\t//checkCrossPeaks(output, properties, signal, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//Now, each peak have a score between 0 and 4, we can complete the patterns which\n\t\t\t//contains peaks with high scores, and finally, we can remove peaks with scores 0 and 1\n\t\t\tvar count = 0;\n\t\t\tfor(i=output.length-1;i>=0;i--){\n\t\t\t\tif(properties[i][0]!==0&&properties[i][1]>2){\n\t\t\t\t\tcount++;\n\t\t\t\t\tcount+=this.completeMissingIfNeeded(output,properties,output[i],properties[i]);\n\t\t\t\t}\n\t\t\t\tif(properties[i][1]>=2&&properties[i][0]===0)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\t\n\t\t\tif(this.DEBUG)\n\t\t\t\tconsole.log(\"After optimization size: \"+count);\n\t\t\tvar  toReturn = new Array(count);\n\t\t\tcount--;\n\t\t\tfor(i=output.length-1;i>=0;i--){\n\t\t\t\tif(properties[i][0]!==0&&properties[i][1]>2\n\t\t\t\t\t\t||properties[i][0]===0&&properties[i][1]>1){\n\t\t\t\t\ttoReturn[count--]=output[i];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tconsole.log(\"Removed \"+i+\" \"+output[i].peaks.length);\n\t\t\t\t}\n\t\t\t\t//if(properties.get(i)[1]>=2)\n\t\t\t\t//\ttoReturn[count--]=output.get(i);\n\t\t\t}\n\t\t\treturn toReturn;\n\t\t},\n\t\t\n\t\tcompleteMissingIfNeeded: function(output, properties, thisSignal, thisProp) {\n\t\t\t//Check for symmetry\n\t\t\tvar index = this.exist(output, properties, thisSignal,-thisProp[0],true);\n\t\t\tvar addedPeaks=0;\n\t\t\tvar newSignal = null, tmpProp=null;\n\t\t\tif(index<0){//If this signal have no a symmetry image, we have to include it\n\t\t\t\tnewSignal = {nucleusX:thisSignal.nucleusX,nucleusY:thisSignal.nucleusY};\n\t\t\t\tnewSignal.resolutionX=thisSignal.resolutionX;\n\t\t\t\tnewSignal.resolutionY=thisSignal.resolutionY;\n\t\t\t\tnewSignal.shiftX=thisSignal.shiftY;\n\t\t\t\tnewSignal.shiftY=thisSignal.shiftX;\n\t\t\t\tnewSignal.peaks = [{x:thisSignal.shiftY,y:thisSignal.shiftX,z:1}];\n\t\t\t\toutput.push(newSignal);\n\t\t\t\ttmpProp = [-thisProp[0],thisProp[1]];\n\t\t\t\tproperties.push(tmpProp);\n\t\t\t\taddedPeaks++;\n\t\t\t}\n\t\t\t//Check for diagonal peaks\n\t\t\tvar j=0;\n\t\t\tvar diagX=false, diagY=false;\n\t\t\tvar signal;\n\t\t\tfor(j=output.length-1;j>=0;j--){\n\t\t\t\tsignal = output[j];\n\t\t\t\tif(properties[j][0]===0){\n\t\t\t\t\tif(Math.abs(signal.shiftX-thisSignal.shiftX)<this.diagonalError)\n\t\t\t\t\t\tdiagX=true;\n\t\t\t\t\tif(Math.abs(signal.shiftY-thisSignal.shiftY)<this.diagonalError)\n\t\t\t\t\t\tdiagY=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(diagX===false){\n\t\t\t\tnewSignal = {nucleusX:thisSignal.nucleusX,nucleusY:thisSignal.nucleusY};\n\t\t\t\tnewSignal.resolutionX=thisSignal.resolutionX;\n\t\t\t\tnewSignal.resolutionY=thisSignal.resolutionY;\n\t\t\t\tnewSignal.shiftX=thisSignal.shiftX;\n\t\t\t\tnewSignal.shiftY=thisSignal.shiftX;\n\t\t\t\tnewSignal.peaks = [{x:thisSignal.shiftX,y:thisSignal.shiftX,z:1}];\n\t\t\t\toutput.push(newSignal);\n\t\t\t\ttmpProp = [0,thisProp[1]];\n\t\t\t\tproperties.push(tmpProp);\n\t\t\t\taddedPeaks++;\n\t\t\t}\n\t\t\tif(diagY===false){\n\t\t\t\tnewSignal = {nucleusX:thisSignal.nucleusX,nucleusY:thisSignal.nucleusY};\n\t\t\t\tnewSignal.resolutionX=thisSignal.resolutionX;\n\t\t\t\tnewSignal.resolutionY=thisSignal.resolutionY;\n\t\t\t\tnewSignal.shiftX=thisSignal.shiftY;\n\t\t\t\tnewSignal.shiftY=thisSignal.shiftY;\n\t\t\t\tnewSignal.peaks = [{x:thisSignal.shiftY,y:thisSignal.shiftY,z:1}];\n\t\t\t\toutput.push(newSignal);\n\t\t\t\ttmpProp = [0,thisProp[1]];\n\t\t\t\tproperties.push(tmpProp);\n\t\t\t\taddedPeaks++;\n\t\t\t}\n\t\t\treturn addedPeaks;\n\t\t\t\n\t\t},\n\t\t\n\t\t//Check for any diagonal peak that match this cross peak\n\t\tcheckCrossPeaks: function(output, properties, signal, updateProperties) {\n\t\t\tvar hits = 0, i=0, shift=signal.shiftX*4;\n\t\t\tvar crossPeaksX = [],crossPeaksY = [];\n\t\t\tvar cross;\n\t\t\tfor(i=output.length-1;i>=0;i--){\n\t\t\t\tcross = output[i];\n\t\t\t\tif(properties[i][0]!==0){\n\t\t\t\t\tif(Math.abs(cross.shiftX-signal.shiftX)<this.diagonalError){\n\t\t\t\t\t\thits++;\n\t\t\t\t\t\tif(updateProperties)\n\t\t\t\t\t\t\tproperties[i][1]++;\n\t\t\t\t\t\tcrossPeaksX.push(i);\n\t\t\t\t\t\tshift+=cross.shiftX;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(Math.abs(cross.shiftY-signal.shiftY)<this.diagonalError){\n\t\t\t\t\t\t\thits++;\n\t\t\t\t\t\t\tif(updateProperties)\n\t\t\t\t\t\t\t\tproperties[i][1]++;\n\t\t\t\t\t\t\tcrossPeaksY.push(i);\n\t\t\t\t\t\t\tshift+=cross.shiftY;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//Update found crossPeaks and diagonal peak\n\t\t\tshift/=(crossPeaksX.length+crossPeaksY.length+4);\n\t\t\tif(crossPeaksX.length>0){\n\t\t\t\tfor( i=crossPeaksX.length-1;i>=0;i--){\n\t\t\t\t\toutput[crossPeaksX[i]].shiftX=shift;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(crossPeaksY.length>0){\n\t\t\t\tfor( i=crossPeaksY.length-1;i>=0;i--){\n\t\t\t\t\toutput[crossPeaksY[i]].shiftY=shift;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsignal.shiftX=shift;\n\t\t\tsignal.shiftY=shift;\n\t\t\treturn hits;\n\t\t},\n\t\n\t\texist: function(output, properties, signal, type, symmetricSearch) {\n\t\t\tfor(var i=output.length-1;i>=0;i--){\n\t\t\t\tif(properties[i][0]==type){\n\t\t\t\t\tif(this.distanceTo(signal, output[i], symmetricSearch)<this.tolerance){\n\t\t\t\t\t\tif(!symmetricSearch){\n\t\t\t\t\t\t\tvar shiftX=(output[i].shiftX+signal.shiftX)/2.0;\n\t\t\t\t\t\t\tvar shiftY=(output[i].shiftY+signal.shiftY)/2.0;\n\t\t\t\t\t\t\toutput[i].shiftX=shiftX;\n\t\t\t\t\t\t\toutput[i].shiftY=shiftY;\n\t\t\t\t\t\t\tsignal.shiftX=shiftX;\n\t\t\t\t\t\t\tsignal.shiftY=shiftY;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tvar shiftX=signal.shiftX;\n\t\t\t\t\t\t\tvar shiftY=output[i].shiftX;\n\t\t\t\t\t\t\toutput[i].shiftY=shiftX;\n\t\t\t\t\t\t\tsignal.shiftY=shiftY;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t},\n\t\t/**\n\t\t * We try to determine the position of each signal within the spectrum matrix.\n\t\t * Peaks could be of 3 types: upper diagonal, diagonal or under diagonal 1,0,-1\n\t\t * respectively.\n\t\t * @param Signals\n\t\t * @return A matrix containing the properties of each signal\n\t\t */\n\t\tinitializeProperties: function(signals){\n\t\t\tvar signalsProperties = new Array(signals.length);\n\t\t\tfor(var i=signals.length-1;i>=0;i--){\n\t\t\t\tsignalsProperties[i]=[0,0];\n\t\t\t\t//We check if it is a diagonal peak\n\t\t\t\tif(Math.abs(signals[i].shiftX-signals[i].shiftY)<=this.diagonalError){\n\t\t\t\t\tsignalsProperties[i][1]=1;\n\t\t\t\t\t//We adjust the x and y value to be symmetric.\n\t\t\t\t\t//In general chemical shift in the direct dimension is better than in the other one,\n\t\t\t\t\t//so, we believe more to the shiftX than to the shiftY.\n\t\t\t\t\tvar shift = (signals[i].shiftX*2+signals[i].shiftY)/3.0;\n\t\t\t\t\tsignals[i].shiftX=shift;\n\t\t\t\t\tsignals[i].shiftY=shift;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(signals[i].shiftX-signals[i].shiftY>0)\n\t\t\t\t\t\tsignalsProperties[i][0]=1;\n\t\t\t\t\telse\n\t\t\t\t\t\tsignalsProperties[i][0]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn signalsProperties;\n\t\t},\n\t\t\n\t\t/**\n\t\t * This function calculates the distance between 2 nmr signals . If toImage is true, \n\t\t * it will interchange x by y in the distance calculation for the second signal.\n\t\t */\n\t\tdistanceTo: function(a, b, toImage){\n\t\t\tif(!toImage){\n\t\t\t\treturn Math.sqrt(Math.pow(a.shiftX-b.shiftX, 2)\n\t\t\t\t\t\t+Math.pow(a.shiftY-b.shiftY, 2));\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn Math.sqrt(Math.pow(a.shiftX-b.shiftY, 2)\n\t\t\t\t\t\t+Math.pow(a.shiftY-b.shiftX, 2));\n\t\t\t}\n\t\t},\n\t\n\t\t/**\n\t\t * This function maps the corresponding 2D signals to the given set of 1D signals\n\t\t */\n\t\talignDimensions:function(signals2D,references){\n\t\t\t//For each reference dimension\n\t\t\tfor(var i=0;i<references.length;i++){\n\t\t\t\tvar ref = references[i];\n\t\t\t\tif(ref)\n\t\t\t\t\tthis._alignSingleDimension(signals2D,ref);\n\t\t\t}\n\t\t},\n\t\n\t\t_alignSingleDimension: function(signals2D, references){\n\t\t\t//For each 2D signal\n\t\t\tvar center = 0, width = 0, i, j;\n\t\t\tfor(i=0;i<signals2D.length;i++){\n\t\t\t\tvar signal2D = signals2D[i];\n\t\t\t\t//For each reference 1D signal\n\t\t\t\tfor(j=0;j<references.length;j++){\n\t\t\t\t\tcenter = (references[j].startX+references[j].stopX)/2;\n\t\t\t\t\twidth = Math.abs(references[j].startX-references[j].stopX)/2;\n\t\t\t\t\tif(signal2D.nucleusX==references[j].nucleus){\n\t\t\t\t\t\t//The 2D peak overlaps with the 1D signal\n\t\t\t\t\t\tif(Math.abs(signal2D.shiftX-center)<=width){\n\t\t\t\t\t\t\tsignal2D._highlight.push(references[j]._highlight[0]);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\t\t\t\tif(signal2D.nucleusY==references[j].nucleus){\n\t\t\t\t\t\tif(Math.abs(signal2D.shiftY-center)<=width){\n\t\t\t\t\t\t\tsignal2D._highlight.push(references[j]._highlight[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t}\n\t\t}\n\t\n\t};\n\t\n\tmodule.exports = PeakOptimizer;\n\n/***/ },\n/* 54 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar SimpleClustering={\n\t\n\t\t/*This function returns the cluster list for a given connectivity matrix.\n\t\t*To improve the performance, the connectivity(square and symmetric) matrix \n\t\t*is given as a single vector containing  the upper diagonal of the matrix\n\t\t*Note: This algorithm is O(n*n) complexity. I wonder if there is something better. \n\t\t*acastillo\n\t\t*/\n\t\tfullClusterGenerator:function(conn){\n\t\t\tvar nRows = Math.sqrt(conn.length*2+0.25)-0.5;\n\t\t\t//console.log(\"nRows: \"+nRows+\" - \"+conn.length);\n\t\t\tvar clusterList = [];\n\t\t\tvar available = new Array(nRows);\n\t\t\tvar remaining = nRows, i=0;\n\t\t\tvar cluster = [];\n\t\t\t//Mark all the elements as available\n\t\t\tfor(i=nRows-1;i>=0;i--){\n\t\t\t\tavailable[i]=1;\n\t\t\t}\n\t\t\tvar nextAv=-1;\n\t\t\tvar toInclude = [];\n\t\t\twhile(remaining>0){\n\t\t\t\tif(toInclude.length===0){\n\t\t\t\t\t//If there is no more elements to include. Start a new cluster\n\t\t\t\t\tcluster = new Array(nRows);\n\t\t\t\t\tfor(i=nRows-1;i>=0;i--)\n\t\t\t\t\t\tcluster[i]=0;\n\t\t\t\t\tclusterList.push(cluster);\n\t\t\t    \tfor(nextAv = nRows-1;available[nextAv]==0;nextAv--){};\n\t\t\t    }\n\t\t\t    else{\n\t\t\t    \tnextAv=toInclude.splice(0,1);\n\t\t\t    }\n\t\t\t    //console.log(\"row: \"+nextAv);\n\t\t\t    cluster[nextAv]=1;\n\t\t\t    available[nextAv]=0;\n\t\t\t    remaining--;\n\t\t\t    //Copy the next available row\n\t\t\t    var row = new Array(nRows);\n\t\t\t\tfor(i=nRows-1;i>=0;i--){\n\t\t\t\t\tvar c=Math.max(nextAv,i);\n\t\t\t\t\tvar r=Math.min(nextAv,i);\n\t\t\t\t\t//The element in the conn matrix\n\t\t\t\t\t//console.log(\"index: \"+r*(2*nRows-r-1)/2+c)\n\t\t\t\t\trow[i]=conn[r*(2*nRows-r-1)/2+c];\n\t\t\t\t\t//console.log(\"col: \"+i+\":\"+row[i]);\n\t\t\t\t\t//There is new elements to include in this row?\n\t\t\t\t\t//Then, include it to the current cluster\n\t\t\t\t\tif(row[i]==1&&available[i]==1&&cluster[i]==0){\n\t\t\t\t\t\ttoInclude.push(i);\n\t\t\t\t\t\tcluster[i]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn clusterList;\n\t\t}\n\t}\n\t\n\tmodule.exports = SimpleClustering;\n\n/***/ },\n/* 55 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t/**\n\t * This library formats a set of nmr1D signals to the ACS format.\n\t * Created by acastillo on 3/11/15. p\n\t */\n\tvar ACS=ACS || {};\n\tACS.formater =(function() {\n\t    var acsString=\"\";\n\t    var parenthesis=\"\";\n\t    var spectro=\"\";\n\t    var rangeForMultiplet=false;\n\t\n\t    function fromNMRSignal1D2ACS(spectrum, options){\n\t        acsString=\"\";\n\t        parenthesis=\"\";\n\t        spectro=\"\";\n\t        var solvent = null;\n\t        if(options&&options.solvent)\n\t            solvent = options.solvent;\n\t        //options.rangeForMultiplet=false;\n\t        if(options&&options.rangeForMultiplet!=undefined)\n\t            rangeForMultiplet = options.rangeForMultiplet;\n\t\n\t        if(options&&options.ascending){\n\t            spectrum.sort(function(a,b){\n\t                return b.delta1- a.delta1\n\t            });\n\t        }\n\t        else{\n\t            spectrum.sort(function(a,b){\n\t                return a.delta1- b.delta1\n\t            });\n\t        }\n\t\n\t        //console.log(\"Range1: \"+options.rangeForMultiplet);\n\t\n\t        spectrum.type=\"NMR SPEC\";\n\t        if (spectrum[0][\"nucleus\"]==\"1H\") {\n\t            formatAcs_default(spectrum, false, 2, 1, solvent);\n\t        } else if (spectrum[0][\"nucleus\"]==\"13C\") {\n\t            formatAcs_default(spectrum, false, 1, 0, solvent);\n\t        }\n\t\n\t        if (acsString.length>0) acsString+=\".\";\n\t\n\t        return acsString;\n\t    }\n\t\n\t    /*function formatAcs_default_IR(spectra, ascending, decimalValue, smw) {\n\t     appendSeparator();\n\t     appendSpectroInformation(spectra);\n\t     if (spectra[\"peakLabels\"]) {\n\t     var numberPeakLabels=spectra[\"peakLabels\"].length;\n\t     var minIntensity= 9999999;\n\t     var maxIntensity=-9999999;\n\t     for (var i=0; i<numberPeakLabels; i++) {\n\t     if (spectra[\"peakLabels\"][i].intensity<minIntensity) minIntensity=spectra[\"peakLabels\"][i].intensity;\n\t     if (spectra[\"peakLabels\"][i].intensity>maxIntensity) maxIntensity=spectra[\"peakLabels\"][i].intensity;\n\t     }\n\t     for (var i=0; i<numberPeakLabels; i++) {\n\t     if (ascending) {\n\t     var peakLabel=spectra[\"peakLabels\"][i];\n\t     } else {\n\t     var peakLabel=spectra[\"peakLabels\"][numberPeakLabels-i-1];\n\t     }\n\t     if (peakLabel) {\n\t     appendSeparator();\n\t     appendValue(peakLabel,decimalValue);\n\t     if (smw) { // we need to add small / medium / strong\n\t     if (peakLabel.intensity<((maxIntensity-minIntensity)/3+minIntensity)) acsString+=\" (s)\";\n\t     else if (peakLabel.intensity>(maxIntensity-(maxIntensity-minIntensity)/3)) acsString+=\" (w)\";\n\t     else acsString+=\" (m)\";\n\t     }\n\t     }\n\t     }\n\t     }\n\t     }*/\n\t\n\t    function formatAcs_default(spectra, ascending, decimalValue, decimalJ, solvent) {\n\t        appendSeparator();\n\t        appendSpectroInformation(spectra, solvent);\n\t        var numberSmartPeakLabels=spectra.length;\n\t        //console.log(\"SP \"+spectra);\n\t        //console.log(\"# \"+numberSmartPeakLabels);\n\t        for (var i=0; i<numberSmartPeakLabels; i++) {\n\t            if (ascending) {\n\t                var signal=spectra[i];\n\t            } else {\n\t                var signal=spectra[numberSmartPeakLabels-i-1];\n\t            }\n\t            if (signal) {\n\t                //console.log(\"X2X\"+i+JSON.stringify(signal));\n\t                appendSeparator();\n\t                appendDelta(signal,decimalValue);\n\t                appendParenthesis(signal,decimalJ);\n\t                //console.log(\"S2S\"+i);\n\t            }\n\t        }\n\t    }\n\t\n\t    function appendSpectroInformation(spectrum, solvent) {\n\t        if (spectrum.type==\"NMR SPEC\") {\n\t            if (spectrum[0].nucleus) {\n\t                acsString+=formatNucleus(spectrum[0].nucleus);\n\t            }\n\t            acsString+=\" NMR\";\n\t            if ((solvent) || (spectrum[0].observe)) {\n\t                acsString+=\" (\";\n\t                if (spectrum[0].observe) {\n\t                    acsString+=(spectrum[0].observe*1).toFixed(0)+\" MHz\";\n\t                    if (solvent) acsString+=\", \";\n\t                }\n\t                if (solvent) {\n\t                    acsString+=formatMF(solvent);\n\t                }\n\t                acsString+=\")\";\n\t            }\n\t            acsString+=\" δ \";\n\t        } else if (spectrum.type==\"IR\") {\n\t            acsString+=\" IR \";\n\t        } else if (spectrum.type==\"MASS\") {\n\t            acsString+=\" MASS \";\n\t        }\n\t    }\n\t\n\t    function appendDelta(line, nbDecimal) {\n\t        //console.log(\"appendDelta1\");\n\t        var startX = 0,stopX=0,delta1=0;\n\t        if(line.startX){\n\t            if((typeof line.startX)==\"string\"){\n\t                startX=parseFloat(line.startX);\n\t            }\n\t            else\n\t                startX=line.startX;\n\t        }\n\t        if(line.stopX){\n\t            if((typeof line.stopX)==\"string\"){\n\t                stopX=parseFloat(line.stopX);\n\t            }\n\t            else\n\t                stopX=line.stopX;\n\t        }\n\t        if(line.delta1){\n\t            if((typeof line.delta1)==\"string\"){\n\t                delta1=parseFloat(line.delta1);\n\t            }\n\t            else\n\t                delta1=line.delta1;\n\t\n\t        }\n\t        //console.log(\"Range2: \"+rangeForMultiplet+\" \"+line.multiplicity);\n\t        if (line.asymmetric===true||(line.multiplicity==\"m\"&&rangeForMultiplet===true)) {//Is it massive??\n\t            if (line.startX&&line.stopX) {\n\t                if (startX<stopX) {\n\t                    acsString+=startX.toFixed(nbDecimal)+\"-\"+stopX.toFixed(nbDecimal);\n\t                } else {\n\t                    acsString+=stopX.toFixed(nbDecimal)+\"-\"+startX.toFixed(nbDecimal);\n\t                }\n\t            } else {\n\t                if(line.delta1)\n\t                    acsString+=delta1.toFixed(nbDecimal);\n\t            }\n\t        }\n\t        else{\n\t            if(line.delta1)\n\t                acsString+=delta1.toFixed(nbDecimal);\n\t            else{\n\t                if(line.startX&&line.stopX){\n\t                    acsString+=((startX+stopX)/2).toFixed(nbDecimal);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    function appendValue(line, nbDecimal) {\n\t        if (line.xPosition) {\n\t            acsString+=line.xPosition.toFixed(nbDecimal);\n\t        }\n\t    }\n\t\n\t    function appendParenthesis(line, nbDecimal) {\n\t        //console.log(\"appendParenthesis1\");\n\t        // need to add assignment - coupling - integration\n\t        parenthesis=\"\";\n\t        appendMultiplicity(line);\n\t        appendIntegration(line);\n\t        appendCoupling(line,nbDecimal);\n\t        appendAssignment(line);\n\t\n\t\n\t        if (parenthesis.length>0) {\n\t            acsString+=\" (\"+parenthesis+\")\";\n\t        }\n\t        //console.log(\"appendParenthesis2\");\n\t    }\n\t\n\t    function appendIntegration(line) {\n\t        if (line.pubIntegration) {\n\t            appendParenthesisSeparator();\n\t            parenthesis+=line.pubIntegration;\n\t        } else if (line.integralData) {\n\t            appendParenthesisSeparator();\n\t            parenthesis+=line.integralData.value.toFixed(0)+\" H\";\n\t        }\n\t    }\n\t\n\t    function appendAssignment(line) {\n\t        if (line.pubAssignment) {\n\t            appendParenthesisSeparator();\n\t            parenthesis+=formatAssignment(line.pubAssignment);\n\t        }\n\t        else{\n\t            if (line.assignment) {\n\t                appendParenthesisSeparator();\n\t                parenthesis+=formatAssignment(line.assignment);\n\t            }\n\t        }\n\t    }\n\t\n\t    function appendMultiplicity(line) {\n\t        if (line.pubMultiplicity) {\n\t            appendParenthesisSeparator();\n\t            parenthesis+=line.pubMultiplicity;\n\t        } else if (line.multiplicity) {\n\t            appendParenthesisSeparator();\n\t            parenthesis+=line.multiplicity;\n\t        }\n\t    }\n\t\n\t    function appendCoupling(line, nbDecimal) {\n\t        if (line.nmrJs) {\n\t            var j=\"<i>J</i> = \";\n\t            for (var i=0; i<line.nmrJs.length; i++) {\n\t                var coupling=line.nmrJs[i].coupling;\n\t                if (j.length>11) j+=\", \";\n\t                j+=coupling.toFixed(nbDecimal);\n\t            }\n\t            appendParenthesisSeparator();\n\t            parenthesis+=j+\" Hz\";\n\t        }\n\t\n\t    }\n\t\n\t    function formatAssignment(assignment) {\n\t        assignment=assignment.replace(/([0-9])/g,\"<sub>$1</sub>\");\n\t        assignment=assignment.replace(/\\\"([^\\\"]*)\\\"/g,\"<i>$1</i>\");\n\t        return assignment;\n\t    }\n\t\n\t    function formatMF(mf) {\n\t        mf=mf.replace(/([0-9])/g,\"<sub>$1</sub>\");\n\t        return mf;\n\t    }\n\t\n\t    function formatNucleus(nucleus) {\n\t        nucleus=nucleus.replace(/([0-9])/g,\"<sup>$1</sup>\");\n\t        return nucleus;\n\t    }\n\t\n\t    function appendSeparator() {\n\t        if ((acsString.length>0) && (! acsString.match(/ $/))) {\n\t            acsString+=\", \";\n\t        }\n\t    }\n\t\n\t    function appendParenthesisSeparator() {\n\t        if ((parenthesis.length>0) && (! parenthesis.match(\", $\"))) parenthesis+=\", \";\n\t    }\n\t\n\t    function fromACS2NMRSignal1D(acsString){\n\t        return JSON.parse(SDAPI.AcsParserAsJSONString(acsString));\n\t    }\n\t\n\t    return {\n\t        toACS:fromNMRSignal1D2ACS,\n\t        toNMRSignal:fromACS2NMRSignal1D\n\t    }\n\t})();\n\t\n\tmodule.exports=ACS;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** sdv.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap fce71ee088f33ca04419\n **/","'use strict';\n\n/**\n * Created by acastillo on 5/25/16.\n */\nvar extend = require('extend');\nvar SD = require('spectra-data');\n\nexports.NMR = SD.NMR;\nexports.NMR2D = SD.NMR2D;\nexports.ACS = SD.ACS;\nexports.JAnalyzer = SD.JAnalyzer;\n\nvar options1D = {type:\"rect\",line:0, labelColor:\"red\", strokeColor:\"red\", strokeWidth:\"1px\", fillColor:\"green\"};\nvar options2D = {type:\"rect\",labelColor:\"red\", strokeColor:\"red\", strokeWidth:\"1px\", fillColor:\"green\", width:\"6px\", height:\"6px\"};\n\nfunction annotations1D(signals, optionsG){\n    var options = extend({}, options1D, optionsG);\n    const line = options.line;\n    var annotations=[];\n    for (var i=0; i<signals.length; i++) {\n        var annotation={};\n        var prediction=signals[i];\n        annotations.push(annotation);\n\n        annotation._highlight=prediction._highlight;\n        annotation.type=options.type;\n        annotation.position=[{x:prediction.to, y:(line*15)+\"px\"},\n            {x:prediction.from, y:(line*15+10)+\"px\"}];\n\n        annotation.label={\n            text: Math.round(prediction.integral*10)/10.0,\n            size: \"11px\",\n            anchor: 'middle',\n            color:options.labelColor,\n            position: {x: prediction.signal[0].delta, y:(line*15)+\"px\", dy: \"5px\"}\n        };\n\n        annotation.strokeColor=options.strokeColor;\n        annotation.strokeWidth=options.strokeWidth;\n        annotation.fillColor=options.fillColor;\n        annotation.info=prediction;\n    }\n    return annotations;\n} \n\nfunction annotations2D(signals2D, optionsG){\n    var options = extend({}, options2D, optionsG);\n    var annotations=[];\n    for(var k=signals2D.length-1;k>=0;k--){\n        var signal = signals2D[k];\n        var annotation={};\n        annotation.type=options.type;\n        annotation._highlight=signal._highlight;//[\"cosy\"+k];\n        annotation.position = [{x:signal.fromTo[0].from-0.01, y:signal.fromTo[1].from-0.01, dx:options.width, dy:options.height},\n            {x:signal.fromTo[0].to+0.01,y:signal.fromTo[1].to+0.01}];\n        annotation.fillColor=options.fillColor;\n        annotation.label={text:signal.remark,\n            \"position\": {\n                \"x\": signal.signal[0].delta[0],\n                \"y\": signal.signal[0].delta[1]-0.025}\n        };\n        if(signal.integral==1)\n            annotation.strokeColor=options.strokeColor;\n        else\n            annotation.strokeColor=\"rgb(0,128,0)\";\n\n        annotation.strokeWidth=options.strokeWidth;\n        annotation.width=options.width;\n        annotation.height=options.height;\n        annotation.info=signal;\n        annotations.push(annotation);\n    }\n    return annotations;\n}\n\nexports.GUI = {annotations2D:annotations2D, annotations1D: annotations1D};\n\n\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) {/**/}\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0],\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = target[name];\n\t\t\t\tcopy = options[name];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[name] = extend(deep, clone, copy);\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/extend/index.js\n ** module id = 1\n ** module chunks = 0\n **/","'use strict';\n\n\nexports.SD = require('./SD');\nexports.NMR = require('./NMR');\nexports.NMR2D = require('./NMR2D');\nexports.ACS = require('./AcsParser');\nexports.JAnalyzer = require('./JAnalyzer');\n//exports.SD2 = require('/SD2');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/spectra-data/src/index.js\n ** module id = 2\n ** module chunks = 0\n **/","'use strict';\n// small note on the best way to define array\n// http://jsperf.com/lp-array-and-loops/2\n\nvar StatArray = require('ml-stat/array');\nvar JcampConverter = require(\"jcampconverter\");\nvar JcampCreator = require(\"./JcampCreator\");\nvar extend = require(\"extend\");\n\n/**\n * Construct the object from the given sd object(output of the jcampconverter or brukerconverter filter)\n * @param sd\n * @constructor\n */\nfunction SD(sd) {\n    this.DATACLASS_XY=1;\n    this.DATACLASS_PEAK=2;\n\n    this.sd=sd;\n    this.activeElement=0;\n}\n\n/**\n * @function fromJcamp(jcamp,options)\n * Construct the object from the given jcamp.\n * @param jcamp\n * @param options\n * @option xy\n * @option keepSpectra\n * @option keepRecordsRegExp\n * @returns {SD}\n */\nSD.fromJcamp = function(jcamp, options) {\n    options = options || {xy:true,keepSpectra:true,keepRecordsRegExp:/^.+$/};\n    var spectrum= JcampConverter.convert(jcamp,options);\n    return new SD(spectrum);\n}\n\n\n/**\n * @function setActiveElement(nactiveSpectrum);\n * This function sets the nactiveSpectrum sub-spectrum as active\n * @param index of the sub-spectrum to set as active\n */\nSD.prototype.setActiveElement = function(nactiveSpectrum){\n    this.activeElement=nactiveSpectrum;\n}\n\n/**\n * @function getActiveElement();\n * This function returns the index of the active sub-spectrum.\n * @returns {number|*}\n */\nSD.prototype.getActiveElement = function(){\n    return this.activeElement;\n}\n\n/**\n * @function getXUnits()\n * This function returns the units of the independent dimension.\n * @returns {xUnit|*|M.xUnit}\n */\nSD.prototype.getXUnits = function(){\n    return this.getSpectrum().xUnit;\n}\n\n/**\n * @function setXUnits()\n * This function returns the units of the independent dimension.\n * @returns {xUnit|*|M.xUnit}\n */\nSD.prototype.setXUnits = function(units){\n    this.getSpectrum().xUnit=units;\n}\n\n/**\n * @function getYUnits()\n * * This function returns the units of the dependent variable.\n * @returns {yUnit|*|M.yUnit}\n */\nSD.prototype.getYUnits = function(){\n    return this.getSpectrum().yUnit;\n}\n\n/**\n * @function getSpectraVariable()\n * This function returns the information about the dimensions\n * @returns {*}\n */\nSD.prototype.getSpectraVariable = function(dim){\n    return this.sd.ntuples[dim];\n}\n\n/**\n * @function getNbPoints()\n * Return the number of points in the current spectrum\n * @param i sub-spectrum\n * @returns {*}\n */\nSD.prototype.getNbPoints=function(i){\n    return this.getSpectrumData(i).y.length;\n}\n\n/**\n * @function getFirstX()\n * Return the first value of the direct dimension\n * @param i sub-spectrum\n * @returns {number}\n */\nSD.prototype.getFirstX=function(i) {\n    i=i||this.activeElement;\n    return this.sd.spectra[i].firstX;\n}\n\n/**\n * @function setFirstX()\n * Set the firstX for this spectrum. You have to force and update of the xAxis after!!!\n * @param x\n * @param i sub-spectrum\n */\nSD.prototype.setFirstX=function(x, i) {\n    i=i||this.activeElement;\n    this.sd.spectra[i].firstX=x;\n}\n\n/**\n * @function getLastX()\n * Return the last value of the direct dimension\n * @param i sub-spectrum\n * @returns {number}\n */\nSD.prototype.getLastX=function(i) {\n    i=i||this.activeElement;\n    return this.sd.spectra[i].lastX;\n}\n\n/**\n * @function setLastX()\n * Set the last value of the direct dimension. You have to force and update of the xAxis after!!!\n * @param x\n * @param i sub-spectrum\n */\nSD.prototype.setLastX=function(x, i) {\n    i=i||this.activeElement;\n    this.sd.spectra[i].lastX=x;\n}\n\n/**\n */\n/**\n * Return the first value of the direct dimension\n * @param i sub-spectrum\n * @returns {number}\n */\nSD.prototype.getFirstY=function(i) {\n    i=i||this.activeElement;\n    return this.sd.spectra[i].firstY;\n}\n\n/**\n * @function setFirstY()\n * Set the first value of the indirect dimension. Only valid for 2D spectra.\n * @param y\n * @param i sub-spectrum\n */\nSD.prototype.setFirstY=function(y, i) {\n    i=i||this.activeElement;\n    this.sd.spectra[i].firstY = y;\n}\n\n/**\n * @function getLastY\n * Return the first value of the indirect dimension. Only valid for 2D spectra.\n * @returns {number}\n */\nSD.prototype.getLastY = function(i){\n    i=i||this.activeElement;\n    return this.sd.spectra[i].lastY;\n}\n\n/**\n * @function setLastY()\n * Return the first value of the indirect dimension\n * @param y\n * @param i sub-spectrum\n */\nSD.prototype.setLastY = function(y, i){\n    i=i||this.activeElement;\n    this.sd.spectra[i].lastY = y;\n}\n\n/**\n * @function setDataClass()\n * Set the spectrum data_class. It could be DATACLASS_PEAK=1 or DATACLASS_XY=2\n * @param dataClass\n */\nSD.prototype.setDataClass = function(dataClass){\n    if(dataClass==this.DATACLASS_PEAK) {\n        this.getSpectrum().isPeaktable = true;\n        this.getSpectrum().isXYdata = false;\n    }\n    if(dataClass==this.DATACLASS_XY){\n        this.getSpectrum().isXYdata = true;\n        this.getSpectrum().isPeaktable = false;\n    }\n}\n\n/**\n * @function isDataClassPeak();\n * Is this a PEAKTABLE spectrum?\n * @returns {*}\n */\nSD.prototype.isDataClassPeak = function(){\n    if(this.getSpectrum().isPeaktable)\n        return  this.getSpectrum().isPeaktable;\n    return false;\n}\n\n/**\n * @function isDataClassXY();\n * Is this a XY spectrum?\n * @returns {*}\n */\nSD.prototype.isDataClassXY = function(){\n    if(this.getSpectrum().isXYdata)\n        return  this.getSpectrum().isXYdata;\n    return false\n}\n\n/**\n * @function setDataType()\n * Set the data type for this spectrum. It could be one of the following:\n [\"INFRARED\"||\"IR\",\"IV\",\"NDNMRSPEC\",\"NDNMRFID\",\"NMRSPEC\",\"NMRFID\",\"HPLC\",\"MASS\"\n * \"UV\", \"RAMAN\" \"GC\"|| \"GASCHROMATOGRAPH\",\"CD\"|| \"DICHRO\",\"XY\",\"DEC\"]\n * @param dataType\n */\nSD.prototype.setDataType = function(dataType){\n    this.getSpectrum().dataType=dataType;\n}\n\n/**\n * @function getDataType()\n * Return the dataType(see: setDataType )\n * @returns {string|string|*|string}\n */\nSD.prototype.getDataType = function(){\n    return this.getSpectrum().dataType;\n}\n\n/**\n * @function getSpectrumData()\n * Return the i-th sub-spectrum data in the current spectrum\n * @param i\n * @returns {this.sd.spectra[i].data[0]}\n */\nSD.prototype.getSpectrumData=function(i) {\n    i=i||this.activeElement;\n    return this.sd.spectra[i].data[0];\n}\n\n/**\n * @function getSpectrum()\n * Return the i-th sub-spectra in the current spectrum\n * @param i\n * @returns {this.sd.spectra[i]}\n */\nSD.prototype.getSpectrum=function(i) {\n    i=i||this.activeElement;\n    return this.sd.spectra[i];\n}\n\n/**\n * @function getNbSubSpectra()\n * Return the amount of sub-spectra in this object\n * @returns {*}\n */\nSD.prototype.getNbSubSpectra=function(){\n    return this.sd.spectra.length;\n}\n\n/**\n * @function getXData()\n *  Returns an array containing the x values of the spectrum\n * @param i sub-spectrum Default:activeSpectrum\n * @returns {Array}\n */\nSD.prototype.getXData=function(i){\n    return this.getSpectrumData(i).x;\n}\n\n/**\n * @function getYData()\n * This function returns a double array containing the values with the intensities for the current sub-spectrum.\n * @param i sub-spectrum Default:activeSpectrum\n * @returns {Array}\n */\nSD.prototype.getYData=function(i){\n    return this.getSpectrumData(i).y;\n}\n\n/**\n * @function getX()\n * Returns the x value at the specified index for the active sub-spectrum.\n * @param i array index between 0 and spectrum.getNbPoints()-1\n * @returns {number}\n */\nSD.prototype.getX=function(i){\n    return this.getXData()[i];\n}\n\n/**\n * @function getY()\n * Returns the y value at the specified index for the active sub-spectrum.\n * @param i array index between 0 and spectrum.getNbPoints()-1\n * @returns {number}\n */\nSD.prototype.getY=function(i){\n    return this.getYData()[i];\n}\n\n/**\n * @function getXYData();\n * Returns a double[2][nbPoints] where the first row contains the x values and the second row the y values.\n * @param i sub-spectrum Default:activeSpectrum\n * @returns {*[]}\n */\nSD.prototype.getXYData=function(i){\n    return [this.getXData(i),this.getYData(i)];\n}\n\n/**\n * @function getTitle\n * Return the title of the current spectrum.\n * @param i sub-spectrum Default:activeSpectrum\n * @returns {*}\n */\nSD.prototype.getTitle=function(i) {\n    return this.getSpectrum(i).title;\n}\n\n/**\n * @function setTitle(newTitle);\n * Set the title of this spectrum.\n * @param newTitle The new title\n * @param i sub-spectrum Default:activeSpectrum\n */\nSD.prototype.setTitle=function(newTitle,i) {\n    this.getSpectrum(i).title=newTitle;\n}\n\n/**\n * @function getMinY(i)\n * This function returns the minimal value of Y\n * @param i sub-spectrum Default:activeSpectrum\n * @returns {number}\n */\nSD.prototype.getMinY=function(i) {\n    return  StatArray.min(this.getYData(i));\n}\n\n/**\n * @function getMaxY(i)\n * This function returns the maximal value of Y\n * @param i sub-spectrum Default:activeSpectrum\n * @returns {number}\n */\nSD.prototype.getMaxY=function(i) {\n    return  StatArray.max(this.getYData(i));\n}\n\n/**\n * @function getMinMax(i)\n * Return the min and max value of Y\n * @param i sub-spectrum Default:activeSpectrum\n * @returns {{min, max}|*}\n */\nSD.prototype.getMinMaxY=function(i) {\n    return  StatArray.minMax(this.getYData(i));\n}\n\n\n/**\n * @function getNoiseLevel()\n * Get the noise threshold level of the current spectrum. It uses median instead of the mean\n * @returns {number}\n */\nSD.prototype.getNoiseLevel=function(){\n    var mean = 0,stddev=0;\n    var y = this.getYData();\n    var length = this.getNbPoints(),i=0;\n    for(i = 0; i < length; i++){\n        mean+=y[i];\n    }\n    mean/=this.getNbPoints();\n    var averageDeviations = new Array(length);\n    for (i = 0; i < length; i++)\n        averageDeviations[i] = Math.abs(y[i] - mean);\n    averageDeviations.sort();\n    if (length % 2 == 1) {\n        stddev = averageDeviations[(length-1)/2] / 0.6745;\n    } else {\n        stddev = 0.5*(averageDeviations[length/2]+averageDeviations[length/2-1]) / 0.6745;\n    }\n\n    return stddev*this.getNMRPeakThreshold(this.getNucleus(1));\n}\n\n/**\n * @function arrayPointToUnits(doublePoint)\n * Return the xValue for the given index.\n * @param doublePoint\n * @returns {number}\n */\nSD.prototype.arrayPointToUnits=function(doublePoint){\n    return (this.getFirstX() - (doublePoint* (this.getFirstX() - this.getLastX()) / (this.getNbPoints()-1)));\n}\n\n/**\n * @function unitsToArrayPoint(inValue)\n * Returns the index-value for the data array corresponding to a X-value in\n * units for the element of spectraData to which it is linked (spectraNb).\n * This method makes use of spectraData.getFirstX(), spectraData.getLastX()\n * and spectraData.getNbPoints() to derive the return value if it of data class XY\n * It performs a binary search if the spectrum is a peak table\n * @param inValue\n *            (value in Units to be converted)\n * @return {number} An integer representing the index value of the inValue\n */\nSD.prototype.unitsToArrayPoint=function(inValue){\n    if (this.isDataClassXY()) {\n        return Math.round((this.getFirstX() - inValue) * (-1.0 / this.getDeltaX()));\n    } else if (this.isDataClassPeak())\n    {\n        var currentArrayPoint = 0,upperLimit=this.getNbPoints()-1, lowerLimit=0, midPoint;\n        //If inverted scale\n        if(this.getFirstX()>this.getLastX()){\n            upperLimit=0;\n            lowerLimit=this.getNbPoints()-1;\n\n            if(inValue>this.getFirstX())\n                return this.getNbPoints();\n            if(inValue<this.getLastX())\n                return -1;\n        }\n        else{\n            if(inValue<this.getFirstX())\n                return -1;\n            if(inValue>this.getLastX())\n                return this.getNbPoints();\n        }\n\n        while (Math.abs(upperLimit-lowerLimit) > 1)\n        {\n            midPoint=Math.round(Math.floor((upperLimit+lowerLimit)/2));\n            //x=this.getX(midPoint);\n            if(this.getX(midPoint)==inValue)\n                return midPoint;\n            if(this.getX(midPoint)>inValue)\n                upperLimit=midPoint;\n            else\n                lowerLimit=midPoint;\n        }\n        currentArrayPoint=lowerLimit;\n        if(Math.abs(this.getX(lowerLimit)-inValue)>Math.abs(this.getX(upperLimit)-inValue))\n            currentArrayPoint=upperLimit;\n        return currentArrayPoint;\n    } else {\n        return 0;\n    }\n}\n\n/**\n * @function getDeltaX()\n * Returns the separation between 2 consecutive points in the spectrum domain\n * @returns {number}\n */\nSD.prototype.getDeltaX=function(){\n    return (this.getLastX()-this.getFirstX()) / (this.getNbPoints()-1);\n}\n\n/**\n * @function setMinMax(min,max)\n * This function scales the values of Y between the min and max parameters\n * @param min   Minimum desired value for Y\n * @param max   Maximum desired value for Y\n */\nSD.prototype.setMinMax=function(min,max) {\n    var y = this.getYData();\n    var minMax = StatArray.minMax(y);\n    var factor = (max - min)/(minMax.max-minMax.min);\n    for(var i=0;i< y.length;i++){\n        y[i]=(y[i]-minMax.min)*factor+min;\n    }\n}\n\n/**\n * @function setMin(min)\n * This function scales the values of Y to fit the min parameter\n * @param min   Minimum desired value for Y\n */\nSD.prototype.setMin=function(min) {\n    var y = this.getYData();\n    var currentMin = StatArray.min(y);\n    var factor = min/currentMin;\n    for(var i=0;i< y.length;i++){\n        y[i]*=factor;\n    }\n}\n\n/**\n * @function setMax(max)\n * This function scales the values of Y to fit the max parameter\n * @param max   Maximum desired value for Y\n */\nSD.prototype.setMax=function(max) {\n    var y = this.getYData();\n    var currentMin = StatArray.max(y);\n    var factor = max/currentMin;\n    for(var i=0;i< y.length;i++){\n        y[i]*=factor;\n    }\n}\n\n/**\n * @function YShift(value)\n * This function shifts the values of Y\n * @param value Distance of the shift\n */\nSD.prototype.YShift=function(value) {\n    var y = this.getSpectrumData().y;\n    var length = this.getNbPoints(),i=0;\n    for(i=0;i<length;i++){\n        y[i]+=value;\n    }\n    this.getSpectrum().firstY+=value;\n    this.getSpectrum().lastY+=value;\n}\n\n/**\n * @function shift(globalShift)\n * This function shift the given spectraData. After this function is applied, all the peaks in the\n * spectraData will be found at xi+globalShift\n * @param globalShift\n */\nSD.prototype.shift=function(globalShift) {\n    for(var i=0;i<this.getNbSubSpectra();i++){\n        this.setActiveElement(i);\n        var x = this.getSpectrumData().x;\n        var length = this.getNbPoints(),i=0;\n        for(i=0;i<length;i++){\n            x[i]+=globalShift;\n        }\n\n        this.getSpectrum().firstX+=globalShift;\n        this.getSpectrum().lastX+=globalShift;\n    }\n\n}\n\n/**\n * @function fillWith(from, to, value)\n * This function fills a zone of the spectrum with the given value.\n * @param from\n * @param to\n * @param fillWith\n */\nSD.prototype.fillWith=function(from, to, value) {\n    var tmp, start, end, x, y;\n    if(from > to) {\n        var tmp = from;\n        from = to;\n        to = tmp;\n    }\n\n    for(var i=0;i<this.getNbSubSpectra();i++){\n        this.setActiveElement(i);\n        x = this.getXData();\n        y = this.getYData();\n        start = this.unitsToArrayPoint(from);\n        end = this.unitsToArrayPoint(to);\n        if(start > end){\n            tmp = start;\n            start = end;\n            end = tmp;\n        }\n        if(start<0)\n            start=0;\n        if(end>=this.getNbPoints)\n            end=this.getNbPoints-1;\n        for(i=start;i<=end;i++){\n                y[i]=value;\n        }\n    }\n}\n\n/**\n * @function suppressZone(from, to)\n * This function suppress a zone from the given spectraData within the given x range.\n * Returns a spectraData of type PEAKDATA without peaks in the given region\n * @param from\n * @param to\n */\nSD.prototype.suppressZone=function(from, to) {\n    var tmp, start, end, x, y;\n    if(from > to) {\n        var tmp = from;\n        from = to;\n        to = tmp;\n    }\n\n    for(var i=0;i<this.getNbSubSpectra();i++){\n        this.setActiveElement(i);\n        x = this.getXData();\n        y = this.getYData();\n        start = this.unitsToArrayPoint(from);\n        end = this.unitsToArrayPoint(to);\n        if(start > end){\n            tmp = start;\n            start = end;\n            end = tmp;\n        }\n        if(start<0)\n            start=0;\n        if(end>=this.getNbPoints)\n            end=this.getNbPoints-1;\n        for(i=end;i>=start;i--){\n            y.splice(i,1);\n            x.splice(i,1);\n        }\n    }\n    this.setDataClass(this.DATACLASS_PEAK);\n}\n\n\n/**\n * @function peakPicking(parameters)\n * This function performs a simple peak detection in a spectraData. The parameters that can be specified are:\n * Returns a two dimensional array of double specifying [x,y] of the detected peaks.\n * @option from:    Lower limit.\n * @option to:      Upper limit.\n * @option threshold: The minimum intensity to consider a peak as a signal, expressed as a percentage of the highest peak.\n * @option stdev: Number of standard deviation of the noise for the threshold calculation if a threshold is not specified.\n * @option resolution: The maximum resolution of the spectrum for considering peaks.\n * @option yInverted: Is it a Y inverted spectrum?(like an IR spectrum)\n * @option smooth: A function for smoothing the spectraData before the detection. If your are dealing with\n * experimental spectra, smoothing will make the algorithm less prune to false positives.\n */\nSD.prototype.simplePeakPicking=function(parameters) {\n    //@TODO implements this filter\n}\n\n/**\n * @function getMaxPeak()\n * Get the maximum peak\n * @returns {[x, y]}\n */\nSD.prototype.getMaxPeak = function(){\n    var y = this.getSpectraDataY();\n    var max=y[0], index=0;\n    for(var i=0;i< y.length;i++){\n        if(max<y[i]){\n            max = y[i];\n            index=i;\n        }\n    }\n    return [this.getX(index),max];\n}\n\n/**\n * @function getParamDouble(name, defvalue);\n * Get the value of the parameter\n * @param  name The parameter name\n * @param  defvalue The default value\n * @returns {number}\n */\nSD.prototype.getParamDouble = function(name, defvalue){\n    var value = this.sd.info[name];\n    if(!value)\n        value = defvalue;\n    return value;\n}\n\n/**\n * @function getParamString(name, defvalue);\n * Get the value of the parameter\n * @param  name The parameter name\n * @param  defvalue The default value\n * @returns {string}\n */\nSD.prototype.getParamString = function(name, defvalue){\n    var value = this.sd.info[name];\n    if(!value)\n        value = defvalue;\n    return value+\"\";\n}\n\n/**\n * @function getParamInt(name, defvalue);\n * Get the value of the parameter\n * @param  name The parameter name\n * @param  defvalue The default value\n * @returns {number}\n */\nSD.prototype.getParamInt = function(name, defvalue){\n    var value = this.sd.info[name];\n    if(!value)\n        value = defvalue;\n    return value;\n}\n\n/**\n * @function getParam(name, defvalue);\n * Get the value of the parameter\n * @param  name The parameter name\n * @param  defvalue The default value\n * @returns {*}\n */\nSD.prototype.getParam = function(name, defvalue){\n    var value = this.sd.info[name];\n    if(!value)\n        value = defvalue;\n    return value;\n}\n\n/**\n * @function containsParam(name)\n *True if the spectrum.info contains the given parameter\n * @param name\n * @returns {boolean}\n */\nSD.prototype.containsParam = function(name){\n    if(this.sd.info[name]){\n        return true;\n    }\n    return false;\n}\n\n/**\n * @function getSpectraDataY()\n * Return the y elements of the current spectrum. Same as getYData. Kept for backward compatibility.\n * @returns {Array}\n */\nSD.prototype.getSpectraDataY = function(){\n    return this.getYData();\n}\n\n/**\n * @function getSpectraDataX()\n * Return the x elements of the current spectrum. Same as getXData. Kept for backward compatibility.\n * @returns {Array}\n */\nSD.prototype.getSpectraDataX = function(){\n    return this.getXData();\n}\n\n/**\n * @function resetMinMax()\n * Update min max values of X and Yaxis.\n */\nSD.prototype.resetMinMax = function(){\n    //TODO Impelement this function\n}\n\n/**\n * @function putParam(name, value)\n * Set a new parameter to this spectrum\n * @param name\n * @param value\n */\nSD.prototype.putParam = function(name, value){\n    this.sd.info[name]=value;\n}\n\n/**\n * @function getArea(from, to)\n * This function returns the area under the spectrum in the given window\n * @param from in spectrum units\n * @param to in spectrum units\n * @returns {number}\n */\nSD.prototype.getArea = function(from, to){\n    var i0 = this.unitsToArrayPoint(from);\n    var ie = this.unitsToArrayPoint(to);\n    var area = 0;\n    if(i0>ie){\n        var tmp = i0;\n        i0 = ie;\n        ie = tmp;\n    }\n    i0=i0<0?0:i0;\n    ie=ie>=this.getNbPoints()?this.getNbPoints()-1:ie;\n    for(var i=i0;i<ie;i++){\n        area+= this.getY(i);\n    }\n    return area*Math.abs(this.getDeltaX());\n},\n\n/**\n * @function getVector(from, to, nPoints)\n * Returns a equally spaced vector within the given window.\n * @param from in spectrum units\n * @param to in spectrum units\n * @param nPoints number of points to return(!!!sometimes it is not possible to return exactly the required nbPoints)\n * @returns [x,y]\n */\nSD.prototype.getVector = function(from, to, nPoints){\n    var x = this.getSpectraDataX();\n    var y = this.getSpectraDataY();\n    var result = [];\n    var start = 0, end = x.length- 1,direction=1;\n    var reversed = false;\n\n    if(x[0]>x[1]){\n        direction = -1;\n        start= x.length-1;\n        end = 0;\n    }\n\n    if(from > to){\n        var tmp = from;\n        from = to;\n        to = tmp;\n        reversed = true;\n    }\n    //console.log(x[end]+\" \"+from+\" \"+x[start]+\" \"+to);\n    if(x[start]>to||x[end]<from){\n        //console.log(\"ssss\");\n        return [];\n    }\n\n    while(x[start]<from){start+=direction;}\n    while(x[end]>to){end-=direction;}\n\n    var winPoints = Math.abs(end-start)+1;\n    if(!nPoints){\n        nPoints = winPoints;\n    }\n    var xwin = new Array(nPoints);\n    var ywin = new Array(nPoints);\n    var index = 0;\n\n    if(direction==-1)\n        index=nPoints-1;\n\n    var di = winPoints/nPoints;\n    var i=start-direction;\n    for(var k=0;k<nPoints;k++) {\n        i += Math.round(di * direction);\n        //console.log(i+\" \"+y[i]);\n        xwin[index] = x[i];\n        ywin[index] = y[i];\n        index += direction;\n    }\n    return [xwin,ywin];\n}\n\n/**\n * @function is2D()\n * Is it a 2D spectrum?\n * @returns {boolean}\n */\nSD.prototype.is2D = function(){\n    if(typeof this.sd.twoD == \"undefined\")\n        return false;\n    return this.sd.twoD;\n}\n\n/**\n * @function toJcamp(options)\n * This function creates a String that represents the given spectraData in the format JCAM-DX 5.0\n * The X,Y data can be compressed using one of the methods described in:\n * \"JCAMP-DX. A STANDARD FORMAT FOR THE EXCHANGE OF ION MOBILITY SPECTROMETRY DATA\",\n *  http://www.iupac.org/publications/pac/pdf/2001/pdf/7311x1765.pdf\n * @option encode: ['FIX','SQZ','DIF','DIFDUP','CVS','PAC'] (Default: 'DIFDUP')\n * @option yfactor: The YFACTOR. It allows to compress the data by removing digits from the ordinate. (Default: 1)\n * @option type: [\"NTUPLES\", \"SIMPLE\"] (Default: \"SIMPLE\")\n * @option keep: A set of user defined parameters of the given SpectraData to be stored in the jcamp.\n * @returns a string containing the jcamp-DX file\n * @example SD.toJcamp(spectraData,{encode:'DIFDUP',yfactor:0.01,type:\"SIMPLE\",keep:['#batchID','#url']});\n */\nSD.prototype.toJcamp=function(options) {\n    var defaultOptions = {\"encode\":\"DIFDUP\",\"yFactor\":1,\"type\":\"SIMPLE\",\"keep\":[]};\n    options = extend({}, defaultOptions, options);\n    return JcampCreator.convert(this, options.encode, options.yFactor, options.type, options.keep);\n}\n\n\nmodule.exports = SD;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/spectra-data/src/SD.js\n ** module id = 3\n ** module chunks = 0\n **/","'use strict';\n\nfunction compareNumbers(a, b) {\n    return a - b;\n}\n\n/**\n * Computes the sum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.sum = function sum(values) {\n    var sum = 0;\n    for (var i = 0; i < values.length; i++) {\n        sum += values[i];\n    }\n    return sum;\n};\n\n/**\n * Computes the maximum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.max = function max(values) {\n    var max = -Infinity;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] > max) max = values[i];\n    }\n    return max;\n};\n\n/**\n * Computes the minimum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.min = function min(values) {\n    var min = Infinity;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] < min) min = values[i];\n    }\n    return min;\n};\n\n/**\n * Computes the min and max of the given values\n * @param {Array} values\n * @returns {{min: number, max: number}}\n */\nexports.minMax = function minMax(values) {\n    var min = Infinity;\n    var max = -Infinity;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] < min) min = values[i];\n        if (values[i] > max) max = values[i];\n    }\n    return {\n        min: min,\n        max: max\n    };\n};\n\n/**\n * Computes the arithmetic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.arithmeticMean = function arithmeticMean(values) {\n    var sum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        sum += values[i];\n    }\n    return sum / l;\n};\n\n/**\n * {@link arithmeticMean}\n */\nexports.mean = exports.arithmeticMean;\n\n/**\n * Computes the geometric mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.geometricMean = function geometricMean(values) {\n    var mul = 1;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        mul *= values[i];\n    }\n    return Math.pow(mul, 1 / l);\n};\n\n/**\n * Computes the mean of the log of the given values\n * If the return value is exponentiated, it gives the same result as the\n * geometric mean.\n * @param {Array} values\n * @returns {number}\n */\nexports.logMean = function logMean(values) {\n    var lnsum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        lnsum += Math.log(values[i]);\n    }\n    return lnsum / l;\n};\n\n/**\n * Computes the weighted grand mean for a list of means and sample sizes\n * @param {Array} means - Mean values for each set of samples\n * @param {Array} samples - Number of original values for each set of samples\n * @returns {number}\n */\nexports.grandMean = function grandMean(means, samples) {\n    var sum = 0;\n    var n = 0;\n    var l = means.length;\n    for (var i = 0; i < l; i++) {\n        sum += samples[i] * means[i];\n        n += samples[i];\n    }\n    return sum / n;\n};\n\n/**\n * Computes the truncated mean of the given values using a given percentage\n * @param {Array} values\n * @param {number} percent - The percentage of values to keep (range: [0,1])\n * @param {boolean} [alreadySorted=false]\n * @returns {number}\n */\nexports.truncatedMean = function truncatedMean(values, percent, alreadySorted) {\n    if (alreadySorted === undefined) alreadySorted = false;\n    if (!alreadySorted) {\n        values = values.slice().sort(compareNumbers);\n    }\n    var l = values.length;\n    var k = Math.floor(l * percent);\n    var sum = 0;\n    for (var i = k; i < (l - k); i++) {\n        sum += values[i];\n    }\n    return sum / (l - 2 * k);\n};\n\n/**\n * Computes the harmonic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.harmonicMean = function harmonicMean(values) {\n    var sum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] === 0) {\n            throw new RangeError('value at index ' + i + 'is zero');\n        }\n        sum += 1 / values[i];\n    }\n    return l / sum;\n};\n\n/**\n * Computes the contraharmonic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.contraHarmonicMean = function contraHarmonicMean(values) {\n    var r1 = 0;\n    var r2 = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        r1 += values[i] * values[i];\n        r2 += values[i];\n    }\n    if (r2 < 0) {\n        throw new RangeError('sum of values is negative');\n    }\n    return r1 / r2;\n};\n\n/**\n * Computes the median of the given values\n * @param {Array} values\n * @param {boolean} [alreadySorted=false]\n * @returns {number}\n */\nexports.median = function median(values, alreadySorted) {\n    if (alreadySorted === undefined) alreadySorted = false;\n    if (!alreadySorted) {\n        values = values.slice().sort(compareNumbers);\n    }\n    var l = values.length;\n    var half = Math.floor(l / 2);\n    if (l % 2 === 0) {\n        return (values[half - 1] + values[half]) * 0.5;\n    } else {\n        return values[half];\n    }\n};\n\n/**\n * Computes the variance of the given values\n * @param {Array} values\n * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n * @returns {number}\n */\nexports.variance = function variance(values, unbiased) {\n    if (unbiased === undefined) unbiased = true;\n    var theMean = exports.mean(values);\n    var theVariance = 0;\n    var l = values.length;\n\n    for (var i = 0; i < l; i++) {\n        var x = values[i] - theMean;\n        theVariance += x * x;\n    }\n\n    if (unbiased) {\n        return theVariance / (l - 1);\n    } else {\n        return theVariance / l;\n    }\n};\n\n/**\n * Computes the standard deviation of the given values\n * @param {Array} values\n * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n * @returns {number}\n */\nexports.standardDeviation = function standardDeviation(values, unbiased) {\n    return Math.sqrt(exports.variance(values, unbiased));\n};\n\nexports.standardError = function standardError(values) {\n    return exports.standardDeviation(values) / Math.sqrt(values.length);\n};\n\nexports.quartiles = function quartiles(values, alreadySorted) {\n    if (typeof(alreadySorted) === 'undefined') alreadySorted = false;\n    if (!alreadySorted) {\n        values = values.slice();\n        values.sort(compareNumbers);\n    }\n\n    var quart = values.length / 4;\n    var q1 = values[Math.ceil(quart) - 1];\n    var q2 = exports.median(values, true);\n    var q3 = values[Math.ceil(quart * 3) - 1];\n\n    return {q1: q1, q2: q2, q3: q3};\n};\n\nexports.pooledStandardDeviation = function pooledStandardDeviation(samples, unbiased) {\n    return Math.sqrt(exports.pooledVariance(samples, unbiased));\n};\n\nexports.pooledVariance = function pooledVariance(samples, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var sum = 0;\n    var length = 0, l = samples.length;\n    for (var i = 0; i < l; i++) {\n        var values = samples[i];\n        var vari = exports.variance(values);\n\n        sum += (values.length - 1) * vari;\n\n        if (unbiased)\n            length += values.length - 1;\n        else\n            length += values.length;\n    }\n    return sum / length;\n};\n\nexports.mode = function mode(values) {\n    var l = values.length,\n        itemCount = new Array(l),\n        i;\n    for (i = 0; i < l; i++) {\n        itemCount[i] = 0;\n    }\n    var itemArray = new Array(l);\n    var count = 0;\n\n    for (i = 0; i < l; i++) {\n        var index = itemArray.indexOf(values[i]);\n        if (index >= 0)\n            itemCount[index]++;\n        else {\n            itemArray[count] = values[i];\n            itemCount[count] = 1;\n            count++;\n        }\n    }\n\n    var maxValue = 0, maxIndex = 0;\n    for (i = 0; i < count; i++) {\n        if (itemCount[i] > maxValue) {\n            maxValue = itemCount[i];\n            maxIndex = i;\n        }\n    }\n\n    return itemArray[maxIndex];\n};\n\nexports.covariance = function covariance(vector1, vector2, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var mean1 = exports.mean(vector1);\n    var mean2 = exports.mean(vector2);\n\n    if (vector1.length !== vector2.length)\n        throw \"Vectors do not have the same dimensions\";\n\n    var cov = 0, l = vector1.length;\n    for (var i = 0; i < l; i++) {\n        var x = vector1[i] - mean1;\n        var y = vector2[i] - mean2;\n        cov += x * y;\n    }\n\n    if (unbiased)\n        return cov / (l - 1);\n    else\n        return cov / l;\n};\n\nexports.skewness = function skewness(values, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var theMean = exports.mean(values);\n\n    var s2 = 0, s3 = 0, l = values.length;\n    for (var i = 0; i < l; i++) {\n        var dev = values[i] - theMean;\n        s2 += dev * dev;\n        s3 += dev * dev * dev;\n    }\n    var m2 = s2 / l;\n    var m3 = s3 / l;\n\n    var g = m3 / (Math.pow(m2, 3 / 2.0));\n    if (unbiased) {\n        var a = Math.sqrt(l * (l - 1));\n        var b = l - 2;\n        return (a / b) * g;\n    }\n    else {\n        return g;\n    }\n};\n\nexports.kurtosis = function kurtosis(values, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var theMean = exports.mean(values);\n    var n = values.length, s2 = 0, s4 = 0;\n\n    for (var i = 0; i < n; i++) {\n        var dev = values[i] - theMean;\n        s2 += dev * dev;\n        s4 += dev * dev * dev * dev;\n    }\n    var m2 = s2 / n;\n    var m4 = s4 / n;\n\n    if (unbiased) {\n        var v = s2 / (n - 1);\n        var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n        var b = s4 / (v * v);\n        var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n\n        return a * b - 3 * c;\n    }\n    else {\n        return m4 / (m2 * m2) - 3;\n    }\n};\n\nexports.entropy = function entropy(values, eps) {\n    if (typeof(eps) === 'undefined') eps = 0;\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum += values[i] * Math.log(values[i] + eps);\n    return -sum;\n};\n\nexports.weightedMean = function weightedMean(values, weights) {\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum += values[i] * weights[i];\n    return sum;\n};\n\nexports.weightedStandardDeviation = function weightedStandardDeviation(values, weights) {\n    return Math.sqrt(exports.weightedVariance(values, weights));\n};\n\nexports.weightedVariance = function weightedVariance(values, weights) {\n    var theMean = exports.weightedMean(values, weights);\n    var vari = 0, l = values.length;\n    var a = 0, b = 0;\n\n    for (var i = 0; i < l; i++) {\n        var z = values[i] - theMean;\n        var w = weights[i];\n\n        vari += w * (z * z);\n        b += w;\n        a += w * w;\n    }\n\n    return vari * (b / (b * b - a));\n};\n\nexports.center = function center(values, inPlace) {\n    if (typeof(inPlace) === 'undefined') inPlace = false;\n\n    var result = values;\n    if (!inPlace)\n        result = values.slice();\n\n    var theMean = exports.mean(result), l = result.length;\n    for (var i = 0; i < l; i++)\n        result[i] -= theMean;\n};\n\nexports.standardize = function standardize(values, standardDev, inPlace) {\n    if (typeof(standardDev) === 'undefined') standardDev = exports.standardDeviation(values);\n    if (typeof(inPlace) === 'undefined') inPlace = false;\n    var l = values.length;\n    var result = inPlace ? values : new Array(l);\n    for (var i = 0; i < l; i++)\n        result[i] = values[i] / standardDev;\n    return result;\n};\n\nexports.cumulativeSum = function cumulativeSum(array) {\n    var l = array.length;\n    var result = new Array(l);\n    result[0] = array[0];\n    for (var i = 1; i < l; i++)\n        result[i] = result[i - 1] + array[i];\n    return result;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-stat/array.js\n ** module id = 4\n ** module chunks = 0\n **/","'use strict';\n\nvar parseXYDataRegExp = require('./parseXYData.js');\n\n\nfunction getConverter() {\n\n    // the following RegExp can only be used for XYdata, some peakTables have values with a \"E-5\" ...\n    var ntuplesSeparator = /[, \\t]{1,}/;\n\n    var GC_MS_FIELDS = ['TIC', '.RIC', 'SCANNUMBER'];\n\n    function convertToFloatArray(stringArray) {\n        var l = stringArray.length;\n        var floatArray = new Array(l);\n        for (var i = 0; i < l; i++) {\n            floatArray[i] = parseFloat(stringArray[i]);\n        }\n        return floatArray;\n    }\n    \n    function Spectrum() {\n        \n    }\n\n    /*\n     options.keepSpectra: keep the original spectra for a 2D\n     options.xy: true // create x / y array instead of a 1D array\n     options.keepRecordsRegExp: which fields do we keep\n     */\n\n    function convert(jcamp, options) {\n        options = options || {};\n\n        var keepRecordsRegExp = /^$/;\n        if (options.keepRecordsRegExp) keepRecordsRegExp = options.keepRecordsRegExp;\n\n        var start = Date.now();\n\n        var ntuples = {},\n            ldr,\n            dataLabel,\n            dataValue,\n            ldrs,\n            i, ii, position, endLine, infos;\n\n        var result = {};\n        result.profiling = [];\n        result.logs = [];\n        var spectra = [];\n        result.spectra = spectra;\n        result.info = {};\n        var spectrum = new Spectrum();\n\n        if (!(typeof jcamp === 'string')) return result;\n        // console.time('start');\n\n        if (result.profiling) result.profiling.push({\n            action: 'Before split to LDRS',\n            time: Date.now() - start\n        });\n\n        ldrs = jcamp.split(/[\\r\\n]+##/);\n\n        if (result.profiling) result.profiling.push({\n            action: 'Split to LDRS',\n            time: Date.now() - start\n        });\n\n        if (ldrs[0]) ldrs[0] = ldrs[0].replace(/^[\\r\\n ]*##/, '');\n\n        for (i = 0, ii = ldrs.length; i < ii; i++) {\n            ldr = ldrs[i];\n            // This is a new LDR\n            position = ldr.indexOf('=');\n            if (position > 0) {\n                dataLabel = ldr.substring(0, position);\n                dataValue = ldr.substring(position + 1).trim();\n            } else {\n                dataLabel = ldr;\n                dataValue = '';\n            }\n            dataLabel = dataLabel.replace(/[_ -]/g, '').toUpperCase();\n\n            if (dataLabel === 'DATATABLE') {\n                endLine = dataValue.indexOf('\\n');\n                if (endLine === -1) endLine = dataValue.indexOf('\\r');\n                if (endLine > 0) {\n                    var xIndex = -1;\n                    var yIndex = -1;\n                    // ##DATA TABLE= (X++(I..I)), XYDATA\n                    // We need to find the variables\n\n                    infos = dataValue.substring(0, endLine).split(/[ ,;\\t]+/);\n                    if (infos[0].indexOf('++') > 0) {\n                        var firstVariable = infos[0].replace(/.*\\(([a-zA-Z0-9]+)\\+\\+.*/, '$1');\n                        var secondVariable = infos[0].replace(/.*\\.\\.([a-zA-Z0-9]+).*/, '$1');\n                        xIndex = ntuples.symbol.indexOf(firstVariable);\n                        yIndex = ntuples.symbol.indexOf(secondVariable);\n                    }\n\n                    if (xIndex === -1) xIndex = 0;\n                    if (yIndex === -1) yIndex = 0;\n\n                    if (ntuples.first) {\n                        if (ntuples.first.length > xIndex) spectrum.firstX = ntuples.first[xIndex];\n                        if (ntuples.first.length > yIndex) spectrum.firstY = ntuples.first[yIndex];\n                    }\n                    if (ntuples.last) {\n                        if (ntuples.last.length > xIndex) spectrum.lastX = ntuples.last[xIndex];\n                        if (ntuples.last.length > yIndex) spectrum.lastY = ntuples.last[yIndex];\n                    }\n                    if (ntuples.vardim && ntuples.vardim.length > xIndex) {\n                        spectrum.nbPoints = ntuples.vardim[xIndex];\n                    }\n                    if (ntuples.factor) {\n                        if (ntuples.factor.length > xIndex) spectrum.xFactor = ntuples.factor[xIndex];\n                        if (ntuples.factor.length > yIndex) spectrum.yFactor = ntuples.factor[yIndex];\n                    }\n                    if (ntuples.units) {\n                        if (ntuples.units.length > xIndex) spectrum.xUnit = ntuples.units[xIndex];\n                        if (ntuples.units.length > yIndex) spectrum.yUnit = ntuples.units[yIndex];\n                    }\n                    spectrum.datatable = infos[0];\n                    if (infos[1] && infos[1].indexOf('PEAKS') > -1) {\n                        dataLabel = 'PEAKTABLE';\n                    } else if (infos[1] && (infos[1].indexOf('XYDATA') || infos[0].indexOf('++') > 0)) {\n                        dataLabel = 'XYDATA';\n                        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n                    }\n                }\n            }\n\n\n            if (dataLabel === 'TITLE') {\n                spectrum.title = dataValue;\n            } else if (dataLabel === 'DATATYPE') {\n                spectrum.dataType = dataValue;\n                if (dataValue.indexOf('nD') > -1) {\n                    result.twoD = true;\n                }\n            } else if (dataLabel === 'NTUPLES') {\n                if (dataValue.indexOf('nD') > -1) {\n                    result.twoD = true;\n                }\n            } else if (dataLabel === 'XUNITS') {\n                spectrum.xUnit = dataValue;\n            } else if (dataLabel === 'YUNITS') {\n                spectrum.yUnit = dataValue;\n            } else if (dataLabel === 'FIRSTX') {\n                spectrum.firstX = parseFloat(dataValue);\n            } else if (dataLabel === 'LASTX') {\n                spectrum.lastX = parseFloat(dataValue);\n            } else if (dataLabel === 'FIRSTY') {\n                spectrum.firstY = parseFloat(dataValue);\n            } else if (dataLabel === 'LASTY') {\n                spectrum.lastY = parseFloat(dataValue);\n            } else if (dataLabel === 'NPOINTS') {\n                spectrum.nbPoints = parseFloat(dataValue);\n            } else if (dataLabel === 'XFACTOR') {\n                spectrum.xFactor = parseFloat(dataValue);\n            } else if (dataLabel === 'YFACTOR') {\n                spectrum.yFactor = parseFloat(dataValue);\n            } else if (dataLabel === 'DELTAX') {\n                spectrum.deltaX = parseFloat(dataValue);\n            } else if (dataLabel === '.OBSERVEFREQUENCY' || dataLabel === '$SFO1') {\n                if (!spectrum.observeFrequency) spectrum.observeFrequency = parseFloat(dataValue);\n            } else if (dataLabel === '.OBSERVENUCLEUS') {\n                if (!spectrum.xType) result.xType = dataValue.replace(/[^a-zA-Z0-9]/g, '');\n            } else if (dataLabel === '$SFO2') {\n                if (!result.indirectFrequency) result.indirectFrequency = parseFloat(dataValue);\n\n            } else if (dataLabel === '$OFFSET') {   // OFFSET for Bruker spectra\n                result.shiftOffsetNum = 0;\n                if (!result.shiftOffsetVal)  result.shiftOffsetVal = parseFloat(dataValue);\n            } else if (dataLabel === '$REFERENCEPOINT') {   // OFFSET for Varian spectra\n\n\n                // if we activate this part it does not work for ACD specmanager\n                //         } else if (dataLabel=='.SHIFTREFERENCE') {   // OFFSET FOR Bruker Spectra\n                //                 var parts = dataValue.split(/ *, */);\n                //                 result.shiftOffsetNum = parseInt(parts[2].trim());\n                //                 result.shiftOffsetVal = parseFloat(parts[3].trim());\n            } else if (dataLabel === 'VARNAME') {\n                ntuples.varname = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'SYMBOL') {\n                ntuples.symbol = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'VARTYPE') {\n                ntuples.vartype = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'VARFORM') {\n                ntuples.varform = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'VARDIM') {\n                ntuples.vardim = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'UNITS') {\n                ntuples.units = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'FACTOR') {\n                ntuples.factor = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'FIRST') {\n                ntuples.first = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'LAST') {\n                ntuples.last = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'MIN') {\n                ntuples.min = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'MAX') {\n                ntuples.max = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === '.NUCLEUS') {\n                if (result.twoD) {\n                    result.yType = dataValue.split(ntuplesSeparator)[0];\n                }\n            } else if (dataLabel === 'PAGE') {\n                spectrum.page = dataValue.trim();\n                spectrum.pageValue = parseFloat(dataValue.replace(/^.*=/, ''));\n                spectrum.pageSymbol = spectrum.page.replace(/=.*/, '');\n                var pageSymbolIndex = ntuples.symbol.indexOf(spectrum.pageSymbol);\n                var unit = '';\n                if (ntuples.units && ntuples.units[pageSymbolIndex]) {\n                    unit = ntuples.units[pageSymbolIndex];\n                }\n                if (result.indirectFrequency && unit !== 'PPM') {\n                    spectrum.pageValue /= result.indirectFrequency;\n                }\n            } else if (dataLabel === 'RETENTIONTIME') {\n                spectrum.pageValue = parseFloat(dataValue);\n            } else if (dataLabel === 'XYDATA') {\n                prepareSpectrum(result, spectrum);\n                // well apparently we should still consider it is a PEAK TABLE if there are no '++' after\n                if (dataValue.match(/.*\\+\\+.*/)) {\n                    if (options.fastParse === false) {\n                        parseXYDataRegExp(spectrum, dataValue, result);\n                    } else {\n                        if (!spectrum.deltaX) {\n                            spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n                        }\n                        fastParseXYData(spectrum, dataValue, result);\n                    }\n                } else {\n                    parsePeakTable(spectrum, dataValue, result);\n                }\n                spectra.push(spectrum);\n                spectrum = new Spectrum();\n            } else if (dataLabel === 'PEAKTABLE') {\n                prepareSpectrum(result, spectrum);\n                parsePeakTable(spectrum, dataValue, result);\n                spectra.push(spectrum);\n                spectrum = new Spectrum();\n            } else if (isMSField(dataLabel)) {\n                spectrum[convertMSFieldToLabel(dataLabel)] = dataValue;\n            }\n            if (dataLabel.match(keepRecordsRegExp)) {\n                result.info[dataLabel] = dataValue.trim();\n            }\n        }\n\n        if (result.profiling) result.profiling.push({\n            action: 'Finished parsing',\n            time: Date.now() - start\n        });\n\n        if (Object.keys(ntuples).length > 0) {\n            var newNtuples = [];\n            var keys = Object.keys(ntuples);\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                var values = ntuples[key];\n                for (var j = 0; j < values.length; j++) {\n                    if (!newNtuples[j]) newNtuples[j] = {};\n                    newNtuples[j][key] = values[j];\n                }\n            }\n            result.ntuples = newNtuples;\n        }\n\n        if (result.twoD) {\n            add2D(result, options);\n            if (result.profiling) result.profiling.push({\n                action: 'Finished countour plot calculation',\n                time: Date.now() - start\n            });\n            if (!options.keepSpectra) {\n                delete result.spectra;\n            }\n        }\n\n        var isGCMS = (spectra.length > 1 && (!spectra[0].dataType || spectra[0].dataType.match(/.*mass.*/i)));\n        if (isGCMS && options.newGCMS) {\n            options.xy = true;\n        }\n\n        if (options.xy) { // the spectraData should not be a oneD array but an object with x and y\n            if (spectra.length > 0) {\n                for (var i = 0; i < spectra.length; i++) {\n                    var spectrum = spectra[i];\n                    if (spectrum.data.length > 0) {\n                        for (var j = 0; j < spectrum.data.length; j++) {\n                            var data = spectrum.data[j];\n                            var newData = {\n                                x: new Array(data.length / 2),\n                                y: new Array(data.length / 2)\n                            };\n                            for (var k = 0; k < data.length; k = k + 2) {\n                                newData.x[k / 2] = data[k];\n                                newData.y[k / 2] = data[k + 1];\n                            }\n                            spectrum.data[j] = newData;\n                        }\n\n                    }\n\n                }\n            }\n        }\n\n        // maybe it is a GC (HPLC) / MS. In this case we add a new format\n        if (isGCMS) {\n            if (options.newGCMS) {\n                addNewGCMS(result);\n            } else {\n                addGCMS(result);\n            }\n            if (result.profiling) result.profiling.push({\n                action: 'Finished GCMS calculation',\n                time: Date.now() - start\n            });\n        }\n\n        if (result.profiling) {\n            result.profiling.push({\n                action: 'Total time',\n                time: Date.now() - start\n            });\n        }\n\n        return result;\n    }\n\n\n    function convertMSFieldToLabel(value) {\n        return value.toLowerCase().replace(/[^a-z0-9]/g, '');\n    }\n\n    function isMSField(dataLabel) {\n        return GC_MS_FIELDS.indexOf(dataLabel) !== -1;\n    }\n\n    function addNewGCMS(result) {\n        var spectra = result.spectra;\n        var length = spectra.length;\n        var gcms = {\n            times: new Array(length),\n            series: [{\n                name: 'ms',\n                dimension: 2,\n                data: new Array(length)\n            }]\n        };\n\n        var i;\n        var existingGCMSFields = [];\n        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n            if (spectra[0][label]) {\n                existingGCMSFields.push(label);\n                gcms.series.push({\n                    name: label,\n                    dimension: 1,\n                    data: new Array(length)\n                });\n            }\n        }\n\n        for (i = 0; i < length; i++) {\n            var spectrum = spectra[i];\n            gcms.times[i] = spectrum.pageValue;\n            for (var j = 0; j < existingGCMSFields.length; j++) {\n                gcms.series[j + 1].data[i] = parseFloat(spectrum[existingGCMSFields[j]]);\n            }\n            if (spectrum.data) {\n                gcms.series[0].data[i] = [spectrum.data[0].x, spectrum.data[0].y];\n            }\n\n        }\n        result.gcms = gcms;\n    }\n\n    function addGCMS(result) {\n        var spectra = result.spectra;\n        var existingGCMSFields = [];\n        var i;\n        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n            if (spectra[0][label]) {\n                existingGCMSFields.push(label);\n            }\n        }\n        if (existingGCMSFields.length === 0) return;\n        var gcms = {};\n        gcms.gc = {};\n        gcms.ms = [];\n        for (i = 0; i < existingGCMSFields.length; i++) {\n            gcms.gc[existingGCMSFields[i]] = [];\n        }\n        for (i = 0; i < spectra.length; i++) {\n            var spectrum = spectra[i];\n            for (var j = 0; j < existingGCMSFields.length; j++) {\n                gcms.gc[existingGCMSFields[j]].push(spectrum.pageValue);\n                gcms.gc[existingGCMSFields[j]].push(parseFloat(spectrum[existingGCMSFields[j]]));\n            }\n            if (spectrum.data) gcms.ms[i] = spectrum.data[0];\n\n        }\n        result.gcms = gcms;\n    }\n\n    function prepareSpectrum(result, spectrum) {\n        if (!spectrum.xFactor) spectrum.xFactor = 1;\n        if (!spectrum.yFactor) spectrum.yFactor = 1;\n        if (spectrum.observeFrequency) {\n            if (spectrum.xUnit && spectrum.xUnit.toUpperCase() === 'HZ') {\n                spectrum.xUnit = 'PPM';\n                spectrum.xFactor = spectrum.xFactor / spectrum.observeFrequency;\n                spectrum.firstX = spectrum.firstX / spectrum.observeFrequency;\n                spectrum.lastX = spectrum.lastX / spectrum.observeFrequency;\n                spectrum.deltaX = spectrum.deltaX / spectrum.observeFrequency;\n            }\n        }\n        if (result.shiftOffsetVal) {\n            var shift = spectrum.firstX - result.shiftOffsetVal;\n            spectrum.firstX = spectrum.firstX - shift;\n            spectrum.lastX = spectrum.lastX - shift;\n        }\n    }\n\n\n    function convertTo3DZ(spectra) {\n        var noise = 0;\n        var minZ = spectra[0].data[0][0];\n        var maxZ = minZ;\n        var ySize = spectra.length;\n        var xSize = spectra[0].data[0].length / 2;\n        var z = new Array(ySize);\n        for (var i = 0; i < ySize; i++) {\n            z[i] = new Array(xSize);\n            var xVector = spectra[i].data[0];\n            for (var j = 0; j < xSize; j++) {\n                var value = xVector[j * 2 + 1];\n                z[i][j] = value;\n                if (value < minZ) minZ = value;\n                if (value > maxZ) maxZ = value;\n                if (i !== 0 && j !== 0) {\n                    noise += Math.abs(value - z[i][j - 1]) + Math.abs(value - z[i - 1][j]);\n                }\n            }\n        }\n        return {\n            z: z,\n            minX: spectra[0].data[0][0],\n            maxX: spectra[0].data[0][spectra[0].data[0].length - 2], // has to be -2 because it is a 1D array [x,y,x,y,...]\n            minY: spectra[0].pageValue,\n            maxY: spectra[ySize - 1].pageValue,\n            minZ: minZ,\n            maxZ: maxZ,\n            noise: noise / ((ySize - 1) * (xSize - 1) * 2)\n        };\n\n    }\n\n    function add2D(result, options) {\n        var zData = convertTo3DZ(result.spectra);\n        result.contourLines = generateContourLines(zData, options);\n        delete zData.z;\n        result.minMax = zData;\n    }\n\n\n    function generateContourLines(zData, options) {\n        var noise = zData.noise;\n        var z = zData.z;\n        var contourLevels = [];\n        var nbLevels = options.nbContourLevels || 7;\n        var noiseMultiplier = options.noiseMultiplier === undefined ? 5 : options.noiseMultiplier;\n        var povarHeight0, povarHeight1, povarHeight2, povarHeight3;\n        var isOver0, isOver1, isOver2, isOver3;\n        var nbSubSpectra = z.length;\n        var nbPovars = z[0].length;\n        var pAx, pAy, pBx, pBy;\n\n        var x0 = zData.minX;\n        var xN = zData.maxX;\n        var dx = (xN - x0) / (nbPovars - 1);\n        var y0 = zData.minY;\n        var yN = zData.maxY;\n        var dy = (yN - y0) / (nbSubSpectra - 1);\n        var minZ = zData.minZ;\n        var maxZ = zData.maxZ;\n\n        //System.out.prvarln('y0 '+y0+' yN '+yN);\n        // -------------------------\n        // Povars attribution\n        //\n        // 0----1\n        // |  / |\n        // | /  |\n        // 2----3\n        //\n        // ---------------------d------\n\n        var lineZValue;\n        for (var level = 0; level < nbLevels * 2; level++) { // multiply by 2 for positif and negatif\n            var contourLevel = {};\n            contourLevels[level] = contourLevel;\n            var side = level % 2;\n            var factor = (maxZ - noiseMultiplier * noise) * Math.exp((level >> 1) - nbLevels);\n            if (side === 0) {\n                lineZValue = factor + noiseMultiplier * noise;\n            } else {\n                lineZValue = -factor - noiseMultiplier * noise;\n            }\n            var lines = [];\n            contourLevel.zValue = lineZValue;\n            contourLevel.lines = lines;\n\n            if (lineZValue <= minZ || lineZValue >= maxZ) continue;\n\n            for (var iSubSpectra = 0; iSubSpectra < nbSubSpectra - 1; iSubSpectra++) {\n                var subSpectra = z[iSubSpectra];\n                var subSpectraAfter = z[iSubSpectra + 1];\n                for (var povar = 0; povar < nbPovars - 1; povar++) {\n                    povarHeight0 = subSpectra[povar];\n                    povarHeight1 = subSpectra[povar + 1];\n                    povarHeight2 = subSpectraAfter[povar];\n                    povarHeight3 = subSpectraAfter[povar + 1];\n\n                    isOver0 = (povarHeight0 > lineZValue);\n                    isOver1 = (povarHeight1 > lineZValue);\n                    isOver2 = (povarHeight2 > lineZValue);\n                    isOver3 = (povarHeight3 > lineZValue);\n\n                    // Example povar0 is over the plane and povar1 and\n                    // povar2 are below, we find the varersections and add\n                    // the segment\n                    if (isOver0 !== isOver1 && isOver0 !== isOver2) {\n                        pAx = povar + (lineZValue - povarHeight0) / (povarHeight1 - povarHeight0);\n                        pAy = iSubSpectra;\n                        pBx = povar;\n                        pBy = iSubSpectra + (lineZValue - povarHeight0) / (povarHeight2 - povarHeight0);\n                        lines.push(pAx * dx + x0);\n                        lines.push(pAy * dy + y0);\n                        lines.push(pBx * dx + x0);\n                        lines.push(pBy * dy + y0);\n                    }\n                    // remove push does not help !!!!\n                    if (isOver3 !== isOver1 && isOver3 !== isOver2) {\n                        pAx = povar + 1;\n                        pAy = iSubSpectra + 1 - (lineZValue - povarHeight3) / (povarHeight1 - povarHeight3);\n                        pBx = povar + 1 - (lineZValue - povarHeight3) / (povarHeight2 - povarHeight3);\n                        pBy = iSubSpectra + 1;\n                        lines.push(pAx * dx + x0);\n                        lines.push(pAy * dy + y0);\n                        lines.push(pBx * dx + x0);\n                        lines.push(pBy * dy + y0);\n                    }\n                    // test around the diagonal\n                    if (isOver1 !== isOver2) {\n                        pAx = (povar + 1 - (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) * dx + x0;\n                        pAy = (iSubSpectra + (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) * dy + y0;\n                        if (isOver1 !== isOver0) {\n                            pBx = povar + 1 - (lineZValue - povarHeight1) / (povarHeight0 - povarHeight1);\n                            pBy = iSubSpectra;\n                            lines.push(pAx);\n                            lines.push(pAy);\n                            lines.push(pBx * dx + x0);\n                            lines.push(pBy * dy + y0);\n                        }\n                        if (isOver2 !== isOver0) {\n                            pBx = povar;\n                            pBy = iSubSpectra + 1 - (lineZValue - povarHeight2) / (povarHeight0 - povarHeight2);\n                            lines.push(pAx);\n                            lines.push(pAy);\n                            lines.push(pBx * dx + x0);\n                            lines.push(pBy * dy + y0);\n                        }\n                        if (isOver1 !== isOver3) {\n                            pBx = povar + 1;\n                            pBy = iSubSpectra + (lineZValue - povarHeight1) / (povarHeight3 - povarHeight1);\n                            lines.push(pAx);\n                            lines.push(pAy);\n                            lines.push(pBx * dx + x0);\n                            lines.push(pBy * dy + y0);\n                        }\n                        if (isOver2 !== isOver3) {\n                            pBx = povar + (lineZValue - povarHeight2) / (povarHeight3 - povarHeight2);\n                            pBy = iSubSpectra + 1;\n                            lines.push(pAx);\n                            lines.push(pAy);\n                            lines.push(pBx * dx + x0);\n                            lines.push(pBy * dy + y0);\n                        }\n                    }\n                }\n            }\n        }\n\n        return {\n            minX: zData.minX,\n            maxX: zData.maxX,\n            minY: zData.minY,\n            maxY: zData.maxY,\n            segments: contourLevels\n        };\n    }\n\n    function fastParseXYData(spectrum, value) {\n        // TODO need to deal with result\n        //  console.log(value);\n        // we check if deltaX is defined otherwise we calculate it\n\n        var yFactor = spectrum.yFactor;\n        var deltaX = spectrum.deltaX;\n\n\n        spectrum.isXYdata = true;\n        // TODO to be improved using 2 array {x:[], y:[]}\n        var currentData = [];\n        var currentPosition = 0;\n        spectrum.data = [currentData];\n\n\n        var currentX = spectrum.firstX;\n        var currentY = spectrum.firstY;\n\n        // we skip the first line\n        //\n        var endLine = false;\n        for (var i = 0; i < value.length; i++) {\n            var ascii = value.charCodeAt(i);\n            if (ascii === 13 || ascii === 10) {\n                endLine = true;\n            } else {\n                if (endLine) break;\n            }\n        }\n\n        // we proceed taking the i after the first line\n        var newLine = true;\n        var isDifference = false;\n        var isLastDifference = false;\n        var lastDifference = 0;\n        var isDuplicate = false;\n        var inComment = false;\n        var currentValue = 0;\n        var isNegative = false;\n        var inValue = false;\n        var skipFirstValue = false;\n        var decimalPosition = 0;\n        var ascii;\n        for (; i <= value.length; i++) {\n            if (i === value.length) ascii = 13;\n            else ascii = value.charCodeAt(i);\n            if (inComment) {\n                // we should ignore the text if we are after $$\n                if (ascii === 13 || ascii === 10) {\n                    newLine = true;\n                    inComment = false;\n                }\n            } else {\n                // when is it a new value ?\n                // when it is not a digit, . or comma\n                // it is a number that is either new or we continue\n                if (ascii <= 57 && ascii >= 48) { // a number\n                    inValue = true;\n                    if (decimalPosition > 0) {\n                        currentValue += (ascii - 48) / Math.pow(10, decimalPosition++);\n                    } else {\n                        currentValue *= 10;\n                        currentValue += ascii - 48;\n                    }\n                } else if (ascii === 44 || ascii === 46) { // a \",\" or \".\"\n                    inValue = true;\n                    decimalPosition++;\n                } else {\n                    if (inValue) {\n                        // need to process the previous value\n                        if (newLine) {\n                            newLine = false; // we don't check the X value\n                            // console.log(\"NEW LINE\",isDifference, lastDifference);\n                            // if new line and lastDifference, the first value is just a check !\n                            // that we don't check ...\n                            if (isLastDifference) skipFirstValue = true;\n                        } else {\n                            // need to deal with duplicate and differences\n                            if (skipFirstValue) {\n                                skipFirstValue = false;\n                            } else {\n                                if (isDifference) {\n                                    if (currentValue === 0) lastDifference = 0;\n                                    else lastDifference = isNegative ? -currentValue : currentValue;\n                                    isLastDifference = true;\n                                    isDifference = false;\n                                }\n                                var duplicate = isDuplicate ? currentValue - 1 : 1;\n                                for (var j = 0; j < duplicate; j++) {\n                                    if (isLastDifference) {\n                                        currentY += lastDifference;\n                                    } else {\n                                        if (currentValue === 0) currentY = 0;\n                                        else currentY = isNegative ? -currentValue : currentValue;\n                                    }\n\n                                    //  console.log(\"Separator\",isNegative ?\n                                    //          -currentValue : currentValue,\n                                    //      \"isDiff\", isDifference, \"isDup\", isDuplicate,\n                                    //      \"lastDif\", lastDifference, \"dup:\", duplicate, \"y\", currentY);\n\n                                    // push is slightly slower ... (we loose 10%)\n                                    currentData[currentPosition++] = currentX;\n                                    currentData[currentPosition++] = currentY * yFactor;\n                                    currentX += deltaX;\n                                }\n                            }\n                        }\n                        isNegative = false;\n                        currentValue = 0;\n                        decimalPosition = 0;\n                        inValue = false;\n                        isDuplicate = false;\n                    }\n\n                    // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n                    if ((ascii < 74) && (ascii > 63)) {\n                        inValue = true;\n                        isLastDifference = false;\n                        currentValue = ascii - 64;\n                    } else\n                    // negative SQZ digits a b c d e f g h i (ascii 97-105)\n                    if ((ascii > 96) && (ascii < 106)) {\n                        inValue = true;\n                        isLastDifference = false;\n                        currentValue = ascii - 96;\n                        isNegative = true;\n                    } else\n                    // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n                    if (ascii === 115) {\n                        inValue = true;\n                        isDuplicate = true;\n                        currentValue = 9;\n                    } else if ((ascii > 82) && (ascii < 91)) {\n                        inValue = true;\n                        isDuplicate = true;\n                        currentValue = ascii - 82;\n                    } else\n                    // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n                    if ((ascii > 73) && (ascii < 83)) {\n                        inValue = true;\n                        isDifference = true;\n                        currentValue = ascii - 73;\n                    } else\n                    // negative DIF digits j k l m n o p q r (ascii 106-114)\n                    if ((ascii > 105) && (ascii < 115)) {\n                        inValue = true;\n                        isDifference = true;\n                        currentValue = ascii - 105;\n                        isNegative = true;\n                    } else\n                    // $ sign, we need to check the next one\n                    if (ascii === 36 && value.charCodeAt(i + 1) === 36) {\n                        inValue = true;\n                        inComment = true;\n                    } else\n                    // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n                    if (ascii === 37) {\n                        inValue = true;\n                        isDifference = true;\n                        currentValue = 0;\n                        isNegative = false;\n                    } else if (ascii === 45) { // a \"-\"\n                        // check if after there is a number, decimal or comma\n                        var ascii2 = value.charCodeAt(i + 1);\n                        if ((ascii2 >= 48 && ascii2 <= 57) || ascii2 === 44 || ascii2 === 46) {\n                            inValue = true;\n                            isLastDifference = false;\n                            isNegative = true;\n                        }\n                    } else if (ascii === 13 || ascii === 10) {\n                        newLine = true;\n                        inComment = false;\n                    }\n                    // and now analyse the details ... space or tabulation\n                    // if \"+\" we just don't care\n                }\n            }\n        }\n    }\n\n    function parsePeakTable(spectrum, value, result) {\n        var removeCommentRegExp = /\\$\\$.*/;\n        var peakTableSplitRegExp = /[,\\t ]+/;\n\n        spectrum.isPeaktable = true;\n        var i, ii, j, jj, values;\n        var currentData = [];\n        spectrum.data = [currentData];\n\n        // counts for around 20% of the time\n        var lines = value.split(/,? *,?[;\\r\\n]+ */);\n\n        var k = 0;\n        for (i = 1, ii = lines.length; i < ii; i++) {\n            values = lines[i].trim().replace(removeCommentRegExp, '').split(peakTableSplitRegExp);\n            if (values.length % 2 === 0) {\n                for (j = 0, jj = values.length; j < jj; j = j + 2) {\n                    // takes around 40% of the time to add and parse the 2 values nearly exclusively because of parseFloat\n                    currentData[k++] = (parseFloat(values[j]) * spectrum.xFactor);\n                    currentData[k++] = (parseFloat(values[j + 1]) * spectrum.yFactor);\n                }\n            } else {\n                result.logs.push('Format error: ' + values);\n            }\n        }\n    }\n\n\n    return convert;\n\n}\n\nvar convert = getConverter();\n\nfunction JcampConverter(input, options, useWorker) {\n    if (typeof options === 'boolean') {\n        useWorker = options;\n        options = {};\n    }\n    if (useWorker) {\n        return postToWorker(input, options);\n    } else {\n        return convert(input, options);\n    }\n}\n\nvar stamps = {},\n    worker;\n\nfunction postToWorker(input, options) {\n    if (!worker) {\n        createWorker();\n    }\n    return new Promise(function (resolve) {\n        var stamp = Date.now() + '' + Math.random();\n        stamps[stamp] = resolve;\n        worker.postMessage(JSON.stringify({\n            stamp: stamp,\n            input: input,\n            options: options\n        }));\n    });\n}\n\nfunction createWorker() {\n    var workerURL = URL.createObjectURL(new Blob([\n        'var getConverter =' + getConverter.toString() + ';var convert = getConverter(); onmessage = function (event) { var data = JSON.parse(event.data); postMessage(JSON.stringify({stamp: data.stamp, output: convert(data.input, data.options)})); };'\n    ], {type: 'application/javascript'}));\n    worker = new Worker(workerURL);\n    URL.revokeObjectURL(workerURL);\n    worker.addEventListener('message', function (event) {\n        var data = JSON.parse(event.data);\n        var stamp = data.stamp;\n        if (stamps[stamp]) {\n            stamps[stamp](data.output);\n        }\n    });\n}\n\nmodule.exports = {\n    convert: JcampConverter\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jcampconverter/src/index.js\n ** module id = 5\n ** module chunks = 0\n **/","'use strict';\n\n\nvar xyDataSplitRegExp = /[,\\t \\+-]*(?=[^\\d,\\t \\.])|[ \\t]+(?=[\\d+\\.-])/;\nvar removeCommentRegExp = /\\$\\$.*/;\nvar DEBUG=false;\n\nmodule.exports=function(spectrum, value, result) {\n    // we check if deltaX is defined otherwise we calculate it\n    if (!spectrum.deltaX) {\n        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n    }\n\n    spectrum.isXYdata=true;\n\n    var currentData = [];\n    var currentPosition=0;\n    spectrum.data = [currentData];\n\n    var currentX = spectrum.firstX;\n    var currentY = spectrum.firstY;\n    var lines = value.split(/[\\r\\n]+/);\n    var lastDif, values, ascii, expectedY;\n    values = [];\n    for (var i = 1, ii = lines.length; i < ii; i++) {\n        //var previousValues=JSON.parse(JSON.stringify(values));\n        values = lines[i].trim().replace(removeCommentRegExp, '').split(xyDataSplitRegExp);\n        if (values.length > 0) {\n            if (DEBUG) {\n                if (!spectrum.firstPoint) {\n                    spectrum.firstPoint = +values[0];\n                }\n                var expectedCurrentX = (values[0] - spectrum.firstPoint) * spectrum.xFactor + spectrum.firstX;\n                if ((lastDif || lastDif === 0)) {\n                    expectedCurrentX += spectrum.deltaX;\n                }\n                result.logs.push('Checking X value: currentX: ' + currentX + ' - expectedCurrentX: ' + expectedCurrentX);\n            }\n            for (var j = 1, jj = values.length; j < jj; j++) {\n                if (j === 1 && (lastDif || lastDif === 0)) {\n                    lastDif = null; // at the beginning of each line there should be the full value X / Y so the diff is always undefined\n                    // we could check if we have the expected Y value\n                    ascii = values[j].charCodeAt(0);\n\n                    if (false) { // this code is just to check the jcamp DIFDUP and the next line repeat of Y value\n                        // + - . 0 1 2 3 4 5 6 7 8 9\n                        if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n                            expectedY = +values[j];\n                        } else\n                        // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n                        if ((ascii > 63) && (ascii < 74)) {\n                            expectedY = +(String.fromCharCode(ascii - 16) + values[j].substring(1));\n                        } else\n                        // negative SQZ digits a b c d e f g h i (ascii 97-105)\n                        if ((ascii > 96) && (ascii < 106)) {\n                            expectedY = -(String.fromCharCode(ascii - 48) + values[j].substring(1));\n                        }\n                        if (expectedY !== currentY) {\n                            result.logs.push('Y value check error: Found: ' + expectedY + ' - Current: ' + currentY);\n                            result.logs.push('Previous values: ' + previousValues.length);\n                            result.logs.push(previousValues);\n                        }\n                    }\n                } else {\n                    if (values[j].length > 0) {\n                        ascii = values[j].charCodeAt(0);\n                        // + - . 0 1 2 3 4 5 6 7 8 9\n                        if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n                            lastDif = null;\n                            currentY = +values[j];\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else\n                        // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n                        if ((ascii > 63) && (ascii < 74)) {\n                            lastDif = null;\n                            currentY = +(String.fromCharCode(ascii - 16) + values[j].substring(1));\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++] = currentX;\n                            currentData[currentPosition++] = currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else\n                        // negative SQZ digits a b c d e f g h i (ascii 97-105)\n                        if ((ascii > 96) && (ascii < 106)) {\n                            lastDif = null;\n                            // we can multiply the string by 1 because if may not contain decimal (is this correct ????)\n                            currentY = -(String.fromCharCode(ascii - 48) + values[j].substring(1))*1;\n                            //currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else\n\n\n\n                        // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n                        if (((ascii > 82) && (ascii < 91)) || (ascii === 115)) {\n                            var dup = (String.fromCharCode(ascii - 34) + values[j].substring(1)) - 1;\n                            if (ascii === 115) {\n                                dup = ('9' + values[j].substring(1)) - 1;\n                            }\n                            for (var l = 0; l < dup; l++) {\n                                if (lastDif) {\n                                    currentY = currentY + lastDif;\n                                }\n                                // currentData.push(currentX, currentY * spectrum.yFactor);\n                                currentData[currentPosition++]=currentX;\n                                currentData[currentPosition++]=currentY * spectrum.yFactor;\n                                currentX += spectrum.deltaX;\n                            }\n                        } else\n                        // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n                        if (ascii === 37) {\n                            lastDif = +('0' + values[j].substring(1));\n                            currentY += lastDif;\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else if ((ascii > 73) && (ascii < 83)) {\n                            lastDif = (String.fromCharCode(ascii - 25) + values[j].substring(1))*1;\n                            currentY += lastDif;\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else\n                        // negative DIF digits j k l m n o p q r (ascii 106-114)\n                        if ((ascii > 105) && (ascii < 115)) {\n                            lastDif = -(String.fromCharCode(ascii - 57) + values[j].substring(1))*1;\n                            currentY += lastDif;\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jcampconverter/src/parseXYData.js\n ** module id = 6\n ** module chunks = 0\n **/","'use strict';\n/**\n * Created by acastillo on 3/2/16.\n */\n/**\n * This class converts a SpectraData object into a String that can be stored as a jcamp file.\n * The string reflects the current state of the object and not the raw data from where this\n * spectrum was initially loaded.\n * @author acastillo\n *\n */\n\nvar Encoder = require(\"./VectorEncoder\");\n\nvar JcampCreator = (function(){\n\n    const Integer = {MAX_VALUE:2e31-1,MIN_VALUE:-2e31};\n    const CRLF = \"\\r\\n\";\n    const version = \"Cheminfo tools, March 2016\"\n\n    /**\n     * This function creates a String that represents the given spectraData, in the format JCAM-DX 5.0\n     * The X,Y data can be compressed using one of the methods described in:\n     * \"JCAMP-DX. A STANDARD FORMAT FOR THE EXCHANGE OF ION MOBILITY SPECTROMETRY DATA\",\n     *  http://www.iupac.org/publications/pac/pdf/2001/pdf/7311x1765.pdf\n     * @param spectraData\n     * @param encodeFormat: ('FIX','SQZ','DIF','DIFDUP','CVS','PAC')\n     * @return\n     */\n    var convert = function(spectraData, encodeFormat, factorY, type, userDefinedParams){\n        encodeFormat = encodeFormat.toUpperCase().trim();\n\n        if(type===null||type.length==0)\n            type=\"SIMPLE\";\n\n        var outString = \"\";\n        spectraData.setActiveElement(0);\n\n        var scale=factorY/spectraData.getParamDouble(\"YFACTOR\", 1);\n        if(spectraData.getMaxY()*scale>=Integer.MAX_VALUE/2){\n            scale=Integer.MAX_VALUE/(spectraData.getMaxY()*2);\n        }\n        if(Math.abs(spectraData.getMaxY()-spectraData.getMinY())*scale<16)\n            scale=16/(Math.abs(spectraData.getMaxY()-spectraData.getMinY()));\n\n        var scaleX=Math.abs(1.0/spectraData.getDeltaX());\n\n        outString+=(\"##TITLE= \" + spectraData.getTitle() + CRLF);\n        outString+=(\"##JCAMP-DX= 5.00\\t$$\"+version+ CRLF);\n        outString+=(\"##OWNER= \" + spectraData.getParamString(\"##OWNER=\", \"\")+ CRLF);\n        outString+=(\"##DATA TYPE= \" +spectraData.getDataType()+ CRLF);\n\n        if(type==\"NTUPLES\") {\n            outString+=ntuplesHead(spectraData, scale, scaleX, encodeFormat, userDefinedParams);\n        }\n\n        if(type==\"SIMPLE\"){\n            outString+=simpleHead(spectraData, scale, scaleX, encodeFormat, userDefinedParams);\n        }\n        return outString;\n    }\n\n    var ntuplesHead = function(spectraData, scale, scaleX, encodeFormat, userDefinedParams){\n        var outString=\"\";\n        var variableX = spectraData.getSpectraVariable(0);\n        var variableY = spectraData.getSpectraVariable(1);\n        var variableZ = spectraData.getSpectraVariable(2);\n\n        outString+=\"##DATA CLASS= NTUPLES\" + CRLF;\n        outString+=\"##NUM DIM= 2\" + CRLF;\n        var nTuplesName=spectraData.getDataType().trim();\n        // we set the VarName parameter to the most common ones.\n        // These tables contain the number of occurences of each one\n        var abscVar = {};\n        var sub;\n        for ( sub = 0; sub < spectraData.getNbSubSpectra(); sub++) {\n            spectraData.setActiveElement(sub);\n            if (abscVar[spectraData.getXUnits()]) {\n                abscVar[spectraData.getXUnits()].value++;\n            } else {\n                abscVar[spectraData.getXUnits()]={value:1, index:sub};\n            }\n        }\n\n        var keys = Object.keys(abscVar);\n        var mostCommon =keys[0], defaultSub = 0;\n\n        for(sub=1;sub<keys.length;sub++){\n            if(abscVar[keys[sub]].value>abscVar[mostCommon].value){\n                mostCommon = keys[sub];\n                defaultSub=abscVar[keys[sub]].index;\n            }\n        }\n        var isComplex=false;\n        spectraData.setActiveElement(defaultSub);\n        var isNMR = spectraData.getDataType().indexOf(\"NMR\")>=0;\n        //If it is a NMR spectrum\n        if(isNMR){\n            outString+=(\"##.OBSERVE FREQUENCY= \" + spectraData.getParamDouble(\"observefrequency\", 0) + CRLF);\n            outString+=(\"##.OBSERVE NUCLEUS= ^\" + spectraData.getNucleus()+ CRLF);\n            outString+=(\"##$DECIM= \" + (spectraData.getParamDouble(\"$DECIM\",0))+ CRLF);\n            outString+=(\"##$DSPFVS= \" + (spectraData.getParamDouble(\"$DSPFVS\",0))+ CRLF);\n            outString+=(\"##$FCOR= \" + (Math.floor(spectraData.getParamDouble(\"$FCOR\",0)))+ CRLF);\n            if(spectraData.containsParam(\"$SW_h\"))\n                outString+=(\"##$SW_h= \" + (spectraData.getParamDouble(\"$SW_h\",0))+ CRLF);\n            else\n            if(spectraData.containsParam(\"$SW_p\"))\n                outString+=(\"##$SW_p= \" + (spectraData.getParamDouble(\"$SW_p\",0))+ CRLF);\n            outString+=(\"##$SW= \" + (spectraData.getParamDouble(\"$SW\",0))+ CRLF);\n            outString+=(\"##$TD= \" + (Math.floor(spectraData.getParamDouble(\"$TD\",0)))+ CRLF);\n            outString+=(\"##$BF1= \" + (spectraData.getParamDouble(\"$BF1\",0))+ CRLF);\n            outString+=(\"##$GRPDLY= \" + (spectraData.getParamDouble(\"$GRPDLY\",0))+ CRLF);\n            outString+=(\"##.DIGITISER RES= \" + (spectraData.getParamInt(\".DIGITISER RES\",0))+ CRLF);\n            outString+=(\"##.PULSE SEQUENCE= \" + (spectraData.getParamString(\".PULSE SEQUENCE\", \"\"))+ CRLF);\n            outString+=(\"##.SOLVENT NAME= \" + (spectraData.getSolventName())+ CRLF);\n            outString+=(\"##$NUC1= <\" +spectraData.getNucleus()+\">\"+ CRLF);\n            if(spectraData.containsParam(\"2D_X_FREQUENCY\"))\n                outString+=(\"##$SFO1= \" + (spectraData.getParamDouble(\"2D_X_FREQUENCY\",0))+ CRLF);\n            else\n                outString+=(\"##$SFO1= \" + (spectraData.getParamDouble(\"$SFO1\",0))+ CRLF);\n\n            if(spectraData.containsParam(\"2D_X_OFFSET\"))\n                outString+=(\"##$OFFSET= \" +spectraData.getParamDouble(\"2D_X_OFFSET\", 0)+ CRLF);\n\n            if(spectraData.is2D()){\n                outString+=(\"$$Parameters for 2D NMR Spectrum\"+ CRLF);\n                outString+=(\"##$NUC1= <\" +spectraData.getNucleus(2)+\">\"+ CRLF);\n                if(spectraData.containsParam(\"2D_Y_FREQUENCY\")){\n                    outString+=(\"##$SFO1= \" + spectraData.getParamDouble(\"2D_Y_FREQUENCY\", 0)+ CRLF);\n                    outString+=(\"##$SFO2= \" + spectraData.getParamDouble(\"2D_Y_FREQUENCY\", 0)+ CRLF);\n                    outString+=(\"##$BF2= \" +spectraData.getParamDouble(\"2D_Y_FREQUENCY\", 0)+ CRLF);\n                }\n                if(spectraData.containsParam(\"2D_Y_OFFSET\"))\n                    outString+=(\"##$OFFSET= \" +spectraData.getParamDouble(\"2D_Y_OFFSET\", 0)+ CRLF);\n\n                outString+=(\"$$End of Parameters for 2D NMR Spectrum\"+ CRLF);\n            }\n        }\n        outString+=(\"##NTUPLES=\\t\" + nTuplesName + CRLF);\n        var freq1 = 1,freq2=1;//spectraData.getParamDouble(\"2D_Y_FREQUENCY\", 0);\n        if(!spectraData.is2D()&&spectraData.getNbSubSpectra()>1&& isNMR)\n            isComplex=true;\n        if(isComplex){\n            outString+=(\"##VAR_NAME=\\t\" + spectraData.getXUnits() + \",\\t\"+ nTuplesName.substring(4) +\"/REAL,\\t\"+ nTuplesName.substring(4) +\"/IMAG\"+CRLF);\n            outString+=(\"##SYMBOL=\\tX,\\tR,\\tI\" + CRLF);\n            outString+=(\"##VAR_TYPE=\\tINDEPENDENT,\\tDEPENDENT,\\tDEPENDENT\" + CRLF);\n            if(encodeFormat!=\"CSV\"||encodeFormat!=\"PAC\")\n                outString+=(\"##VAR_FORM=\\tAFFN,\\tASDF,\\tASDF\" + CRLF);\n            else\n                outString+=(\"##VAR_FORM=\\tAFFN,\\tAFFN,\\tAFFN\" + CRLF);\n            outString+=(\"##VAR_DIM=\\t\" + spectraData.getNbPoints() + \",\\t\" + spectraData.getNbPoints()+\",\\t\" + spectraData.getNbPoints()+CRLF);\n            outString+=(\"##UNITS=\\tHZ\"+ \",\\t\"+ spectraData.getYUnits() +\",\\t\"+ variableZ.units + CRLF);\n            outString+=(\"##FACTOR=\\t\" + 1.0/scaleX + \",\\t\"+1.0/scale+\",\\t\"+1.0/scale+ CRLF);\n\n            if(spectraData.getXUnits()==\"PPM\")\n                freq1 = spectraData.observeFrequencyX();\n\n            outString+=(\"##FIRST=\\t\" + spectraData.getFirstX()*freq1 + \",\\t\"+spectraData.getY(0)+\",\\t0\" + CRLF);\n            outString+=(\"##LAST=\\t\" + spectraData.getLastX()*freq1 + \",\\t\"+spectraData.getLastY()+\",\\t0\" + CRLF);\n        }\n        else{\n            freq1 = 1;\n            if(spectraData.is2D()) {\n                outString += (\"##VAR_NAME=\\tFREQUENCY1,\\tFREQUENCY2,\\tSPECTRUM\" + CRLF);\n                outString += (\"##SYMBOL=\\tF1,\\tF2,\\tY\" + CRLF);\n                outString += (\"##.NUCLEUS=\\t\" + spectraData.getNucleus(2) + \",\\t\" + spectraData.getNucleus(1) + CRLF);\n                outString += (\"##VAR_TYPE=\\tINDEPENDENT,\\tINDEPENDENT,\\tDEPENDENT\" + CRLF);\n                if (encodeFormat != \"CSV\" || encodeFormat != \"PAC\")\n                    outString += (\"##VAR_FORM=\\tAFFN,\\tAFFN,\\tASDF\" + CRLF);\n                else\n                    outString+=(\"##VAR_FORM=\\tAFFN,\\tAFFN,\\tASDF\" + CRLF);\n                outString+=(\"##VAR_DIM=\\t\" + spectraData.getNbSubSpectra() + \",\\t\" + spectraData.getNbPoints()+ \",\\t\" + spectraData.getNbPoints() + CRLF);\n                //We had to change this, for Mestre compatibility\n                //outString+=(\"##UNITS=\\tHZ,\\t\"+ spectraData.getXUnits() + \",\\t\" + spectraData.getYUnits()+CRLF);\n                outString+=(\"##UNITS=\\tHZ,\\tHZ,\\t\" + spectraData.getYUnits()+CRLF);\n                if(spectraData.getXUnits()==\"PPM\")\n                    freq1 = spectraData.getParamDouble(\"2D_Y_FREQUENCY\", 1);\n                if(spectraData.getYUnits()==\"PPM\"){\n                    freq2 = spectraData.getParamDouble(\"2D_X_FREQUENCY\", 1);\n                }\n                outString+=(\"##FACTOR=\\t1,\\t\"+freq2/scaleX + \",\\t\"+1.0/scale+ CRLF);\n                outString+=(\"##FIRST=\\t\"+spectraData.getParamDouble(\"firstY\", 0)*freq1+\",\\t\"+ spectraData.getFirstX()*freq2 + \",\\t\"+spectraData.getY(0) + CRLF);\n                outString+=(\"##LAST=\\t\" +spectraData.getParamDouble(\"lastY\", 0)*freq1+\",\\t\"+ spectraData.getLastX() *freq2\n                + \",\\t\"+ spectraData.getY(spectraData.getNbPoints()-1)+ CRLF);\n            }else{\n                outString+=(\"##VAR_NAME=\\t\" + variableX.varname + \",\\t\"+ variableY.varname + \",\\t\"+ variableX.varname + CRLF);\n                outString+=(\"##SYMBOL=\\t\" + variableX.symbol + \",\\t\"+ variableY.symbol + \",\\t\"+ variableZ.symbol + CRLF);\n                outString+=(\"##VAR_TYPE=\\t\" + variableX.vartype + \",\\t\"+ variableY.vartype + \",\\t\"+ variableZ.vartype + CRLF);\n                if(encodeFormat!=\"CSV\"||encodeFormat!=\"PAC\")\n                    outString+=(\"##VAR_FORM=\\tAFFN,\\tASDF,\\tASDF\" + CRLF);\n                else\n                    outString+=(\"##VAR_FORM=\\tAFFN,\\tAFFN,\\tAFFN\" + CRLF);\n                outString+=(\"##VAR_DIM=\\t\" + variableX.vardim + \",\\t\"+ variableY.vardim + \",\\t\"+ variableZ.vardim + CRLF);\n                outString+=(\"##UNITS=\\tHZ\" + \",\\t\"+ spectraData.getYUnits() + \",\\t\"+ variableZ.units + CRLF);\n                if(spectraData.getXUnits()==\"PPM\")\n                    freq1 = spectraData.observeFrequencyX();\n                outString+=(\"##FACTOR=\\t\" + 1.0/scaleX + \",\\t\"+1.0/scale + CRLF);\n                outString+=(\"##FIRST=\\t\" + variableX.first*freq1 + \",\\t\"+ variableY.first + \",\\t\"+ variableZ.first + CRLF);\n                outString+=(\"##LAST=\\t\" + variableX.last*freq1 + \",\\t\"+ variableY.last + \",\\t\"+ variableZ.last + CRLF);\n\n            }\n        }\n\n        //Set the user defined parameters\n        if(userDefinedParams!=null){\n            for(var i=userDefinedParams.length-1;i>=0;i--){\n                if(spectraData.containsParam(userDefinedParams[i])){\n                    outString+=(\"##\"+userDefinedParams[i]+\"= \"\n                    + spectraData.getParam(userDefinedParams[i], \"\")+ CRLF);\n                }\n            }\n        }\n        //Ordinate of the second dimension in case of 2D NMR spectra\n        var yUnits = 0, lastY = 0, dy = 0;\n\n        if(spectraData.is2D()&& isNMR){\n            yUnits = spectraData.getParamDouble(\"firstY\", 0)*freq1;\n            lastY = spectraData.getParamDouble(\"lastY\", 0)*freq1;\n            dy = (lastY-yUnits)/(spectraData.getNbSubSpectra()-1);\n        }\n\n        for ( sub = 0; sub < spectraData.getNbSubSpectra(); sub++) {\n            spectraData.setActiveElement(sub);\n            outString+=(\"##PAGE= \" + spectraData.page + CRLF);\n            yUnits+=dy;\n\n            if(spectraData.is2D()&&isNMR)\n                outString+=(\"##FIRST=\\t\"+spectraData.getParamDouble(\"firstY\", 0)*freq1+\",\\t\"\n                + spectraData.getFirstX()*freq2 + \",\\t\"+spectraData.getY(0) + CRLF);\n\n\n            outString+=(\"##DATA TABLE= \");\n            if (spectraData.isDataClassPeak()) {\n                outString+=(\"(XY..XY), PEAKS\" + CRLF);\n                for (var point = 0; point < spectraData.getNbPoints(); point++)\n                    outString+=(spectraData.getX(point) + \", \" + spectraData.getY(point)+ CRLF);\n\n            } else if (spectraData.isDataClassXY()) {\n                if(isNMR){\n                    if(spectraData.is2D()){\n                        outString+=(\"(F2++(Y..Y)), PROFILE\" + CRLF);\n                    }\n                    else{\n                        if(sub%2==0)\n                            outString+=(\"(X++(R..R)), XYDATA\" + CRLF);\n                        else\n                            outString+=(\"(X++(I..I)), XYDATA\" + CRLF);\n                    }\n                }\n                else\n                    outString+=(\"(X++(Y..Y)), XYDATA\" + CRLF);\n\n                var tempString = \"\";\n                var data = new Array(spectraData.getNbPoints());\n                for (var point = data.length-1; point >=0; point--) {\n                    data[point]=Math.round((spectraData.getY(point)*scale));\n                }\n\n                tempString+=Encoder.encode(data,\n                    spectraData.getFirstX()*scaleX,spectraData.getDeltaX()*scaleX,encodeFormat);\n\n                outString+=(tempString+CRLF);\n            }\n        }\n        outString+=(\"##END NTUPLES= \" + nTuplesName + CRLF);\n        outString+=(\"##END= \");\n\n        spectraData.setActiveElement(0);\n\n        return outString;\n    }\n\n    var simpleHead = function(spectraData, scale, scaleX, encodeFormat, userDefinedParams){\n        var variableX = spectraData.getSpectraVariable(0);\n        var variableY = spectraData.getSpectraVariable(1);\n        var outString=\"\";\n        if(spectraData.isDataClassPeak())\n            outString+=(\"##DATA CLASS= PEAK TABLE\"+ CRLF);\n        if(spectraData.isDataClassXY())\n            outString+=(\"##DATA CLASS= XYDATA\"+ CRLF);\n\n        spectraData.setActiveElement(0);\n        //If it is a NMR spectrum\n        if(spectraData.getDataType().indexOf(\"NMR\")>=0){\n            outString+=(\"##.OBSERVE FREQUENCY= \" + spectraData.getParamDouble(\"observefrequency\", 0) + CRLF);\n            outString+=(\"##.OBSERVE NUCLEUS= ^\" + spectraData.getNucleus()+ CRLF);\n            outString+=(\"##$DECIM= \" + (Math.round(spectraData.getParamDouble(\"$DECIM\",0)))+ CRLF);\n            outString+=(\"##$DSPFVS= \" + (Math.round(spectraData.getParamDouble(\"$DSPFVS\",0)))+ CRLF);\n            outString+=(\"##$FCOR= \" + (Math.round(spectraData.getParamDouble(\"$FCOR\",0)))+ CRLF);\n            outString+=(\"##$SW_h= \" + (spectraData.getParamDouble(\"$SW_h\",0))+ CRLF);\n            outString+=(\"##$SW= \" + (spectraData.getParamDouble(\"$SW\",0))+ CRLF);\n            outString+=(\"##$TD= \" + (Math.round(spectraData.getParamDouble(\"$TD\",0)))+ CRLF);\n            outString+=(\"##$GRPDLY= \" + (spectraData.getParamDouble(\"$GRPDLY\",0))+ CRLF);\n            outString+=(\"##$BF1= \" + (spectraData.getParamDouble(\"$BF1\",0))+ CRLF);\n            outString+=(\"##$SFO1= \" + (spectraData.getParamDouble(\"$SFO1\",0))+ CRLF);\n            outString+=(\"##$NUC1= <\" +spectraData.getNucleus()+\">\"+ CRLF);\n            outString+=(\"##.SOLVENT NAME= \" + (spectraData.getSolventName())+ CRLF);\n\n        }\n        outString+=(\"##XUNITS=\\t\" + spectraData.getXUnits() + CRLF);\n        outString+=(\"##YUNITS=\\t\" + spectraData.getYUnits() + CRLF);\n        outString+=(\"##NPOINTS=\\t\" + spectraData.getNbPoints() + CRLF);\n        outString+=(\"##FIRSTX=\\t\" + spectraData.getFirstX() + CRLF);\n        outString+=(\"##LASTX=\\t\" + spectraData.getLastX() + CRLF);\n        outString+=(\"##FIRSTY=\\t\" + spectraData.getFirstY() + CRLF);\n        outString+=(\"##LASTY=\\t\" + spectraData.getLastY() + CRLF);\n        if (spectraData.isDataClassPeak()) {\n            outString+=(\"##XFACTOR=1\"+ CRLF);\n            outString+=(\"##YFACTOR=1\"+ CRLF);\n        } else if (spectraData.isDataClassXY()) {\n            outString+=(\"##XFACTOR= \"+ 1.0/scaleX+ CRLF);\n            outString+=(\"##YFACTOR= \"+1.0/scale + CRLF);\n        }\n        outString+=(\"##MAXY= \"+ spectraData.getMaxY()+ CRLF);\n        outString+=(\"##MINY= \"+ spectraData.getMinY()+ CRLF);\n\n        //Set the user defined parameters\n        if(userDefinedParams!=null){\n            for(var i=userDefinedParams.length-1;i>=0;i--){\n                if(spectraData.containsParam(userDefinedParams[i])){\n                    outString+=(\"##\"+userDefinedParams[i]+\"= \"\n                    + spectraData.getParam(userDefinedParams[i], \"\")+ CRLF);\n                }\n            }\n        }\n\n\n        if (spectraData.isDataClassPeak()) {\n            outString+=(\"##PEAK TABLE= (XY..XY)\" + CRLF);\n            for (var point = 0; point < spectraData.getNbPoints(); point++)\n                outString+=(spectraData.getX(point) + \", \" + spectraData.getY(point)+ CRLF);\n            outString+=(\"##END \");\n\n        } else if (spectraData.isDataClassXY()) {\n            outString+=(\"##DELTAX= \"+spectraData.getDeltaX()+CRLF);\n            outString+=(\"##XYDATA=(X++(Y..Y))\" + CRLF);\n            var tempString = \"\";\n            var data = new Array(spectraData.getNbPoints());\n            for (var point = data.length-1; point >=0; point--) {\n                data[point]=Math.round(spectraData.getY(point)*scale);\n            }\n\n            tempString+=Encoder.encode(data, spectraData.getFirstX()*scaleX,spectraData.getDeltaX()*scaleX, encodeFormat);\n\n            outString+=(tempString+CRLF);\n            outString+=(\"##END= \");\n        }\n\n        spectraData.setActiveElement(0);\n        return outString;\n    }\n\n    return {\"convert\":convert};\n})();\n\nmodule.exports = JcampCreator;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/spectra-data/src/JcampCreator.js\n ** module id = 7\n ** module chunks = 0\n **/","'use strict';\n/**\n * class encodes a integer vector as a String in order to store it in a text file.\n * The algorithms used to encode the data are describe in:\n *            http://www.iupac.org/publications/pac/pdf/2001/pdf/7311x1765.pdf\n * Created by acastillo on 3/2/16.\n */\nvar Encoder = (function(){\n    var newLine=\"\\r\\n\";\n\n    var pseudoDigits=[['0','1','2','3','4','5','6','7','8','9'],\n                  ['@','A','B','C','D','E','F','G','H','I'],\n                  ['@','a','b','c','d','e','f','g','h','i'],\n                  ['%','J','K','L','M','N','O','P','Q','R'],\n                  ['%','j','k','l','m','n','o','p','q','r'],\n                  [' ','S','T','U','V','W','X','Y','Z','s']];\n\n    var SQZ_P= 1, SQZ_N= 2, DIF_P=3, DIF_N=4, DUP=5, MaxLinelength=100;\n\n    /**\n     * This function encodes the given vector. The encoding format is specified by the\n     * encoding option\n     * @param data\n     * @param firstX\n     * @param intervalX\n     * @param encoding: ('FIX','SQZ','DIF','DIFDUP','CVS','PAC') Default 'DIFDUP'\n     * @returns {String}\n     */\n    var encode = function(data, firstX, intervalX, encoding){\n        if(encoding==(\"FIX\"))\n            return FIXencod(data, firstX,intervalX);\n        if(encoding==(\"SQZ\"))\n            return SQZencod(data, firstX,intervalX);\n        if(encoding==(\"DIF\"))\n            return DIFencod(data, firstX,intervalX);\n        if(encoding==(\"DIFDUP\"))\n            return DIFDUPencod(data, firstX,intervalX);\n        if(encoding==(\"CSV\"))\n            return CSVencod(data, firstX,intervalX);\n        if(encoding==(\"PAC\"))\n            return PACencod(data, firstX,intervalX);\n        //Default\n        return DIFencod(data, firstX,intervalX);\n    }\n\n    /**\n     * No data compression used. The data is separated by a comma(',').\n     * @param data\n     * @return\n     */\n    var CSVencod =  function(data, firstX, intervalX){\n        return FIXencod(data, firstX, intervalX, \",\");\n    };\n\n    /**\n     * No data compression used. The data is separated by the specified separator.\n     * @param data\n     * @param separator, The separator character\n     * @return\n     */\n    var FIXencod =  function(data, firstX, intervalX, separator){\n        if(!separator)\n            separator = \" \";\n        var outputData = \"\";\n        var j=0, TD = data.length, i;\n        while(j<TD-7){\n            outputData+=Math.ceil(firstX+j*intervalX);\n            for(i = 0;i<8;i++)\n                outputData+=separator+data[j++];\n            outputData+=newLine;\n        }\n        if(j<TD){\n            //We add last numbers\n            outputData+=Math.ceil(firstX+j*intervalX);\n            for(i=j;i<TD;i++)\n                outputData+=separator + data[i];\n        }\n        return outputData;\n    };\n    /**\n     * No data compression used. The data is separated by the sign of the number.\n     * @param data\n     * @return\n     */\n    var PACencod = function(data, firstX, intervalX){\n        var outputData = \"\";\n        var j=0, TD = data.length, i;\n\n        while(j<TD-7){\n            outputData+=Math.ceil(firstX+j*intervalX);\n            for(i = 0;i<8;i++){\n                if(data[j]<0)\n                    outputData+=\"-\"+data[j++];\n                else\n                    outputData+=\"+\"+data[j++];\n            }\n            outputData+=newLine;\n        }\n        if(j<TD){\n            //We add last numbers\n            outputData+=Math.ceil(firstX+j*intervalX);\n            for(i=j;i<TD;i++){\n                if(data[i]<0)\n                    outputData+=\"-\"+data[i];\n                else\n                    outputData+=\"+\"+data[i];\n            }\n        }\n        return outputData;\n    };\n    /**\n     * Data compression is possible using the squeezed form (SQZ) in which the delimiter, the leading digit,\n     * and sign are replaced by a pseudo-digit from Table 1. For example, the Y-values 30, 32 would be\n     * represented as C0C2.\n     * @param data\n     * @return String\n     */\n    var SQZencod = function(data, firstX, intervalX){\n        var outputData = \"\";\n        //String outputData = new String();\n        var j=0, TD = data.length, i;\n\n        while(j<TD-10){\n            outputData+=Math.ceil(firstX+j*intervalX);\n            for(i = 0;i<10;i++)\n                outputData+=SQZDigit(data[j++].toString());\n            outputData+=newLine;\n        }\n        if(j<TD){\n            //We add last numbers\n            outputData+=Math.ceil(firstX+j*intervalX);\n            for(i = j;i<TD;i++)\n                outputData+=SQZDigit(data[i].toString());\n        }\n\n        return outputData;\n    };\n\n    /**\n     * Duplicate suppression encoding\n     * @param data\n     * @return\n     */\n    var DIFDUPencod = function(data, firstX, intervalX){\n        var mult=0, index=0, charCount= 0, i;\n        //We built a string where we store the encoded data.\n        var encodData = \"\",encodNumber = \"\",temp = \"\";\n\n        //We calculate the differences vector\n        var diffData = new Array(data.length-1);\n        for(i=0;i<diffData.length;i++){\n            diffData[i]= data[i+1]-data[i];\n        }\n\n        //We simulate a line carry\n        var numDiff = diffData.length;\n        while(index<numDiff){\n            if(charCount==0){//Start line\n                encodNumber = Math.ceil(firstX+index*intervalX)+SQZDigit(data[index].toString())+DIFDigit(diffData[index].toString());\n                encodData+=encodNumber;\n                charCount+=encodNumber.length;\n            }\n            else{\n                //Try to insert next difference\n                if(diffData[index-1]==diffData[index]){\n                    mult++;\n                }\n                else{\n                    if(mult>0){//Now we know that it can be in line\n                        mult++;\n                        encodNumber=DUPDigit(mult.toString());\n                        encodData+=encodNumber;\n                        charCount+=encodNumber.length;\n                        mult=0;\n                        index--;\n                    }\n                    else{\n                        //Mirar si cabe, en caso contrario iniciar una nueva linea\n                        encodNumber=DIFDigit(diffData[index].toString());\n                        if(encodNumber.length+charCount<MaxLinelength){\n                            encodData+=encodNumber;\n                            charCount+=encodNumber.length;\n                        }\n                        else{//Iniciar nueva linea\n                            encodData+=newLine;\n                            temp=Math.ceil(firstX+index*intervalX)+SQZDigit(data[index].toString())+encodNumber;\n                            encodData+=temp;//Each line start with first index number.\n                            charCount=temp.length;\n                        }\n                    }\n                }\n            }\n            index++;\n        }\n        if(mult>0)\n            encodData+=DUPDigit((mult+1).toString());\n        //We insert the last data from fid. It is done to control of data\n        //The last line start with the number of datas in the fid.\n        encodData+=newLine+Math.ceil(firstX+index*intervalX)+SQZDigit(data[index].toString());\n\n        return encodData;\n    };\n\n    /**\n     * Differential encoding\n     * @param data\n     * @return\n     */\n    var DIFencod = function(data, firstX, intervalX){\n        var index=0, charCount= 0,i;\n\n        var encodData = \"\";\n        //String encodData = new String();\n        var encodNumber = \"\", temp = \"\";\n\n        //We calculate the differences vector\n        var diffData = new Array(data.length-1);\n        for(i=0;i<diffData.length;i++){\n            diffData[i]= data[i+1]-data[i];\n        }\n\n        index=0;\n        var numDiff = diffData.length;\n        while(index<numDiff){\n            if(charCount==0){//Iniciar linea\n                //We convert the first number.\n                encodNumber = Math.ceil(firstX+index*intervalX)+SQZDigit(data[index].toString())+DIFDigit(diffData[index].toString());\n                encodData+=encodNumber;\n                charCount+=encodNumber.length;\n            }\n            else{\n                //Mirar si cabe, en caso contrario iniciar una nueva linea\n                encodNumber=DIFDigit(diffData[index].toString());\n                if(encodNumber.length+charCount<MaxLinelength){\n                    encodData+=encodNumber;\n                    charCount+=encodNumber.length;\n                }\n                else{//Iniciar nueva linea\n                    encodData+=newLine;\n                    temp=Math.ceil(firstX+index*intervalX)+SQZDigit(data[index].toString())+encodNumber;\n                    encodData+=temp;//Each line start with first index number.\n                    charCount=temp.length;\n                }\n            }\n            index++;\n        }\n        //We insert the last number from data. It is done to control of data\n        encodData+=newLine+Math.ceil(firstX+index*intervalX)+SQZDigit(data[index].toString());\n\n        return encodData;\n    };\n\n    /**\n     * Convert number to the ZQZ format, using pseudo digits.\n     * @param num\n     * @return\n     */\n    var SQZDigit = function(num){\n        //console.log(num+\" \"+num.length);\n        var SQZdigit = \"\";\n        if(num.charAt(0)=='-'){\n            SQZdigit+=pseudoDigits[SQZ_N][Number(num.charAt(1))];\n            if(num.length>2)\n                SQZdigit+=num.substring(2);\n        }\n        else{\n            SQZdigit+=pseudoDigits[SQZ_P][Number(num.charAt(0))];\n            if(num.length>1)\n                SQZdigit+=num.substring(1);\n        }\n\n        return SQZdigit;\n    };\n    /**\n     * Convert number to the DIF format, using pseudo digits.\n     * @param num\n     * @return\n     */\n    var DIFDigit = function(num){\n        var DIFFdigit = \"\";\n\n        if(num.charAt(0)=='-'){\n            DIFFdigit+=pseudoDigits[DIF_N][Number(num.charAt(1))];\n            if(num.length>2)\n                DIFFdigit+=num.substring(2);\n\n        }\n        else{\n            DIFFdigit+=pseudoDigits[DIF_P][Number(num.charAt(0))];\n            if(num.length>1)\n                DIFFdigit+=num.substring(1);\n\n        }\n\n        return DIFFdigit;\n    };\n    /**\n     * Convert number to the DUP format, using pseudo digits.\n     * @param num\n     * @return\n     */\n    var DUPDigit = function(num){\n        var DUPdigit = \"\";\n        DUPdigit+=pseudoDigits[DUP][Number(num.charAt(0))];\n        if(num.length>1)\n            DUPdigit+=num.substring(1);\n\n        return DUPdigit;\n    }\n\n    return {\n        encode:encode,\n        FIXencod:FIXencod,\n        CSVencod:CSVencod,\n        PACencod:PACencod,\n        SQZencod:SQZencod,\n        DIFDUPencod:DIFDUPencod,\n        DIFencod:DIFDUPencod\n    };\n\n})();\n\nmodule.exports = Encoder;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/spectra-data/src/VectorEncoder.js\n ** module id = 8\n ** module chunks = 0\n **/","'use strict';\n\nvar SD = require('./SD');\nvar PeakPicking = require('./PeakPicking');\nvar JcampConverter=require(\"jcampconverter\");\nvar fft = require(\"ml-fft\");\nvar Filters = require(\"./filters/Filters.js\");\n\n/**\n * Construct the object from the given sd object(output of the jcampconverter or brukerconverter filter)\n * @param sd\n * @constructor\n */\nfunction NMR(sd) {\n    SD.call(this, sd); // Héritage\n}\n\nNMR.prototype = Object.create(SD.prototype);\nNMR.prototype.constructor = NMR;\n\n/**\n * @function fromJcamp(jcamp,options)\n * Construct the object from the given jcamp.\n * @param jcamp\n * @param options\n * @option xy\n * @option keepSpectra\n * @option keepRecordsRegExp\n * @returns {NMR}\n */\nNMR.fromJcamp = function(jcamp,options) {\n    options = options || {xy:true,keepSpectra:true,keepRecordsRegExp:/^.+$/};\n    var spectrum= JcampConverter.convert(jcamp,options);\n    return new NMR(spectrum);\n}\n\n/**\n * @function getNucleus(dim)\n * Returns the observed nucleus. A dimension parameter is accepted for compatibility with 2DNMR\n * @param dim\n * @returns {*}\n */\nNMR.prototype.getNucleus=function(dim){\n    if(!dim||dim==0||dim==1)\n        return this.sd.xType;\n    else{\n        return \"\";\n    }\n}\n\n/**\n * @function getSolventName()\n * Returns the solvent name.\n * @returns {string|XML}\n */\nNMR.prototype.getSolventName=function(){\n    return (this.sd.info[\".SOLVENTNAME\"]||this.sd.info[\"$SOLVENT\"]||\"\").replace(\"<\",\"\").replace(\">\",\"\");\n}\n\n/**\n * @function observeFrequencyX()\n * Returns the observe frequency in the direct dimension\n * @returns {number}\n */\nNMR.prototype.observeFrequencyX=function(){\n    return this.sd.spectra[0].observeFrequency;\n}\n\n/**\n * @function getNMRPeakThreshold(nucleus)\n * Returns the noise factor depending on the nucleus.\n * @param nucleus\n * @returns {number}\n */\nNMR.prototype.getNMRPeakThreshold=function(nucleus) {\n    if (nucleus == \"1H\")\n        return 3.0;\n    if (nucleus ==\"13C\")\n        return 5.0;\n    return 1.0;\n}\n\n\n    \n/**\n * @function addNoise(SNR)\n * This function adds white noise to the the given spectraData. The intensity of the noise is \n * calculated from the given signal to noise ratio.\n * @param SNR Signal to noise ratio\n * @returns this object\n */\n NMR.prototype.addNoise=function(SNR) {\n     //@TODO Implement addNoise filter\n}\n\n\n/**\n * @function addSpectraDatas(spec2,factor1,factor2,autoscale )   \n *  This filter performs a linear combination of two spectraDatas.\n * A=spec1\n * B=spec2\n * After to apply this filter you will get:\n *      A=A*factor1+B*factor2\n * if autoscale is set to 'true' then you will obtain:\n *  A=A*factor1+B*k*factor2\n * Where the k is a factor such that the maximum peak in A is equal to the maximum peak in spectraData2 \n * @param spec2 spectraData2\n * @param factor1 linear factor for spec1\n * @param factor2 linear factor for spec2\n * @param autoscale Auto-adjust scales before combine the spectraDatas\n * @returns this object\n * @example spec1 = addSpectraDatas(spec1,spec2,1,-1, false) This subtract spec2 from spec1\n*/\nNMR.prototype.addSpectraDatas=function(spec2,factor1,factor2,autoscale ) {\n    //@TODO Implement addSpectraDatas filter\n\n}\n\n/**\n * @function autoBaseline()\n * Automatically corrects the base line of a given spectraData. After this process the spectraData\n * should have meaningful integrals.\n * @returns this object\n */\nNMR.prototype.autoBaseline=function( ) {\n    //@TODO Implement autoBaseline filter\n}\n\n/**\n * @function fourierTransform()\n * Fourier transforms the given spectraData (Note. no 2D handling yet) this spectraData have to be of type NMR_FID or 2DNMR_FID\n * @returns this object\n */\nNMR.prototype.fourierTransform=function( ) {\n    return Filters.fourierTransform(this);\n}\n\n/**\n * @function postFourierTransform(ph1corr)\n * This filter makes an phase 1 correction that corrects the problem of the spectra that has been obtained \n * on spectrometers using the Bruker digital filters. This method is used in cases when the BrukerSpectra \n * filter could not find the correct number of points to perform a circular shift.\n * The actual problem is that not all of the spectra has the necessary parameters for use only one method for \n * correcting the problem of the Bruker digital filters.\n * @param spectraData A fourier transformed spectraData.\n * @param ph1corr Phase 1 correction value in radians.\n * @returns this object\n */\nNMR.prototype.postFourierTransform=function(ph1corr) {\n    return Filters.phaseCorrection(0,ph1corr);\n}\n\n/**\n * @function zeroFilling(nPointsX [,nPointsY])\n * This function increase the size of the spectrum, filling the new positions with zero values. Doing it one \n * could increase artificially the spectral resolution.\n * @param nPointsX Number of new zero points in the direct dimension\n * @param nPointsY Number of new zero points in the indirect dimension\n * @returns this object\n */\nNMR.prototype.zeroFilling=function(nPointsX, nPointsY) {\n    return Filters.zeroFilling(this,nPointsX, nPointsY);\n}\n\n/**\n * @function  haarWhittakerBaselineCorrection(waveletScale,whittakerLambda)\n * Applies a baseline correction as described in J Magn Resonance 183 (2006) 145-151 10.1016/j.jmr.2006.07.013\n * The needed parameters are the wavelet scale and the lambda used in the whittaker smoother.\n * @param waveletScale To be described\n * @param whittakerLambda To be described\n * @returns this object\n */\nNMR.prototype.haarWhittakerBaselineCorrection=function(waveletScale,whittakerLambda) {\n    //@TODO Implement haarWhittakerBaselineCorrection filter\n}\n\n/**\n * @function whittakerBaselineCorrection(whittakerLambda,ranges)\n * Applies a baseline correction as described in J Magn Resonance 183 (2006) 145-151 10.1016/j.jmr.2006.07.013\n * The needed parameters are the Wavelet scale and the lambda used in the Whittaker smoother.\n * @param waveletScale To be described\n * @param whittakerLambda To be described\n * @param ranges A string containing the ranges of no signal.\n * @returns this object\n */\nNMR.prototype.whittakerBaselineCorrection=function(whittakerLambda,ranges) {\n    //@TODO Implement whittakerBaselineCorrection filter\n}\n\n/**\n * @function brukerFilter()\n * This filter applies a circular shift(phase 1 correction in the time domain) to an NMR FID spectrum that \n * have been obtained on spectrometers using the Bruker digital filters. The amount of shift depends on the \n * parameters DECIM and DSPFVS. This spectraData have to be of type NMR_FID\n * @returns this object\n */\nNMR.prototype.brukerFilter=function() {\n    return Filters.digitalFilter(this, {\"brukerFilter\":true});\n}\n\n/**\n * @function digitalFilter(options)\n * This filter applies a circular shift(phase 1 correction in the time domain) to an NMR FID spectrum that\n * have been obtained on spectrometers using the Bruker digital filters. The amount of shift depends on the\n * parameters DECIM and DSPFVS. This spectraData have to be of type NMR_FID\n * @option nbPoints: The number of points to shift. Positive values will shift the values to the rigth\n * and negative values will do to the left.\n * @option brukerSpectra\n * @returns this object\n */\nNMR.prototype.digitalFilter=function(options) {\n    return Filters.digitalFilter(this, options);\n}\n\n/**\n * @function apodization(functionName, lineBroadening)\n * Apodization of a spectraData object.\n * @param spectraData An spectraData of type NMR_FID\n * @param functionName Valid values for functionsName are\n *  Exponential, exp\n *  Hamming, hamming\n *  Gaussian, gauss\n *  TRAF, traf\n *  Sine Bell, sb\n *  Sine Bell Squared, sb2\n * @param lineBroadening The parameter LB should either be a line broadening factor in Hz \n * or alternatively an angle given by degrees for sine bell functions and the like.\n * @returns this object\n * @example SD.apodization(\"exp\", lineBroadening)\n */\nNMR.prototype.apodization=function(functionName, lineBroadening) {\n    return Filters.apodization(this,{\"functionName\":functionName,\n                            \"lineBroadening\":lineBroadening});\n\n}\n\n/**\n * @function echoAntiechoFilter();\n * That decodes an Echo-Antiecho 2D spectrum.\n * @returns this object\n */\nNMR.prototype.echoAntiechoFilter=function() {\n    //@TODO Implement echoAntiechoFilter filter\n}\n\n/**\n * @function SNVFilter()\n * This function apply a Standard Normal Variate Transformation over the given spectraData. Mainly used for IR spectra.\n * @returns this object\n */\nNMR.prototype.SNVFilter=function() {\n    //@TODO Implement SNVFilter\n}\n\n/**\n * @function powerFilter(power)\n * This function applies a power to all the Y values.<br>If the power is less than 1 and the spectrum has negative values, it will be shifted so that the lowest value is zero \n * @param   power   The power to apply\n * @returns this object\n */\nNMR.prototype.powerFilter=function(power) {\n    var minY=this.getMinY();\n    if(power<1 && minY<0){\n        this.YShift(-1*minY);\n        console.warn(\"SD.powerFilter: The spectrum had negative values and was automatically shifted before applying the function.\");\n    }\n    //@TODO Implement powerFilter\n}\n\n/**\n * @function logarithmFilter(base)\n * This function applies a log to all the Y values.<br>If the spectrum has negative or zero values, it will be shifted so that the lowest value is 1 \n * @param   base    The base to use\n * @returns this object\n */\nNMR.prototype.logarithmFilter=function(base) {\n    var minY=this.getMinY();\n    if(minY<=0){\n        this.YShift((-1*minY)+1);\n        console.warn(\"SD.logarithmFilter: The spectrum had negative values and was automatically shifted before applying the function.\");\n    }\n   //@TODO Implement logarithmFilter filter\n}\n\n\n/**\n * @function correlationFilter(func) \n * This function correlates the given spectraData with the given vector func. The correlation\n * operation (*) is defined as:\n * \n *                    __ inf\n *  c(x)=f(x)(*)g(x)= \\        f(x)*g(x+i)\n *                   ./    \n *                    -- i=-inf\n * @param func A double array containing the function to correlates the spectraData\n * @returns this object\n * @example var smoothedSP = SD.correlationFilter(spectraData,[1,1]) returns a smoothed version of the\n * given spectraData. \n */\nNMR.prototype.correlationFilter=function(func) {\n    //@TODO Implement correlationFilter filter\n}\n\n/**\n * @function  phaseCorrection(phi0, phi1)\n * Applies the phase correction (phi0,phi1) to a Fourier transformed spectraData. The angles must be given in radians.\n * @param phi0 Zero order phase correction\n * @param phi1 One order phase correction\n * @returns this object\n*/\nNMR.prototype.phaseCorrection=function(phi0, phi1) {\n    return Filters.phaseCorrection(this, phi0, phi1);\n}\n\n/**\n * @function automaticPhase() \n * This function determines automatically the correct parameters phi0 and phi1 for a phaseCorrection\n * function and applies it.\n * @returns this object\n */ \nNMR.prototype.automaticPhase=function() {\n    //@TODO Implement automaticPhase filter\n}\n\n\n/**\n * @function nmrPeakDetection(parameters);\n * This function process the given spectraData and tries to determine the NMR signals. Returns an NMRSignal1D array containing all the detected 1D-NMR Signals\n * @param parameters A JSONObject containing the optional parameters:\n * @option fromX:   Lower limit.\n * @option toX:     Upper limit.\n * @option threshold: The minimum intensity to consider a peak as a signal, expressed as a percentage of the highest peak. \n * @option stdev: Number of standard deviation of the noise for the threshold calculation if a threshold is not specified.\n * @returns {*}\n */\nNMR.prototype.nmrPeakDetection=function(parameters) {\n    return PeakPicking.peakPicking(this, parameters);\n}\n\n\n\nmodule.exports = NMR;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/spectra-data/src/NMR.js\n ** module id = 9\n ** module chunks = 0\n **/","'use strict';\n/**\n * Implementation of the peak pickig method described by Cobas in:\n * A new approach to improving automated analysis of proton NMR spectra\n * through Global Spectral Deconvolution (GSD)\n * http://www.spectroscopyeurope.com/images/stories/ColumnPDFs/TD_23_1.pdf\n */\nvar JAnalyzer = require('./JAnalyzer');\n/*var LM = require('ml-curve-fitting');\nvar Matrix = LM.Matrix;\nvar math = Matrix.algebra;*/\nvar GSD = require(\"ml-gsd\");\nvar extend = require(\"extend\");\nvar removeImpurities = require(\"./ImpurityRemover\");\n\nvar PeakPicking={\n    impurities:[],\n    maxJ:20,\n    defaultOptions:{nH:99,\n        clean:true,\n        realTop:false,\n        thresholdFactor:1,\n        compile:true,\n        integralFn:0,\n        optimize:true,\n        idPrefix:\"\",\n        format:\"old\"\n    },\n\n    peakPicking:function(spectrum, optionsEx){\n        var options = extend({}, this.defaultOptions, optionsEx);\n        var i, j, nHi, sum;\n\n        var noiseLevel = Math.abs(spectrum.getNoiseLevel())*(options.thresholdFactor);\n\n        //console.log(\"noiseLevel \"+noiseLevel);\n        var gsdOptions = extend({},\n            {noiseLevel: noiseLevel,\n                minMaxRatio:0.01,\n                broadRatio:0.0025,\n                smoothY:true,\n                nL:4,\n                sgOptions:{windowSize: 9, polynomial: 3}\n            },\n            options.gsdOptions);\n\n        var data = spectrum.getXYData();\n        var peakList = GSD.gsd(data[0],data[1], gsdOptions);\n        var peakList = GSD.post.joinBroadPeaks(peakList,{width:0.25});\n        if(options.optimize)\n            peakList = GSD.post.optimizePeaks(peakList,data[0],data[1],gsdOptions.nL,\"lorentzian\");\n\n        peakList = this.clearList(peakList, noiseLevel);\n        var signals = this.detectSignals(peakList, spectrum, options.nH, options.integralFn);\n        //console.log(JSON.stringify(signals));\n        //Remove all the signals with small integral\n        if(options.clean||false){\n            for(var i=signals.length-1;i>=0;i--){\n                if(signals[i].integralData.value<0.5) {\n                    signals.splice(i, 1);\n                }\n            }\n        }\n        if(options.compile||false){\n            for(i=0;i<signals.length;i++){\n                //console.log(\"Sum \"+signals[i].integralData.value);\n                JAnalyzer.compilePattern(signals[i]);\n                //console.log(signals[i])\n                if(signals[i].maskPattern&&signals[i].multiplicity!=\"m\"\n                    && signals[i].multiplicity!=\"\"){\n                    //Create a new signal with the removed peaks\n                    nHi = 0;\n                    sum=0;\n                    var peaksO = [];\n                    for(j=signals[i].maskPattern.length-1;j>=0;j--){\n                        sum+=this.area(signals[i].peaks[j]);\n\n                        if(signals[i].maskPattern[j]===false) {\n                            var peakR = signals[i].peaks.splice(j,1)[0];\n                            peaksO.push({x:peakR.x, y:peakR.intensity, width:peakR.width});\n                            //peaksO.push(peakR);\n                            signals[i].mask.splice(j,1);\n                            signals[i].mask2.splice(j,1);\n                            signals[i].maskPattern.splice(j,1);\n                            signals[i].nbPeaks--;\n                            nHi+=this.area(peakR);\n                        }\n                    }\n                    if(peaksO.length>0){\n                        nHi=nHi*signals[i].integralData.value/sum;\n                        signals[i].integralData.value-=nHi;\n                        var peaks1 = [];\n                        for(var j=peaksO.length-1;j>=0;j--)\n                            peaks1.push(peaksO[j]);\n                        var newSignals = this.detectSignals(peaks1, spectrum, nHi, options.integralFn);\n\n                        for(j=0;j<newSignals.length;j++)\n                            signals.push(newSignals[j]);\n                    }\n                }\n            }\n            //console.log(signals);\n            this.updateIntegrals(signals, options.nH);\n        }\n        signals.sort(function(a,b){\n            return b.delta1- a.delta1\n        });\n        //Remove all the signals with small integral\n        if(options.clean||false){\n            for(var i=signals.length-1;i>=0;i--){\n                //console.log(signals[i]);\n                if(signals[i].integralData.value<0.5) {\n                    signals.splice(i, 1);\n                }\n            }\n        }\n\n        for(var i=0;i<signals.length;i++){\n            if(options.idPrefix&&options.idPrefix.length>0)\n                signals[i].signalID = options.idPrefix+\"_\"+(i+1);\n            else\n                signals[i].signalID = (i+1)+\"\";\n            signals[i]._highlight=[signals[i].signalID];\n        }\n\n        removeImpurities(signals, spectrum.getSolventName(),options.nH);\n\n        if(options.format===\"new\"){\n            var newSignals = new Array(signals.length);\n            for(var i=0;i<signals.length;i++){\n                var signal = signals[i];\n                newSignals[i] = {\n                    from : signal.integralData.from,\n                    to : signal.integralData.to,\n                    integral : signal.integralData.value,\n                    signal:[{\n                        delta:signal.delta1,\n                        nbAtoms:0,\n                        diaID:[],\n                        multiplicity:signal.multiplicity,\n                        peak:signal.peaks,\n                        kind:\"\",\n                        remark:\"\"\n                    }],\n                    signalID:signal.signalID,\n                    _highlight:signal._highlight\n\n                };\n                if(signal.nmrJs){\n                    newSignals[i].signal[0].j = signal.nmrJs;\n                }\n            }\n            signals = newSignals;\n        }\n\n        return signals;\n\n\n        /*var frequency = spectrum.observeFrequencyX();//getParamDouble(\"$BF1\",400);\n        var imp = this.labelPeaks(peakList, solvent, frequency);\n        return [peakList,imp];\n        */\n        //return createSignals(peakList,nH);\n    },\n\n    clearList:function(peakList, threshold){\n        for(var i=peakList.length-1;i>=0;i--){\n            if(Math.abs(peakList[i].y)<threshold){\n                peakList.splice(i,1);\n            }\n        }\n        return peakList;\n    },\n\n\n    /**\n     * This method implements a non linear sampling of the spectrum. The point close to\n     * the critic points are more sampled than the other ones.\n     * @param spectrum\n     * @param peaks\n     * @param rowWise\n     */\n    sampling: function(spectrum, peaks, rowWise){\n        var i0, ie, ic,i, j,nbPoints;\n        var xy = []\n        if(i0>ie){\n            var tmp = i0;\n            i0 = ie;\n            ie = tmp;\n        }\n        //Non linear sampling for each peak.\n        for(i=0;i<peaks.length;i++){\n            var more = true;\n            var nL = 4;\n            while(more) {\n                i0 = spectrum.unitsToArrayPoint(peaks[i][0] - peaks[i][2] * nL);\n                ie = spectrum.unitsToArrayPoint(peaks[i][0] + peaks[i][2] * nL);\n                ic = spectrum.unitsToArrayPoint(peaks[i][0]);\n                if (i0 > ie) {\n                    tmp = i0;\n                    i0 = ie;\n                    ie = tmp;\n                }\n                i0 = i0 < 0 ? 0 : i0;\n                ie = ie >= spectrum.getNbPoints() ? spectrum.getNbPoints() - 1 : ie;\n\n                if (ie - i0 < 10) {\n                    for (j = i0; j <= ie; j++) {\n                        xy.push([spectrum.getX(j), spectrum.getY(j)]);\n                    }\n                    more = false;\n                }\n                else {\n                    xy.push([spectrum.getX(i0), spectrum.getY(i0)]);\n                    xy.push([spectrum.getX(ie), spectrum.getY(ie)]);\n                    if (nL > 0.5) {\n                        nL -= 0.5;\n                    }\n                    else {\n                        nL /= 2;\n                    }\n                }\n            }\n        }\n        //console.log(xy);\n        xy.sort(function(a,b){\n            return a[0]-b[0];\n        });\n        //console.log(\"XX \"+xy.length);\n        var x=[],y=[];\n        var index =0;\n        if(rowWise){\n            x=[xy[0][0]],y=[xy[0][1]];\n            for(i=1;i<xy.length;i++){\n                if(x[index]!=xy[i][0]){\n                    x.push(xy[i][0]);\n                    y.push(xy[i][1]);\n                    index++;\n                }\n            }\n        }\n        else{\n            x=[[xy[0][0]]],y=[[xy[0][1]]];\n            for(i=1;i<xy.length;i++){\n                if(x[index][0]!=xy[i][0]){\n                    x.push([xy[i][0]]);\n                    y.push([xy[i][1]]);\n                    index++;\n                }\n            }\n        }\n        return [x,y];\n\n    },\n\n    getVector: function(spectrum, from, to, rowWise){\n        var i0 = spectrum.unitsToArrayPoint(from);\n        var ie = spectrum.unitsToArrayPoint(to);\n        var x = [];\n        var y = [];\n        if(i0>ie){\n            var tmp = i0;\n            i0 = ie;\n            ie = tmp;\n        }\n        i0=i0<0?0:i0;\n        ie=ie>=spectrum.getNbPoints()?spectrum.getNbPoints()-1:ie;\n        for(var i=i0;i<ie;i+=10){\n            if(rowWise){\n                y.push(spectrum.getY(i));\n                x.push(spectrum.getX(i));\n            }\n            else{\n                y.push([spectrum.getY(i)]);\n                x.push([spectrum.getX(i)]);\n            }\n        }\n        return [x,y];\n    },\n\n\n\n    updateLimits : function(signal){\n        if(signal.multiplicity!=\"m\" && signal.multiplicity!=\"\"){\n            //Remove the integral of the removed peaks\n            var peaksO = signal.peaks;\n            var nbPeaks0 = peaksO.length, index = 0, factor = 0, toRemove = 0;\n\n            for(var i=0;i<nbPeaks0;i++){\n                if(signal.maskPattern[i]===false)\n                    toRemove+=this.area(peaksO[i]);\n                factor+= this.area(peaksO[i]);\n            }\n            factor=signal.integralData.value/factor;\n            signal.integralData.value-=toRemove*factor;\n        }\n        return signal.integralData.value;\n    },\n\n    updateIntegrals : function(signals, nH){\n        var sumIntegral = 0,i,sumObserved=0;\n        for(i=0;i<signals.length;i++){\n            sumObserved+=Math.round(signals[i].integralData.value);\n        }\n        if(sumObserved!=nH){\n\n            sumIntegral=nH/sumObserved;\n            for(i=0;i<signals.length;i++){\n                signals[i].integralData.value*=sumIntegral;\n            }\n        }\n    },\n\n    /*\n     {\n     \"nbPeaks\":1,\"multiplicity\":\"\",\"units\":\"PPM\",\"startX\":3.43505,\"assignment\":\"\",\n     \"pattern\":\"s\",\"stopX\":3.42282,\"observe\":400.08,\"asymmetric\":false,\n     \"delta1\":3.42752,\n     \"integralData\":{\"to\":3.43505,\"value\":590586504,\"from\":3.42282},\n     \"nucleus\":\"1H\",\n     \"peaks\":[{\"intensity\":60066147,\"x\":3.42752}]\n     }\n     */\n    detectSignals: function(peakList, spectrum, nH, integralType){\n\n        var frequency = spectrum.observeFrequencyX();\n        var signals = [];\n        var signal1D = {};\n        var prevPeak = {x:100000,y:0,width:0},peaks=null;\n        var rangeX = 16/frequency;//Peaks withing this range are considered to belongs to the same signal1D\n        var spectrumIntegral = 0,cs,sum, i,j;\n        //console.log(\"RangeX \"+rangeX);\n        for(i=0;i<peakList.length;i++){\n            //console.log(peakList[i]);\n            if(Math.abs(peakList[i].x-prevPeak.x)>rangeX){\n                //console.log(typeof peakList[i].x+\" \"+typeof peakList[i].width);\n                signal1D = {\"nbPeaks\":1,\"units\":\"PPM\",\n                    \"startX\":peakList[i].x+peakList[i].width,\n                    \"stopX\":peakList[i].x-peakList[i].width,\n                    \"multiplicity\":\"\",\"pattern\":\"\",\n                    \"observe\":frequency,\"nucleus\":\"1H\",\n                    \"integralData\":{\"from\":peakList[i].x-peakList[i].width*3,\n                                    \"to\":peakList[i].x+peakList[i].width*3\n                                    //\"value\":this.area(peakList[i])\n                    },\n                    \"peaks\":[]};\n                signal1D.peaks.push({x:peakList[i].x,\"intensity\":peakList[i].y, width:peakList[i].width});\n                signals.push(signal1D);\n                //spectrumIntegral+=this.area(peakList[i]);\n            }\n            else{\n                var tmp = peakList[i].x-peakList[i].width;\n                signal1D.stopX = Math.min(signal1D.stopX,tmp);\n                tmp = peakList[i].x+peakList[i].width;\n                signal1D.stopX = Math.max(signal1D.stopX,tmp);\n                signal1D.nbPeaks++;\n                signal1D.peaks.push({x:peakList[i].x,\"intensity\":peakList[i].y, width:peakList[i].width});\n                //signal1D.integralData.value+=this.area(peakList[i]);\n                signal1D.integralData.from = Math.min(signal1D.integralData.from, peakList[i].x-peakList[i].width*3);\n                signal1D.integralData.to = Math.max(signal1D.integralData.to,peakList[i].x+peakList[i].width*3);\n                //spectrumIntegral+=this.area(peakList[i]);\n            }\n            prevPeak = peakList[i];\n        }\n        //Normalize the integral to the normalization parameter and calculate cs\n        for(i=0;i<signals.length;i++){\n            peaks = signals[i].peaks;\n            var integral = signals[i].integralData;\n            cs = 0;\n            sum = 0;\n\n            for(var j=0;j<peaks.length;j++){\n                cs+=peaks[j].x*this.area(peaks[j]);//.intensity;\n                sum+=this.area(peaks[j]);\n            }\n            signals[i].delta1 = cs/sum;\n\n            if(integralType==0)\n                integral.value = sum;\n            else {\n                integral.value=spectrum.getArea(integral.from,integral.to);//*nH/spectrumIntegral;\n            }\n            spectrumIntegral+=integral.value;\n\n        }\n        for(var i=0;i<signals.length;i++){\n            //console.log(integral.value);\n            var integral = signals[i].integralData;\n            integral.value*=nH/spectrumIntegral;\n        }\n\n        return signals;\n    },\n\n    area: function(peak){\n        return Math.abs(peak.intensity*peak.width*1.57)//1.772453851);\n    },\n\n    /**\n     Updates the score that a given impurity is present in the current spectrum. In this part I would expect\n     to have into account the multiplicity of the signal. Also the relative intensity of the signals.\n     THIS IS the KEY part of the algorithm!!!!!!!!!\n     */\n    updateScore:function(candidates, peakList, maxIntensity, frequency){\n        //You may do it to avoid this part.\n        //return 1;\n\n        //Check the multiplicity\n        var mul = \"\";\n        var j = 0,index, k, maxJppm=this.maxJ/frequency;\n        var min=0, indexMin=0, score=0;\n        for(var i=candidates.length-1;i>=0;i--){\n            mul = candidates[i][1];\n            j = candidates[i][2];\n            //console.log(candidates[i][4]);\n            index = candidates[i][4][0];\n            //console.log(peakList[index][0]+\" \"+mul+\" \"+j+\" \"+index);\n            //I guess we should try to identify the pattern in the nearby.\n            if(mul.indexOf(\"sep\")>=0){\n                if(peakList[index][1]>maxIntensity*0.33){\n                    candidates.splice(i,1);//Not a candidate anymore.\n                }\n            }else{\n                if(mul.indexOf(\"s\")>=0||mul.indexOf(\"X\")>=0){\n                    k=index-1;\n                    min=peakList[index][1];\n                    indexMin=index;\n                    while(k>=0&&Math.abs(peakList[index][0]-peakList[k][0])<0.025){\n                        if(peakList[k][1]<min){\n                            min=peakList[k][1];\n                            indexMin=k;\n                        }\n                        k--;\n                    }\n                    k=index+1;\n                    while(k<peakList.length&&Math.abs(peakList[index][0]-peakList[k][0])<0.025){\n                        if(peakList[k][1]<min){\n                            min=peakList[k][1];\n                            indexMin=k;\n                        }\n                        k++;\n                    }\n                    candidates[i][4][0]=indexMin;\n                    score+=1;\n                }\n            }\n            if(mul.indexOf(\"d\")>=0){\n                if(index>0&&index<peakList.length-1){\n                    var thisJ1 = Math.abs(Math.abs(peakList[index-1][0]-peakList[index][0])*frequency-j);\n                    var thisJ2 = Math.abs(Math.abs(peakList[index+1][0]-peakList[index][0])*frequency-j);\n                    var thisJ3 = Math.abs(Math.abs(peakList[index+1][0]-peakList[index-1][0])*frequency-j);\n                    if(thisJ1<2||thisJ2<2||thisJ3<2){\n                        if(thisJ1<thisJ2){\n                            if(thisJ1<thisJ3){\n                                candidates[i][4]=[index-1,index];\n                                score+=1;\n                            }\n                            else{\n                                candidates[i][4]=[index-1,index+1];\n                                score+=1;\n                            }\n                        }\n                        else{\n                            if(thisJ2<thisJ3){\n                                candidates[i][4]=[index,index+1];\n                                score+=1;\n                            }\n                            else{\n                                candidates[i][4]=[index-1,index+1];\n                                score+=1;\n                            }\n                        }\n                    }\n                }\n            }\n            if(mul.indexOf(\"t\")>=0){\n                //console.log(\"here\");\n                if(index>0&&index<peakList.length-1){\n                    var thisJ1 = Math.abs(Math.abs(peakList[index-1][0]-peakList[index][0])*frequency-j);\n                    var thisJ2 = Math.abs(Math.abs(peakList[index+1][0]-peakList[index][0])*frequency-j);\n                    var thisJ4 = Math.abs(Math.abs(peakList[index+1][0]-peakList[index+2][0])*frequency-j);\n                    //console.log(\"XX \"+thisJ1+\" \"+thisJ2);\n                    if(thisJ1<2){\n                        candidates[i][4]=[index-1, index];\n                        score+=0.5;\n                    }\n                    if(thisJ2<2){\n                        candidates[i][4].push(index+1);\n                        score+=0.5;\n                    }\n                    if(thisJ3<2){\n                        candidates[i][4].push(index+2);\n                        score+=0.5;\n                    }\n\n                }\n            }\n            if(mul.indexOf(\"q\")>=0){\n                if(index>1&&index<peakList.length-2){\n                    var thisJ1 = Math.abs(Math.abs(peakList[index-2][0]-peakList[index-1][0])*frequency-j);\n                    var thisJ2 = Math.abs(Math.abs(peakList[index-1][0]-peakList[index][0])*frequency-j);\n                    var thisJ3 = Math.abs(Math.abs(peakList[index+1][0]-peakList[index][0])*frequency-j);\n                    var thisJ4= Math.abs(Math.abs(peakList[index+2][0]-peakList[index+1][0])*frequency-j);\n                    if(thisJ1<2){\n                        candidates[i][4].push(index-2);\n                        score+=0.25;\n                    }\n                    if(thisJ2<2){\n                        candidates[i][4].push(index-1);\n                        score+=0.25;\n                    }\n                    if(thisJ3<2){\n                        candidates[i][4].push(index+1);\n                        score+=0.25;\n                    }\n                    if(thisJ4<2){\n                        candidates[i][4].push(index+2);\n                        score+=0.25;\n                    }\n                }\n            }\n        }\n\n        //console.log(score/candidates.length+ \" -> \"+candidates);\n        //Lets remove the candidates to be impurities.\n        //It would be equivalent to mark the peaks as valid again\n        if(score/candidates.length < 0.5){\n            for(var i=candidates.length-1;i>=0;i--){\n                candidates.splice(i,1);\n            }\n            return 0;\n        }\n        //Check the relative intensity\n        return 1;\n    },\n\n    score:function(value, gamma){\n        return Math.exp(-Math.pow(value/gamma,2)/2.0);\n    }\n\n}\n\nmodule.exports = PeakPicking;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/spectra-data/src/PeakPicking.js\n ** module id = 10\n ** module chunks = 0\n **/","'use strict';\n/**\n * This library implements the J analyser described by Cobas et al in the paper:\n * A two-stage approach to automatic determination of 1H NMR coupling constants\n * Created by acastillo on 4/5/15.\n */\nvar JAnalyzer = {\n    pascalTriangle : [[0],[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]],\n    patterns: [\"s\",\"d\",\"t\",\"q\",\"quint\",\"h\",\"sept\",\"o\",\"n\"],\n    symRatio : 1.5,\n    maxErrorIter1 : 2.5,//Hz\n    maxErrorIter2 : 1,//Hz\n    DEBUG : false,\n\n    /**\n     * The compilation process implements at the first stage a normalization procedure described by Golotvin et al.\n     * embedding in peak-component-counting method described by Hoyes et al.\n     * @param signal\n     */\n    compilePattern : function(signal){\n        if(this.DEBUG)console.log(\"Debugin...\");\n\n        signal.multiplicity=\"m\";//By default the multiplicity is massive\n        // 1.1 symmetrize\n        // It will add a set of peaks(signal.peaksComp) to the signal that will be used during\n        // the compilation process. The unit of those peaks will be in Hz\n        signal.symRank = this.symmetrizeChoiseBest(signal,this.maxErrorIter1,1);\n        signal.asymmetric = true;\n       // console.log(signal.delta1+\" \"+signal.symRank);\n        //Is the signal symmetric?\n        if(signal.symRank>=0.95&&signal.peaksComp.length<32){\n            if(this.DEBUG)console.log(signal.delta1+ \" nbPeaks \"+signal.peaksComp.length);\n            signal.asymmetric = false;\n            var i,j,n,k=1,P1,Jc=[],n2,maxFlagged;\n            //Loop over the possible number of coupling contributing to the multiplet\n            for(n=0;n<9;n++){\n                if(this.DEBUG)console.log(\"Trying \"+n+\" couplings\");\n                //1.2 Normalize. It makes a deep copy of the peaks before to modify them.\n                var peaks = this.normalize(signal,n);\n                //signal.peaksCompX = peaks;\n                var validPattern = false;//It will change to true, when we find the good patter\n                //Lets check if the signal could be a singulet.\n                if(peaks.length == 1 && n === 0){\n                    validPattern=true;\n                }\n                else{\n                    if(peaks.length <= 1){\n                        continue;\n                    }\n                }\n                // 1.3 Establish a range for the Heights Hi [peaks.intensity*0.85,peaks.intensity*1.15];\n                var ranges = this.getRanges(peaks);\n                n2 = Math.pow(2,n);\n\n                if(this.DEBUG){\n                    console.log(\"ranges: \"+JSON.stringify(ranges));\n                    console.log(\"Target sum: \"+n2);\n                }\n\n                // 1.4 Find a combination of integer heights Hi, one from each Si, that sums to 2^n.\n                var heights = null;\n                while(!validPattern&&(heights = this.getNextCombination(ranges, n2))!==null){\n\n                    if(this.DEBUG){\n                        console.log(\"Possible pattern found with \"+n+\" couplings!!!\");\n                        console.log(heights);\n                    }\n                    // 2.1 Number the components of the multiplet consecutively from 1 to 2n,\n                    //starting at peak 1\n                    var numbering = new Array(heights.length);\n                    k=1;\n                    for(i=0;i<heights.length;i++){\n                        numbering[i]=new Array(heights[i]);\n                        for(j=0;j<heights[i];j++){\n                            numbering[i][j]=k++;\n                        }\n                    }\n                    if(this.DEBUG){\n                        console.log(\"Numbering: \"+JSON.stringify(numbering));\n                    }\n                    Jc = []; //The array to store the detected j-coupling\n                    // 2.2 Set j = 1; J1 = P2 - P1. Flag components 1 and 2 as accounted for.\n                    j=1;\n                    Jc.push(peaks[1].x-peaks[0].x);\n                    P1 = peaks[0].x;\n                    numbering[0].splice(0,1);//Flagged\n                    numbering[1].splice(0,1);//Flagged\n                    k=1;\n                    var nFlagged = 2;\n                    maxFlagged = Math.pow(2,n)-1;\n                    while(Jc.length<n&&nFlagged<maxFlagged&&k<peaks.length){\n                        if(this.DEBUG){\n                            console.log(\"New Jc\"+JSON.stringify(Jc));\n                            console.log(\"Aval. numbering \"+JSON.stringify(numbering));\n                        }\n                        // 4.1. Increment j. Set k to the number of the first unflagged component.\n                        j++;\n                        while(k<peaks.length&&numbering[k].length===0){\n                            k++;\n                        }\n                        if(k<peaks.length){\n                            // 4.2 Jj = Pk - P1.\n                            Jc.push(peaks[k].x-peaks[0].x);\n                            //Flag component k and, for each sum of the...\n                            numbering[k].splice(0,1);//Flageed\n                            nFlagged++;\n                            //Flag the other components of the multiplet\n                            for(var u=2;u<=j;u++){\n                                //TODO improve those loops\n                                var jSum = 0;\n                                for(i=0;i<u;i++){\n                                    jSum+=Jc[i];\n                                }\n                                for(i=1;i<numbering.length;i++){\n                                    //Maybe 0.25 Hz is too much?\n                                    if(Math.abs(peaks[i].x-(P1+jSum))<0.25){\n                                        numbering[i].splice(0,1);//Flageed\n                                        nFlagged++;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    //Calculate the ideal patter by using the extracted j-couplings\n                    var pattern = this.idealPattern(Jc);\n                    //Compare the ideal pattern with the proposed intensities.\n                    // All the intensities have to match to accept the multiplet\n                    validPattern = true;\n                    for(i=0;i<pattern.length;i++){\n                        if(pattern[i].intensity != heights[i])\n                            validPattern = false;\n                    }\n                    //More verbosity of the process\n                    if(this.DEBUG){\n                        console.log(\"Jc \"+JSON.stringify(Jc));\n                        console.log(\"Heights \"+JSON.stringify(heights));\n                        console.log(\"pattern \"+JSON.stringify(pattern));\n                        console.log(\"Valid? \"+validPattern);\n                    }\n                }\n                //If we found a valid pattern we should inform about the pattern.\n                if(validPattern){\n                    this.updateSignal(signal,Jc);\n                }\n            }\n        }\n\n        //Before to return, change the units of peaksComp from Hz to PPM again\n        for(i=0;i<signal.peaksComp.length;i++){\n            signal.peaksComp[i].x/=signal.observe;\n        }\n    },\n\n    updateSignal : function(signal, Jc){\n        //Update the limits of the signal\n        var peaks = signal.peaksComp;//Always in Hz\n        var nbPeaks = peaks.length;\n        signal.startX=peaks[0].x/signal.observe+peaks[0].width;\n        signal.stopX=peaks[nbPeaks-1].x/signal.observe-peaks[nbPeaks-1].width;\n        signal.integralData.to=peaks[0].x/signal.observe+peaks[0].width*3;\n        signal.integralData.from=peaks[nbPeaks-1].x/signal.observe-peaks[nbPeaks-1].width*3;\n\n        //Compile the pattern and format the constant couplings\n        signal.maskPattern = signal.mask2;\n        signal.multiplicity = this.abstractPattern(signal,Jc);\n        signal.pattern=signal.multiplicity;//Our library depends on this parameter, but it is old\n        //console.log(signal);\n        if(this.DEBUG)\n            console.log(\"Final j-couplings: \"+JSON.stringify(Jc));\n    },\n\n    /**\n     * Returns the multiplet in the compact format\n     */\n    abstractPattern : function(signal,Jc){\n        var tol = 0.05,i, pattern = \"\", cont = 1;\n        var newNmrJs = [];\n        if(Jc&&Jc.length>0){\n            Jc.sort(function(a,b){\n                return a-b;\n            });\n            for(i=0;i<Jc.length-1;i++){\n                if(Math.abs(Jc[i]-Jc[i+1])<tol){\n                    cont++;\n                }\n                else{\n                    newNmrJs.push({\"coupling\":Math.abs(Jc[i]),\"multiplicity\":this.patterns[cont]});\n                    pattern+=this.patterns[cont];\n                    cont=1;\n                }\n            }\n            newNmrJs.push({\"coupling\":Math.abs(Jc[i]),\"multiplicity\":this.patterns[cont]});\n            pattern+=this.patterns[cont];\n            signal.nmrJs =  newNmrJs;\n        }\n        else{\n            pattern=\"s\";\n            if(Math.abs(signal.startX-signal.stopX)*signal.observe>16){\n                pattern=\"br s\"\n            }\n        }\n        return pattern;\n    },\n\n    /**\n     *This function creates an ideal pattern from the given J-couplings\n     */\n    idealPattern : function(Jc){\n        var hsum = Math.pow(2,Jc.length),i,j;\n        var pattern = [{x:0,intensity:hsum}];\n        //To split the initial height\n        for(i=0;i<Jc.length;i++){\n            for(j=pattern.length-1;j>=0;j--){\n                pattern.push({x:pattern[j].x+Jc[i]/2,\n                    intensity:pattern[j].intensity/2});\n                pattern[j].x = pattern[j].x-Jc[i]/2;\n                pattern[j].intensity = pattern[j].intensity/2;\n            }\n        }\n        //To sum the heights in the same positions\n        pattern.sort(function compare(a,b) { return a.x-b.x});\n        for(j=pattern.length-2;j>=0;j--){\n            if(Math.abs(pattern[j].x-pattern[j+1].x)<0.1){\n                pattern[j].intensity+= pattern[j+1].intensity\n                pattern.splice(j+1,1);\n            }\n        }\n        return pattern;\n    },\n\n    /**\n     * Find a combination of integer heights Hi, one from each Si, that sums to 2n.\n     */\n    getNextCombination : function(ranges, value){\n        var half = Math.ceil(ranges.values.length/2), lng = ranges.values.length;\n        var sum = 0,i,ok;\n        while(sum!=value){\n            //Update the indexes to point at the next possible combination\n            ok = false;\n            var leftIndex = 0;\n            while(!ok){\n                ok = true;\n                ranges.currentIndex[ranges.active]++;\n                if(ranges.currentIndex[ranges.active]>=ranges.values[ranges.active].length){\n                    //In this case, there is no more possible combinations\n                    if(ranges.active+1==half){\n                        return null;\n                    }\n                    else{\n                        //If this happens we need to try the next active peak\n                        ranges.currentIndex[ranges.active]=0;\n                        ok=false;\n                        ranges.active++;\n                    }\n                }\n                else{\n                    ranges.active=0;\n                }\n            }\n            // Sum the heights for this combination\n            sum=0;\n            for(i=0;i<half;i++){\n                sum+= ranges.values[i][ranges.currentIndex[i]]*2;\n            }\n            if(ranges.values.length%2!==0){\n                sum-= ranges.values[half-1][ranges.currentIndex[half-1]];\n            }\n            if(this.DEBUG){\n                console.log(ranges.currentIndex);\n                console.log(sum+\" \"+value);\n            }\n        }\n        //If the sum is equal to the expected value, fill the array to return\n        if(sum==value){\n            var heights = new Array(lng);\n            for(i=0;i<half;i++){\n                heights[i] = ranges.values[i][ranges.currentIndex[i]];\n                heights[lng-i-1] = ranges.values[i][ranges.currentIndex[i]];\n            }\n            return heights;\n        }\n        return null;\n    },\n\n    /**\n     * This function generates the possible values that each peak can contribute\n     * to the multiplet.\n     * @param peaks\n     * @returns {{values: Array, currentIndex: Array, active: number}}\n     */\n    getRanges : function(peaks){\n        var ranges = new Array(peaks.length);\n        var currentIndex = new Array(peaks.length);\n        var min,max;\n        ranges[0] = [1];\n        ranges[peaks.length-1] = [1];\n        currentIndex[0]=-1;\n        currentIndex[peaks.length-1] = 0;\n        for(var i=1;i<peaks.length-1;i++){\n            min = Math.round(peaks[i].intensity*0.85);\n            max = Math.round(peaks[i].intensity*1.15);\n            ranges[i] =[];\n            for(var j=min;j<=max;j++){\n                ranges[i].push(j);\n            }\n            currentIndex[i]=0;\n        }\n        return {values:ranges, currentIndex:currentIndex, active:0};\n    },\n    /**\n     * Performs a symmetrization of the signal by using different aproximations to the center.\n     * It will return the result of the symmetrization that removes less peaks from the signal\n     * @param signal\n     * @param maxError\n     * @param iteration\n     * @returns {*}\n     */\n    symmetrizeChoiseBest : function(signal,maxError,iteration){\n        var symRank1 = this.symmetrize(signal,maxError,iteration);\n        var tmpPeaks = signal.peaksComp;\n        var tmpMask = signal.mask;\n        var cs = signal.delta1;\n        signal.delta1 = (signal.peaks[0].x+signal.peaks[signal.peaks.length-1].x)/2;\n        var symRank2 = this.symmetrize(signal,maxError,iteration);\n        if(signal.peaksComp.length>tmpPeaks.length)\n            return symRank2;\n        else{\n            signal.delta1 = cs;\n            signal.peaksComp = tmpPeaks;\n            signal.mask = tmpMask;\n            return symRank1;\n        }\n\n    },\n    /**\n     * This function will return a set of symmetric peaks that will\n     * be the enter point for the patter compilation process.\n     */\n    symmetrize : function(signal, maxError, iteration){\n        //Before to symmetrize we need to keep only the peaks that possibly conforms the multiplete\n        var max, min, avg, ratio, avgWidth, j;\n        var peaks = new Array(signal.peaks.length);\n        //Make a deep copy of the peaks and convert PPM ot HZ\n        for(j=0;j<peaks.length;j++){\n            peaks[j]= {x:signal.peaks[j].x*signal.observe,\n                intensity:signal.peaks[j].intensity,\n                width:signal.peaks[j].width};\n        }\n        //Join the peaks that are closer than 0.25 Hz\n        for(j=peaks.length-2;j>=0;j--){\n            if(Math.abs(peaks[j].x-peaks[j+1].x)<0.25){\n                peaks[j].x = (peaks[j].x*peaks[j].intensity+peaks[j+1].x*peaks[j+1].intensity);\n                peaks[j].intensity = peaks[j].intensity+peaks[j+1].intensity;\n                peaks[j].x/=peaks[j].intensity;\n                peaks[j].intensity/=2;\n                peaks[j].width+=peaks[j+1].width;\n                peaks.splice(j+1,1);\n            }\n        }\n        signal.peaksComp = peaks;\n        var nbPeaks = peaks.length;\n        var mask = new Array(nbPeaks);\n        signal.mask = mask;\n        var left=0, right=peaks.length-1, cs = signal.delta1*signal.observe, middle = [(peaks[0].x+peaks[nbPeaks-1].x)/2,1];\n        maxError = this.error(Math.abs(cs-middle[0]));\n        var heightSum = 0;\n        //We try to symmetrize the extreme peaks. We consider as candidates for symmetricing those which have\n        //ratio smaller than 3\n        for(var i=0;i<nbPeaks;i++){\n            mask[i]= true;\n            heightSum+=signal.peaks[i].intensity;\n        }\n\n        while(left<=right){\n            mask[left] = true;\n            mask[right] = true;\n            if(left==right){\n                if(nbPeaks>2&&Math.abs(peaks[left].x-cs)>maxError){\n                    mask[left] = false;\n                }\n            }\n            else{\n                max = Math.max(peaks[left].intensity,peaks[right].intensity);\n                min = Math.min(peaks[left].intensity,peaks[right].intensity);\n                ratio = max/min;\n                if(ratio>this.symRatio){\n                    if(peaks[left].intensity==min){\n                        mask[left] = false;\n                        right++;\n                    }\n                    else{\n                        mask[right] = false;\n                        left--;\n                    }\n                }\n                else{\n                    var diffL = Math.abs(peaks[left].x-cs);\n                    var diffR = Math.abs(peaks[right].x-cs);\n\n                    if(Math.abs(diffL-diffR)<maxError){\n                        //avg = (peaks[left].intensity+peaks[right].intensity)/2;\n                        avg = Math.min(peaks[left].intensity,peaks[right].intensity);\n                        avgWidth = Math.min(peaks[left].width,peaks[right].width);\n                        peaks[left].intensity=peaks[right].intensity=avg;\n                        peaks[left].width=peaks[right].width=avgWidth;\n                        middle=[middle[0]+((peaks[right].x+peaks[left].x)/2), middle[1]+1];\n                    }\n                    else{\n                        if(Math.max(diffL,diffR)==diffR){\n                            mask[right] = false;\n                            left--;\n                        }\n                        else{\n                            mask[left] = false;\n                            right++;\n                        }\n                    }\n                    if(this.DEBUG){\n                        console.log(\"MaxError: \"+maxError+\" \"+middle[0]+\" \"+middle[1]);\n                        console.log(iteration+\" CS: \"+cs+\" Hz \"+cs/signal.observe+\" PPM\");\n                        console.log(\"Middle: \"+(middle[0]/middle[1])+\" Hz \"+(middle[0]/middle[1])/signal.observe+\" PPM\");\n                        console.log(diffL+ \" \"+diffR);\n                        console.log(Math.abs(diffL-diffR));\n                        console.log(JSON.stringify(peaks));\n                        console.log(JSON.stringify(mask));\n                    }\n                }\n            }\n            left++;\n            right--;\n            //Only alter cs if it is the first iteration of the sym process.\n            if(iteration==1){\n                cs = this.chemicalShift(peaks, mask);\n                //There is not more available peaks\n                if(isNaN(cs)){ return 0;}\n            }\n            maxError = this.error(Math.abs(cs-middle[0]/middle[1]));\n        }\n        //To remove the weak peaks and recalculate the cs\n        for(i=nbPeaks-1;i>=0;i--){\n            if(mask[i]===false){\n                peaks.splice(i,1);\n            }\n        }\n        cs = this.chemicalShift(peaks);\n        if(isNaN(cs)){ return 0;}\n        signal.delta1 = cs/signal.observe;\n        //Now, the peak should be symmetric in heights, but we need to know if it is symmetric in x\n        var symFactor = 0,weight = 0;\n        if(peaks.length>1){\n            for(i=Math.ceil(peaks.length/2)-1;i>=0;i--){\n                symFactor+=(3+Math.min(Math.abs(peaks[i].x-cs),Math.abs(peaks[peaks.length-1-i].x-cs)))\n                /(3+Math.max(Math.abs(peaks[i].x-cs),Math.abs(peaks[peaks.length-1-i].x-cs)))*peaks[i].intensity;\n                weight+=peaks[i].intensity;\n            }\n            symFactor/=weight;\n        }\n        else{\n            if(peaks.length==1)\n                symFactor=1;\n        }\n        var newSumHeights = 0;\n        for(i=0;i<peaks.length;i++){\n            newSumHeights+=peaks[i].intensity;\n        }\n        symFactor-=(heightSum-newSumHeights)/heightSum*0.12; //Removed peaks penalty\n        if(this.DEBUG){\n            console.log(\"Penalty \"+(heightSum-newSumHeights)/heightSum*0.12);\n            console.log(\"cs: \"+(cs/signal.observe)+\" symFactor: \"+symFactor);\n        }\n        //Sometimes we need a second opinion after the first symmetrization.\n        if(symFactor>0.8&&symFactor<0.97&&iteration<2){\n            return this.symmetrize(signal, this.maxErrorIter2, 2);\n        }{\n            //Center the given pattern at cs and symmetrize x\n            if(peaks.length>1) {\n                var weight = 0, dxi;\n                for (i = Math.ceil(peaks.length / 2) - 1; i >= 0; i--) {\n                    dxi = (peaks[i].x - peaks[peaks.length - 1 - i].x)/2.0;\n                    peaks[i].x =cs+dxi;\n                    peaks[peaks.length - 1 - i].x=cs-dxi;\n                }\n            }\n        }\n        return symFactor;\n    },\n\n    error : function(value){\n        var maxError = value*2.5;\n        if(maxError<0.75)\n            maxError = 0.75;\n        if(maxError > 3)\n            maxError = 3;\n        return maxError;\n    },\n    /**\n     * 2 stages normalizarion of the peaks heights to Math.pow(2,n).\n     * Creates a new mask with the peaks that could contribute to the multiplete\n     * @param signal\n     * @param n\n     * @returns {*}\n     */\n    normalize : function(signal, n){\n        //Perhaps this is slow\n        var peaks = JSON.parse(JSON.stringify(signal.peaksComp));\n        var norm = 0,norm2=0,i;//Math.pow(2,n);\n        for(i=0;i<peaks.length;i++){\n            norm+= peaks[i].intensity;\n        }\n        norm=Math.pow(2,n)/norm;\n        signal.mask2 = JSON.parse(JSON.stringify(signal.mask));\n        //console.log(\"Mask0 \"+JSON.stringify(signal.mask2));\n        var index=signal.mask2.length-1;\n        for(i=peaks.length-1;i>=0;i--){\n            peaks[i].intensity*= norm;\n            while(index>=0&&signal.mask2[index]===false)\n                index--;\n            if(peaks[i].intensity<0.75){\n                if(this.DEBUG)\n                    console.log(\"Peak \"+i+\" does not seem to belong to this multiplet \"+peaks[i].intensity);\n                peaks.splice(i,1);\n                signal.mask2[index]=false;\n            }\n            else{\n                norm2+= peaks[i].intensity;\n            }\n            index--;\n        }\n        norm2=Math.pow(2,n)/norm2;\n        for(i=peaks.length-1;i>=0;i--){\n            peaks[i].intensity*= norm2;\n        }\n        //console.log(\"Mask1 \"+JSON.stringify(signal.mask2));\n        if(this.DEBUG) console.log(JSON.stringify(peaks));\n        return peaks;\n    },\n\n    /**\n     * Calculates the chemical shift as the weighted sum of the peaks\n     * @param peaks\n     * @param mask\n     * @returns {number}\n     */\n    chemicalShift : function(peaks, mask){\n        var sum=0,cs= 0, i, area;\n        if(mask){\n            for(i=0;i<peaks.length;i++){\n                //console.log(mask[i]);\n                if(mask[i]===true){\n                    area = this.area(peaks[i]);\n                    sum+=area;\n                    cs+=area*peaks[i].x;\n                }\n            }\n        }\n        else{\n            for(i=0;i<peaks.length;i++){\n                area = this.area(peaks[i]);\n                sum+=area;\n                cs+=area*peaks[i].x;\n            }\n        }\n        return cs/sum;\n    },\n\n    area: function(peak){\n        return Math.abs(peak.intensity*peak.width*1.57)//1.772453851);\n    }\n}\n\nmodule.exports = JAnalyzer;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/spectra-data/src/JAnalyzer.js\n ** module id = 11\n ** module chunks = 0\n **/","\nmodule.exports.post = require(\"../src/optimize\");\nmodule.exports.gsd = require(\"../src/gsd\");\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-gsd/src/index.js\n ** module id = 12\n ** module chunks = 0\n **/","/**\n * Created by acastillo on 9/6/15.\n */\nvar Opt = require(\"ml-optimize-lorentzian\");\n\nfunction sampleFunction(from, to, x, y, lastIndex){\n    var nbPoints = x.length;\n    var sampleX = [];\n    var sampleY = [];\n    var direction = Math.sign(x[1]-x[0]);//Direction of the derivative\n    if(direction==-1){\n        lastIndex[0]= x.length-1;\n    }\n\n    var delta = Math.abs(to-from)/2;\n    var mid = (from+to)/2;\n    var stop = false;\n    var index = lastIndex[0];\n    while(!stop&&index<nbPoints&&index>=0){\n        if(Math.abs(x[index]-mid)<=delta){\n            sampleX.push(x[index]);\n            sampleY.push(y[index]);\n            index+=direction;\n        }\n        //It is outside the range.\n        else{\n\n            if(Math.sign(mid-x[index])==1){\n                //We'll reach the mid going in the current direction\n                index+=direction;\n            }\n            else{\n                //There is not more peaks in the current range\n                stop=true;\n            }\n        }\n        //console.log(sampleX);\n    }\n    lastIndex[0]=index;\n    return [sampleX, sampleY];\n}\n\nfunction optimizePeaks(peakList,x,y,n, fnType){\n    var i, j, lastIndex=[0];\n    var groups = groupPeaks(peakList,n);\n    var result = [];\n    var factor = 1;\n    if(fnType==\"gaussian\")\n        factor = 1.17741;//From https://en.wikipedia.org/wiki/Gaussian_function#Properties\n    for(i=0;i<groups.length;i++){\n        var peaks = groups[i].group;\n        if(peaks.length>1){\n            //Multiple peaks\n            //console.log(\"Pending group of overlaped peaks \"+peaks.length);\n            //console.log(\"here1\");\n            //console.log(groups[i].limits);\n            var sampling = sampleFunction(groups[i].limits[0]-groups[i].limits[1],groups[i].limits[0]+groups[i].limits[1],x,y,lastIndex);\n            //console.log(sampling);\n            if(sampling[0].length>5){\n                var error = peaks[0].width/1000;\n                var opts = [  3,    100, error, error, error, error*10, error*10,    11,    9,        1 ];\n                //var gauss = Opt.optimizeSingleGaussian(sampling[0], sampling[1], opts, peaks);\n                var optPeaks = [];\n                if(fnType==\"gaussian\")\n                    optPeaks = Opt.optimizeGaussianSum(sampling, peaks, opts);\n                else{\n                    if(fnType==\"lorentzian\"){\n                        optPeaks = Opt.optimizeLorentzianSum(sampling, peaks, opts);\n                    }\n                }\n                //console.log(optPeak);\n                for(j=0;j<optPeaks.length;j++){\n                    result.push({x:optPeaks[j][0][0],y:optPeaks[j][1][0],width:optPeaks[j][2][0]*factor});\n                }\n            }\n        }\n        else{\n            //Single peak\n            peaks = peaks[0];\n            var sampling = sampleFunction(peaks.x-n*peaks.width,\n                peaks.x+n*peaks.width,x,y,lastIndex);\n            //console.log(\"here2\");\n            //console.log(groups[i].limits);\n            if(sampling[0].length>5){\n                var error = peaks.width/1000;\n                var opts = [  3,    100, error, error, error, error*10, error*10,    11,    9,        1 ];\n                //var gauss = Opt.optimizeSingleGaussian(sampling[0], sampling[1], opts, peaks);\n                //var gauss = Opt.optimizeSingleGaussian([sampling[0],sampling[1]], peaks, opts);\n                var optPeak = [];\n                if(fnType==\"gaussian\")\n                    var optPeak = Opt.optimizeSingleGaussian([sampling[0],sampling[1]], peaks,  opts);\n                else{\n                    if(fnType==\"lorentzian\"){\n                        var optPeak = Opt.optimizeSingleLorentzian([sampling[0],sampling[1]], peaks,  opts);\n                    }\n                }\n                //console.log(optPeak);\n                result.push({x:optPeak[0][0],y:optPeak[1][0],width:optPeak[2][0]*factor}); // From https://en.wikipedia.org/wiki/Gaussian_function#Properties}\n            }\n        }\n\n    }\n    return result;\n}\n\nfunction groupPeaks(peakList,nL){\n    var group = [];\n    var groups = [];\n    var i, j;\n    var limits = [peakList[0].x,nL*peakList[0].width];\n    var upperLimit, lowerLimit;\n    //Merge forward\n    for(i=0;i<peakList.length;i++){\n        //If the 2 things overlaps\n        if(Math.abs(peakList[i].x-limits[0])<(nL*peakList[i].width+limits[1])){\n            //Add the peak to the group\n            group.push(peakList[i]);\n            //Update the group limits\n            upperLimit = limits[0]+limits[1];\n            if(peakList[i].x+nL*peakList[i].width>upperLimit){\n                upperLimit = peakList[i].x+nL*peakList[i].width;\n            }\n            lowerLimit = limits[0]-limits[1];\n            if(peakList[i].x-nL*peakList[i].width<lowerLimit){\n                lowerLimit = peakList[i].x-nL*peakList[i].width;\n            }\n            limits = [(upperLimit+lowerLimit)/2,Math.abs(upperLimit-lowerLimit)/2];\n\n        }\n        else{\n            groups.push({limits:limits,group:group});\n            //var optmimalPeak = fitSpectrum(group,limits,spectrum);\n            group=[peakList[i]];\n            limits = [peakList[i].x,nL*peakList[i].width];\n        }\n    }\n    groups.push({limits:limits,group:group});\n    //Merge backward\n    for(i =groups.length-2;i>=0;i--){\n        //The groups overlaps\n        if(Math.abs(groups[i].limits[0]-groups[i+1].limits[0])<\n            (groups[i].limits[1]+groups[i+1].limits[1])/2){\n            for(j=0;j<groups[i+1].group.length;j++){\n                groups[i].group.push(groups[i+1].group[j]);\n            }\n            upperLimit = groups[i].limits[0]+groups[i].limits[1];\n            if(groups[i+1].limits[0]+groups[i+1].limits[1]>upperLimit){\n                upperLimit = groups[i+1].limits[0]+groups[i+1].limits[1];\n            }\n            lowerLimit = groups[i].limits[0]-groups[i].limits[1];\n            if(groups[i+1].limits[0]-groups[i+1].limits[1]<lowerLimit){\n                lowerLimit = groups[i+1].limits[0]-groups[i+1].limits[1];\n            }\n            //console.log(limits);\n            groups[i].limits = [(upperLimit+lowerLimit)/2,Math.abs(upperLimit-lowerLimit)/2];\n\n            groups.splice(i+1,1);\n        }\n    }\n    return groups;\n}\n/**\n * This function try to join the peaks that seems to belong to a broad signal in a single broad peak.\n * @param peakList\n * @param options\n */\nfunction joinBroadPeaks(peakList, options){\n    var width = options.width;\n    var broadLines=[];\n    //Optimize the possible broad lines\n    var max=0, maxI=0,count=1;\n    var isPartOf = false;\n    for(var i=peakList.length-1;i>=0;i--){\n        if(peakList[i].soft){\n            broadLines.push(peakList.splice(i,1)[0]);\n        }\n    }\n    //Push a feak peak\n    broadLines.push({x:Number.MAX_VALUE});\n\n    var candidates = [[broadLines[0].x,\n                        broadLines[0].y]];\n    var indexes = [0];\n\n    for(var i=1;i<broadLines.length;i++){\n        //console.log(broadLines[i-1].x+\" \"+broadLines[i].x);\n        if(Math.abs(broadLines[i-1].x-broadLines[i].x)<width){\n            candidates.push([broadLines[i].x,broadLines[i].y]);\n            if(broadLines[i].y>max){\n                max = broadLines[i].y;\n                maxI = i;\n            }\n            indexes.push(i);\n            count++;\n        }\n        else{\n            if(count>2){\n                var fitted =  Opt.optimizeSingleLorentzian(candidates,\n                    {x: broadLines[maxI].x, y:max, width: Math.abs(candidates[0][0]-candidates[candidates.length-1][0])});\n                //console.log(fitted)\n                peakList.push({x:fitted[0][0],y:fitted[1][0],width:fitted[2][0],soft:false});\n\n            }\n            else{\n                //Put back the candidates to the signals list\n                indexes.map(function(index){peakList.push(broadLines[index])});\n            }\n            candidates = [[broadLines[i].x,broadLines[i].y]];\n            indexes = [i];\n            max = broadLines[i].y;\n            maxI = i;\n            count = 1;\n        }\n    }\n\n    peakList.sort(function (a, b) {\n        return a.x - b.x;\n    });\n\n    return peakList;\n\n}\n\n/*if(options.broadRatio>0){\n var broadLines=[[Number.MAX_VALUE,0,0]];\n //Optimize the possible broad lines\n var max=0, maxI=0,count=0;\n var candidates = [],broadLinesS=[];\n var isPartOf = false;\n\n for(var i=broadLines.length-1;i>0;i--){\n //console.log(broadLines[i][0]+\" \"+rangeX+\" \"+Math.abs(broadLines[i-1][0]-broadLines[i][0]));\n if(Math.abs(broadLines[i-1][0]-broadLines[i][0])<rangeX){\n\n candidates.push(broadLines[i]);\n if(broadLines[i][1]>max){\n max = broadLines[i][1];\n maxI = i;\n }\n count++;\n }\n else{\n isPartOf = true;\n if(count>30){ // TODO, an options ?\n isPartOf = false;\n //for(var j=0;j<signals.length;j++){\n //    if(Math.abs(broadLines[maxI][0]-signals[j][0])<rangeX)\n //       isPartOf = true;\n //    }\n //console.log(\"Was part of \"+isPartOf);\n }\n if(isPartOf){\n for(var j=0;j<candidates.length;j++){\n signals.push([candidates[j][0], candidates[j][1], dx]);\n }\n }\n else{\n var fitted =  Opt.optimizeSingleLorentzian(candidates,{x:candidates[maxI][0],\n width:Math.abs(candidates[0][0]-candidates[candidates.length-1][0])},\n []);\n //console.log(fitted);\n signals.push([fitted[0][0],fitted[0][1],fitted[0][2]]);\n }\n candidates = [];\n max = 0;\n maxI = 0;\n count = 0;\n }\n }\n }*/\n\nmodule.exports={optimizePeaks:optimizePeaks,joinBroadPeaks:joinBroadPeaks};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-gsd/src/optimize.js\n ** module id = 13\n ** module chunks = 0\n **/","'use strict';\n\nvar LM = require('ml-curve-fitting');\nvar math = LM.Matrix.algebra;\nvar Matrix = require('ml-matrix');\n\n/**\n * This function calculates the spectrum as a sum of lorentzian functions. The Lorentzian\n * parameters are divided in 3 batches. 1st: centers; 2nd: heights; 3th: widths;\n * @param t Ordinate values\n * @param p Lorentzian parameters\n * @param c Constant parameters(Not used)\n * @returns {*}\n */\nfunction sumOfLorentzians(t,p,c){\n    var nL = p.length/3,factor,i, j,p2, cols = t.rows;\n    var result = Matrix.zeros(t.length,1);\n\n    for(i=0;i<nL;i++){\n        p2 = Math.pow(p[i+nL*2][0]/2,2);\n        factor = p[i+nL][0]*p2;\n        for(j=0;j<cols;j++){\n            result[j][0]+=factor/(Math.pow(t[j][0]-p[i][0],2)+p2);\n        }\n    }\n    return result;\n}\n\n/**\n * This function calculates the spectrum as a sum of gaussian functions. The Gaussian\n * parameters are divided in 3 batches. 1st: centers; 2nd: height; 3th: std's;\n * @param t Ordinate values\n * @param p Gaussian parameters\n * @param c Constant parameters(Not used)\n * @returns {*}\n */\nfunction sumOfGaussians(t,p,c){\n    var nL = p.length/3,factor,i, j, cols = t.rows;\n    var result = Matrix.zeros(t.length,1);\n\n    for(i=0;i<nL;i++){\n        factor = p[i+nL*2][0]*p[i+nL*2][0]/2;\n        for(j=0;j<cols;j++){\n            result[j][0]+=p[i+nL][0]*Math.exp(-(t[i][0]-p[i][0])*(t[i][0]-p[i][0])/factor);\n        }\n    }\n    return result;\n}\n/**\n * Single 4 parameter lorentzian function\n * @param t Ordinate values\n * @param p Lorentzian parameters\n * @param c Constant parameters(Not used)\n * @returns {*}\n */\nfunction singleLorentzian(t,p,c){\n    var factor = p[1][0]*Math.pow(p[2][0]/2,2);\n    var rows = t.rows;\n    var result = new Matrix(t.rows, t.columns);\n    for(var i=0;i<rows;i++){\n        result[i][0]=factor/(Math.pow(t[i][0]-p[0][0],2)+Math.pow(p[2][0]/2,2));\n    }\n    return result;\n}\n\n/**\n * Single 3 parameter gaussian function\n * @param t Ordinate values\n * @param p Gaussian parameters [mean, height, std]\n * @param c Constant parameters(Not used)\n * @returns {*}\n */\nfunction singleGaussian(t,p,c){\n    var factor2 = p[2][0]*p[2][0]/2;\n    var rows = t.rows;\n    var result = new Matrix(t.rows, t.columns);\n    for(var i=0;i<rows;i++){\n        result[i][0]=p[1][0]*Math.exp(-(t[i][0]-p[0][0])*(t[i][0]-p[0][0])/factor2);\n    }\n    return result;\n}\n\n/**\n * * Fits a set of points to a Lorentzian function. Returns the center of the peak, the width at half height, and the height of the signal.\n * @param data,[y]\n * @returns {*[]}\n */\nfunction optimizeSingleLorentzian(xy, peak, opts) {\n    var xy2 = parseData(xy);\n    var t = xy2[0];\n    var y_data = xy2[1];\n    var maxY = xy2[2];\n    var nbPoints = t.columns, i;\n\n    var weight = [nbPoints / Math.sqrt(y_data.dot(y_data))];\n\n    var opts=Object.create(opts || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ]);\n    //var opts = [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ];\n    var consts = [ ];\n    var dt = Math.abs(t[0][0]-t[1][0]);// optional vector of constants\n    var dx = new Matrix([[-dt/10000],[-1e-3],[-dt/10000]]);//-Math.abs(t[0][0]-t[1][0])/100;\n    var p_init = new Matrix([[peak.x],[1],[peak.width]]);\n    var p_min = new Matrix([[peak.x-dt],[0.75],[peak.width/4]]);\n    var p_max = new Matrix([[peak.x+dt],[1.25],[peak.width*4]]);\n\n    var p_fit = LM.optimize(singleLorentzian,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);\n\n\n    p_fit = p_fit.p;\n    return [p_fit[0],[p_fit[1][0]*maxY],p_fit[2]];\n\n}\n\n/**\n * Fits a set of points to a gaussian bell. Returns the mean of the peak, the std and the height of the signal.\n * @param data,[y]\n * @returns {*[]}\n */\nfunction optimizeSingleGaussian(xy, peak, opts) {\n    var xy2 = parseData(xy);\n    var t = xy2[0];\n    var y_data = xy2[1];\n    var maxY = xy2[2];\n\n    var nbPoints = t.columns, i;\n\n    var weight = [nbPoints / Math.sqrt(y_data.dot(y_data))];\n\n    var opts=Object.create(opts || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ]);\n    //var opts = [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ];\n    var consts = [ ];                         // optional vector of constants\n    var dt = Math.abs(t[0][0]-t[1][0]);\n    var dx = new Matrix([[-dt/10000],[-1e-3],[-dt/10000]]);//-Math.abs(t[0][0]-t[1][0])/100;\n\n    var dx = new Matrix([[-Math.abs(t[0][0]-t[1][0])/1000],[-1e-3],[-peak.width/1000]]);\n    var p_init = new Matrix([[peak.x],[1],[peak.width]]);\n    var p_min = new Matrix([[peak.x-dt],[0.75],[peak.width/4]]);\n    var p_max = new Matrix([[peak.x+dt],[1.25],[peak.width*4]]);\n    //var p_min = new Matrix([[peak.x-peak.width/4],[0.75],[peak.width/3]]);\n    //var p_max = new Matrix([[peak.x+peak.width/4],[1.25],[peak.width*3]]);\n\n    var p_fit = LM.optimize(singleGaussian,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);\n    p_fit = p_fit.p;\n    return [p_fit[0],[p_fit[1][0]*maxY],p_fit[2]];\n}\n\n\n/**\n *\n * @param xy A two column matrix containing the x and y data to be fitted\n * @param group A set of initial lorentzian parameters to be optimized [center, heigth, half_width_at_half_height]\n * @returns {Array} A set of final lorentzian parameters [center, heigth, hwhh*2]\n */\nfunction optimizeLorentzianSum(xy, group, opts){\n    var xy2 = parseData(xy);\n    var t = xy2[0];\n    var y_data = xy2[1];\n    var maxY = xy2[2];\n    var nbPoints = t.columns, i;\n\n    var weight = [nbPoints / math.sqrt(y_data.dot(y_data))];\n    var opts=Object.create(opts || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ]);\n    var consts = [ ];// optional vector of constants\n\n    var nL = group.length;\n    var p_init = new Matrix(nL*3,1);\n    var p_min =  new Matrix(nL*3,1);\n    var p_max =  new Matrix(nL*3,1);\n    var dx = new Matrix(nL*3,1);\n    var dt = Math.abs(t[0][0]-t[1][0]);\n    for( i=0;i<nL;i++){\n        p_init[i][0] = group[i].x;\n        p_init[i+nL][0] = 1;\n        p_init[i+2*nL][0] = group[i].width;\n\n        p_min[i][0] = group[i].x-dt;//-group[i].width/4;\n        p_min[i+nL][0] = 0;\n        p_min[i+2*nL][0] = group[i].width/4;\n\n        p_max[i][0] = group[i].x+dt;//+group[i].width/4;\n        p_max[i+nL][0] = 1.5;\n        p_max[i+2*nL][0] = group[i].width*4;\n\n        dx[i][0] = -dt/1000;\n        dx[i+nL][0] = -1e-3;\n        dx[i+2*nL][0] = -dt/1000;\n    }\n\n    var dx = -Math.abs(t[0][0]-t[1][0])/10000;\n    var p_fit = LM.optimize(sumOfLorentzians, p_init, t, y_data, weight, dx, p_min, p_max, consts, opts);\n    p_fit=p_fit.p;\n    //Put back the result in the correct format\n    var result = new Array(nL);\n    for( i=0;i<nL;i++){\n        result[i]=[p_fit[i],[p_fit[i+nL][0]*maxY],p_fit[i+2*nL]];\n    }\n\n    return result;\n\n}\n\n/**\n *\n * @param xy A two column matrix containing the x and y data to be fitted\n * @param group A set of initial lorentzian parameters to be optimized [center, heigth, half_width_at_half_height]\n * @returns {Array} A set of final lorentzian parameters [center, heigth, hwhh*2]\n */\nfunction optimizeGaussianSum(xy, group, opts){\n    var xy2 = parseData(xy);\n    var t = xy2[0];\n    var y_data = xy2[1];\n    var maxY = xy2[2];\n    var nbPoints = t.rows,i;\n\n    var weight = new Matrix(nbPoints,1);//[nbPoints / math.sqrt(y_data.dot(y_data))];\n    var k = nbPoints / math.sqrt(y_data.dot(y_data));\n    for(i=0;i<nbPoints;i++){\n        weight[i][0]=k;///(y_data[i][0]);\n        //weight[i][0]=k*(2-y_data[i][0]);\n    }\n\n    var opts=Object.create(opts || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        2 ]);\n    //var opts=[  3,    100, 1e-5, 1e-6, 1e-6, 1e-6, 1e-6,    11,    9,        1 ];\n    var consts = [ ];// optional vector of constants\n\n    var nL = group.length;\n    var p_init = new Matrix(nL*3,1);\n    var p_min =  new Matrix(nL*3,1);\n    var p_max =  new Matrix(nL*3,1);\n    var dx = new Matrix(nL*3,1);\n    var dt = Math.abs(t[0][0]-t[1][0]);\n    for( i=0;i<nL;i++){\n        p_init[i][0] = group[i].x;\n        p_init[i+nL][0] = group[i].y/maxY;\n        p_init[i+2*nL][0] = group[i].width;\n\n        p_min[i][0] = group[i].x-dt;\n        p_min[i+nL][0] = group[i].y*0.8/maxY;\n        p_min[i+2*nL][0] = group[i].width/2;\n\n        p_max[i][0] = group[i].x+dt;\n        p_max[i+nL][0] = group[i].y*1.2/maxY;\n        p_max[i+2*nL][0] = group[i].width*2;\n\n        dx[i][0] = -dt/1000;\n        dx[i+nL][0] = -1e-3;\n        dx[i+2*nL][0] = -dt/1000;\n    }\n    //console.log(t);\n    var p_fit = LM.optimize(sumOfLorentzians,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);\n    p_fit = p_fit.p;\n    //Put back the result in the correct format\n    var result = new Array(nL);\n    for( i=0;i<nL;i++){\n        result[i]=[p_fit[i],[p_fit[i+nL][0]*maxY],p_fit[i+2*nL]];\n    }\n\n    return result;\n\n}\n/**\n *\n * Converts the given input to the required x, y column matrices. y data is normalized to max(y)=1\n * @param xy\n * @returns {*[]}\n */\nfunction parseData(xy){\n    var nbSeries = xy.length;\n    var t = null;\n    var y_data = null, x,y;\n    var maxY = 0, i,j;\n\n    if(nbSeries==2){\n        //Looks like row wise matrix [x,y]\n        var nbPoints = xy[0].length;\n        if(nbPoints<3)\n            throw new SizeException(nbPoints);\n        else{\n            t = new Matrix(nbPoints,1);\n            y_data = new Matrix(nbPoints,1);\n            x = xy[0];\n            y = xy[1];\n            if(typeof x[0] === \"number\"){\n                for(i=0;i<nbPoints;i++){\n                    t[i][0]=x[i];\n                    y_data[i][0]=y[i];\n                    if(y[i]>maxY)\n                        maxY = y[i];\n                }\n            }\n            else{\n                //It is a colum matrix\n                if(typeof x[0] === \"object\"){\n                    for(i=0;i<nbPoints;i++){\n                        t[i][0]=x[i][0];\n                        y_data[i][0]=y[i][0];\n                        if(y[i][0]>maxY)\n                            maxY = y[i][0];\n                    }\n                }\n\n            }\n\n        }\n    }\n    else{\n        //Looks like a column wise matrix [[x],[y]]\n        var nbPoints = nbSeries;\n        if(nbPoints<3)\n            throw new SizeException(nbPoints);\n        else {\n            t = new Matrix(nbPoints, 1);\n            y_data = new Matrix(nbPoints, 1);\n            for (i = 0; i < nbPoints; i++) {\n                t[i][0] = xy[i][0];\n                y_data[i][0] = xy[i][1];\n                if(y_data[i][0]>maxY)\n                    maxY = y_data[i][0];\n            }\n        }\n    }\n    for (i = 0; i < nbPoints; i++) {\n        y_data[i][0]/=maxY;\n    }\n    return [t,y_data,maxY];\n}\n\nfunction sizeException(nbPoints) {\n    return new RangeError(\"Not enough points to perform the optimization: \"+nbPoints +\"< 3\");\n}\n\nmodule.exports.optimizeSingleLorentzian = optimizeSingleLorentzian;\nmodule.exports.optimizeLorentzianSum = optimizeLorentzianSum;\nmodule.exports.optimizeSingleGaussian = optimizeSingleGaussian;\nmodule.exports.optimizeGaussianSum = optimizeGaussianSum;\nmodule.exports.singleGaussian = singleGaussian;\nmodule.exports.singleLorentzian = singleLorentzian;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-optimize-lorentzian/src/index.js\n ** module id = 14\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = require('./LM');\nmodule.exports.Matrix = require('ml-matrix');\nmodule.exports.Matrix.algebra = require('./algebra');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-curve-fitting/src/index.js\n ** module id = 15\n ** module chunks = 0\n **/","/**\n * Created by acastillo on 8/5/15.\n */\nvar Matrix = require(\"ml-matrix\");\nvar math = require(\"./algebra\");\n\nvar DEBUG = false;\n/** Levenberg Marquardt curve-fitting: minimize sum of weighted squared residuals\n ----------  INPUT  VARIABLES  -----------\n func   = function of n independent variables, 't', and m parameters, 'p',\n returning the simulated model: y_hat = func(t,p,c)\n p      = n-vector of initial guess of parameter values\n t      = m-vectors or matrix of independent variables (used as arg to func)\n y_dat  = m-vectors or matrix of data to be fit by func(t,p)\n weight = weighting vector for least squares fit ( weight >= 0 ) ...\n inverse of the standard measurement errors\n Default:  sqrt(d.o.f. / ( y_dat' * y_dat ))\n dp     = fractional increment of 'p' for numerical derivatives\n dp(j)>0 central differences calculated\n dp(j)<0 one sided 'backwards' differences calculated\n dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n Default:  0.001;\n p_min  = n-vector of lower bounds for parameter values\n p_max  = n-vector of upper bounds for parameter values\n c      = an optional matrix of values passed to func(t,p,c)\n opts   = vector of algorithmic parameters\n parameter    defaults    meaning\n opts(1)  =  prnt            3        >1 intermediate results; >2 plots\n opts(2)  =  MaxIter      10*Npar     maximum number of iterations\n opts(3)  =  epsilon_1       1e-3     convergence tolerance for gradient\n opts(4)  =  epsilon_2       1e-3     convergence tolerance for parameters\n opts(5)  =  epsilon_3       1e-3     convergence tolerance for Chi-square\n opts(6)  =  epsilon_4       1e-2     determines acceptance of a L-M step\n opts(7)  =  lambda_0        1e-2     initial value of L-M paramter\n opts(8)  =  lambda_UP_fac   11       factor for increasing lambda\n opts(9)  =  lambda_DN_fac    9       factor for decreasing lambda\n opts(10) =  Update_Type      1       1: Levenberg-Marquardt lambda update\n 2: Quadratic update\n 3: Nielsen's lambda update equations\n\n ----------  OUTPUT  VARIABLES  -----------\n p       = least-squares optimal estimate of the parameter values\n X2      = Chi squared criteria\n sigma_p = asymptotic standard error of the parameters\n sigma_y = asymptotic standard error of the curve-fit\n corr    = correlation matrix of the parameters\n R_sq    = R-squared cofficient of multiple determination\n cvg_hst = convergence history\n\n Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. 22 Sep 2013\n modified from: http://octave.sourceforge.net/optim/function/leasqr.html\n using references by\n Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n Sam Roweis       http://www.cs.toronto.edu/~roweis/notes/lm.pdf\n Manolis Lourakis http://www.ics.forth.gr/~lourakis/levmar/levmar.pdf\n Hans Nielson     http://www2.imm.dtu.dk/~hbn/publ/TR9905.ps\n Mathworks        optimization toolbox reference manual\n K. Madsen, H.B., Nielsen, and O. Tingleff\n http://www2.imm.dtu.dk/pubdb/views/edoc_download.php/3215/pdf/imm3215.pdf\n */\nvar LM = {\n\n    optimize: function(func,p,t,y_dat,weight,dp,p_min,p_max,c,opts){\n\n        var tensor_parameter = 0;\t\t\t// set to 1 of parameter is a tensor\n\n        var iteration  = 0;\t\t\t// iteration counter\n        //func_calls = 0;\t\t\t// running count of function evaluations\n\n        if((typeof p[0])!=\"object\"){\n            for(var i=0;i< p.length;i++){\n                p[i]=[p[i]];\n            }\n\n        }\n        //p = p(:); y_dat = y_dat(:);\t\t// make column vectors\n        var i,k;\n        var eps = 2^-52;\n        var Npar   = p.length;//length(p); \t\t\t// number of parameters\n        var Npnt   = y_dat.length;//length(y_dat);\t\t// number of data points\n        var p_old  = Matrix.zeros(Npar,1);\t\t// previous set of parameters\n        var y_old  = Matrix.zeros(Npnt,1);\t\t// previous model, y_old = y_hat(t;p_old)\n        var X2     = 1e-2/eps;\t\t\t// a really big initial Chi-sq value\n        var X2_old = 1e-2/eps;\t\t\t// a really big initial Chi-sq value\n        var J =  Matrix.zeros(Npnt,Npar);\n\n\n        if (t.length != y_dat.length) {\n            console.log('lm.m error: the length of t must equal the length of y_dat');\n\n            length_t = t.length;\n            length_y_dat = y_dat.length;\n            var X2 = 0, corr = 0, sigma_p = 0, sigma_y = 0, R_sq = 0, cvg_hist = 0;\n            if (!tensor_parameter) {\n                return;\n            }\n        }\n\n        weight = weight||Math.sqrt((Npnt-Npar+1)/(math.multiply(math.transpose(y_dat),y_dat)));\n        dp = dp || 0.001;\n        p_min   = p_min || math.multiply(Math.abs(p),-100);\n        p_max   = p_max || math.multiply(Math.abs(p),100);\n        c = c || 1;\n        // Algorithmic Paramters\n        //prnt MaxIter  eps1  eps2  epx3  eps4  lam0  lamUP lamDN UpdateType\n        opts = opts ||[  3,10*Npar, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2, 11, 9, 1 ];\n\n        var prnt          = opts[0];\t// >1 intermediate results; >2 plots\n        var MaxIter       = opts[1];\t// maximum number of iterations\n        var epsilon_1     = opts[2];\t// convergence tolerance for gradient\n        var epsilon_2     = opts[3];\t// convergence tolerance for parameter\n        var epsilon_3     = opts[4];\t// convergence tolerance for Chi-square\n        var epsilon_4     = opts[5];\t// determines acceptance of a L-M step\n        var lambda_0      = opts[6];\t// initial value of damping paramter, lambda\n        var lambda_UP_fac = opts[7];\t// factor for increasing lambda\n        var lambda_DN_fac = opts[8];\t// factor for decreasing lambda\n        var Update_Type   = opts[9];\t// 1: Levenberg-Marquardt lambda update\n        // 2: Quadratic update\n        // 3: Nielsen's lambda update equations\n\n        if ( tensor_parameter && prnt == 3 ) prnt = 2;\n\n\n        if(!dp.length || dp.length == 1){\n            var dp_array = new Array(Npar);\n            for(var i=0;i<Npar;i++)\n                dp_array[i]=[dp];\n            dp=dp_array;\n        }\n\n        // indices of the parameters to be fit\n        var idx   = [];\n        for(i=0;i<dp.length;i++){\n            if(dp[i][0]!=0){\n                idx.push(i);\n            }\n        }\n\n        var Nfit = idx.length;\t\t\t// number of parameters to fit\n        var stop = false;\t\t\t\t// termination flag\n\n        var weight_sq = null;\n        //console.log(weight);\n        if ( !weight.length || weight.length < Npnt )\t{\n            // squared weighting vector\n            //weight_sq = ( weight(1)*ones(Npnt,1) ).^2;\n            //console.log(\"weight[0] \"+typeof weight[0]);\n            var tmp = math.multiply(Matrix.ones(Npnt,1),weight[0]);\n            weight_sq = math.dotMultiply(tmp,tmp);\n        }\n        else{\n            //weight_sq = (weight(:)).^2;\n            weight_sq = math.dotMultiply(weight,weight);\n        }\n\n\n        // initialize Jacobian with finite difference calculation\n        //console.log(\"J \"+weight_sq);\n        var result = this.lm_matx(func,t,p_old,y_old,1,J,p,y_dat,weight_sq,dp,c);\n        var JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n        //[JtWJ,JtWdy,X2,y_hat,J] = this.lm_matx(func,t,p_old,y_old,1,J,p,y_dat,weight_sq,dp,c);\n        //console.log(JtWJ);\n\n        if ( Math.max(Math.abs(JtWdy)) < epsilon_1 ){\n            console.log(' *** Your Initial Guess is Extremely Close to Optimal ***')\n            console.log(' *** epsilon_1 = ', epsilon_1);\n            stop = true;\n        }\n\n\n        switch(Update_Type){\n            case 1: // Marquardt: init'l lambda\n                lambda  = lambda_0;\n                break;\n            default:    // Quadratic and Nielsen\n                lambda  = lambda_0 * Math.max(math.diag(JtWJ));\n                nu=2;\n        }\n        //console.log(X2);\n        X2_old = X2; // previous value of X2\n        //console.log(MaxIter+\" \"+Npar);\n        //var cvg_hst = Matrix.ones(MaxIter,Npar+3);\t\t// initialize convergence history\n        var h = null;\n        while ( !stop && iteration <= MaxIter ) {\t\t// --- Main Loop\n            iteration = iteration + 1;\n            // incremental change in parameters\n            switch(Update_Type){\n                case 1:\t\t\t\t\t// Marquardt\n                    //h = ( JtWJ + lambda * math.diag(math.diag(JtWJ)) ) \\ JtWdy;\n                    //h = math.multiply(math.inv(JtWdy),math.add(JtWJ,math.multiply(lambda,math.diag(math.diag(Npar)))));\n                    h = math.solve(math.add(JtWJ,math.multiply(math.diag(math.diag(JtWJ)),lambda)),JtWdy);\n                    break;\n                default:\t\t\t\t\t// Quadratic and Nielsen\n                    //h = ( JtWJ + lambda * math.eye(Npar) ) \\ JtWdy;\n\n                    h = math.solve(math.add(JtWJ,math.multiply( Matrix.eye(Npar),lambda)),JtWdy);\n            }\n\n            /*for(var k=0;k< h.length;k++){\n             h[k]=[h[k]];\n             }*/\n            //console.log(\"h \"+h);\n            //h=math.matrix(h);\n            //  big = max(abs(h./p)) > 2;\n            //this is a big step\n            // --- Are parameters [p+h] much better than [p] ?\n            var hidx = new Array(idx.length);\n            for(k=0;k<idx.length;k++){\n                hidx[k]=h[idx[k]];\n            }\n            var p_try = math.add(p, hidx);// update the [idx] elements\n\n            for(k=0;k<p_try.length;k++){\n                p_try[k][0]=Math.min(Math.max(p_min[k][0],p_try[k][0]),p_max[k][0]);\n            }\n            // p_try = Math.min(Math.max(p_min,p_try),p_max);           // apply constraints\n\n            var delta_y = math.subtract(y_dat, func(t,p_try,c));       // residual error using p_try\n            //func_calls = func_calls + 1;\n            //X2_try = delta_y' * ( delta_y .* weight_sq );  // Chi-squared error criteria\n\n            var X2_try = math.multiply(math.transpose(delta_y),math.dotMultiply(delta_y,weight_sq));\n\n            if ( Update_Type == 2 ){  \t\t\t  // Quadratic\n                //    One step of quadratic line update in the h direction for minimum X2\n                //var alpha =  JtWdy'*h / ( (X2_try - X2)/2 + 2*JtWdy'*h ) ;\n                var JtWdy_th = math.multiply(math.transpose(JtWdy),h);\n                var alpha =  math.multiply(JtWdy_th,math.inv(math.add(math.multiply(math.subtract(X2_try - X2),1/2)),math.multiply(JtWdy_th,2)));//JtWdy'*h / ( (X2_try - X2)/2 + 2*JtWdy'*h ) ;\n\n                h = math.multiply(alpha, h);\n                for(var k=0;k<idx.length;k++){\n                    hidx[k]=h[idx[k]];\n                }\n\n                p_try = math.add(p ,hidx);                     // update only [idx] elements\n                p_try = math.min(math.max(p_min,p_try),p_max);          // apply constraints\n\n                delta_y = math.subtract(y_dat, func(t,p_try,c));      // residual error using p_try\n                // func_calls = func_calls + 1;\n                //X2_try = delta_y' * ( delta_y .* weight_sq ); // Chi-squared error criteria\n                X2_try = math.multiply(math.transpose(delta_y), mat.dotMultiply(delta_y, weight_sq));\n            }\n\n            //rho = (X2 - X2_try) / ( 2*h' * (lambda * h + JtWdy) ); // Nielsen\n            var rho = (X2-X2_try)/math.multiply(math.multiply(math.transpose(h),2),math.add(math.multiply(lambda, h),JtWdy));\n            //console.log(\"rho \"+rho);\n            if ( rho > epsilon_4 ) {\t\t// it IS significantly better\n                //console.log(\"Here\");\n                dX2 = X2 - X2_old;\n                X2_old = X2;\n                p_old = p;\n                y_old = y_hat;\n                p = p_try;\t\t\t// accept p_try\n\n                result = this.lm_matx(func, t, p_old, y_old, dX2, J, p, y_dat, weight_sq, dp, c);\n                JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n                // decrease lambda ==> Gauss-Newton method\n\n                switch (Update_Type) {\n                    case 1:\t\t\t\t\t\t\t// Levenberg\n                        lambda = Math.max(lambda / lambda_DN_fac, 1.e-7);\n                        break;\n                    case 2:\t\t\t\t\t\t\t// Quadratic\n                        lambda = Math.max(lambda / (1 + alpha), 1.e-7);\n                        break;\n                    case 3:\t\t\t\t\t\t\t// Nielsen\n                        lambda = math.multiply(Math.max(1 / 3, 1 - (2 * rho - 1) ^ 3),lambda);\n                        nu = 2;\n                        break;\n                }\n            }\n            else {\t\t\t\t\t// it IS NOT better\n                X2 = X2_old;\t\t\t// do not accept p_try\n                if (iteration%(2 * Npar)==0) {\t// rank-1 update of Jacobian\n                    result = this.lm_matx(func, t, p_old, y_old, -1, J, p, y_dat, weight_sq, dp, c);\n                    JtWJ = result.JtWJ,JtWdy=result.JtWdy,dX2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n                }\n\n                // increase lambda  ==> gradient descent method\n                switch (Update_Type) {\n                    case 1:\t\t\t\t\t\t\t// Levenberg\n                        lambda = Math.min(lambda * lambda_UP_fac, 1.e7);\n                        break;\n                    case 2:\t\t\t\t\t\t\t// Quadratic\n                        lambda = lambda + Math.abs((X2_try - X2) / 2 / alpha);\n                        break;\n                    case 3:\t\t\t\t\t\t// Nielsen\n                        lambda = lambda * nu;\n                        nu = 2 * nu;\n                        break;\n                }\n            }\n        }// --- End of Main Loop\n\n        // --- convergence achieved, find covariance and confidence intervals\n\n        // equal weights for paramter error analysis\n        weight_sq = math.multiply(math.multiply(math.transpose(delta_y),delta_y), Matrix.ones(Npnt,1));\n\n        weight_sq.apply(function(i,j){\n            weight_sq[i][j] = (Npnt-Nfit+1)/weight_sq[i][j];\n        });\n        //console.log(weight_sq);\n        result = this.lm_matx(func,t,p_old,y_old,-1,J,p,y_dat,weight_sq,dp,c);\n        JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n\n        /*if nargout > 2\t\t\t\t// standard error of parameters\n         covar = inv(JtWJ);\n         sigma_p = sqrt(diag(covar));\n         end\n\n         if nargout > 3\t\t\t\t// standard error of the fit\n         //  sigma_y = sqrt(diag(J * covar * J'));\t// slower version of below\n         sigma_y = zeros(Npnt,1);\n         for i=1:Npnt\n         sigma_y(i) = J(i,:) * covar * J(i,:)';\n         end\n         sigma_y = sqrt(sigma_y);\n         end\n\n         if nargout > 4\t\t\t\t// parameter correlation matrix\n         corr = covar ./ [sigma_p*sigma_p'];\n         end\n\n         if nargout > 5\t\t\t\t// coefficient of multiple determination\n         R_sq = corrcoef([y_dat y_hat]);\n         R_sq = R_sq(1,2).^2;\n         end\n\n         if nargout > 6\t\t\t\t// convergence history\n         cvg_hst = cvg_hst(1:iteration,:);\n         end*/\n\n        // endfunction  # ---------------------------------------------------------- LM\n\n        return { p:p, X2:X2};\n    },\n\n    lm_FD_J:function(func,t,p,y,dp,c) {\n        // J = lm_FD_J(func,t,p,y,{dp},{c})\n        //\n        // partial derivatives (Jacobian) dy/dp for use with lm.m\n        // computed via Finite Differences\n        // Requires n or 2n function evaluations, n = number of nonzero values of dp\n        // -------- INPUT VARIABLES ---------\n        // func = function of independent variables, 't', and parameters, 'p',\n        //        returning the simulated model: y_hat = func(t,p,c)\n        // t  = m-vector of independent variables (used as arg to func)\n        // p  = n-vector of current parameter values\n        // y  = func(t,p,c) n-vector initialised by user before each call to lm_FD_J\n        // dp = fractional increment of p for numerical derivatives\n        //      dp(j)>0 central differences calculated\n        //      dp(j)<0 one sided differences calculated\n        //      dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n        //      Default:  0.001;\n        // c  = optional vector of constants passed to y_hat = func(t,p,c)\n        //---------- OUTPUT VARIABLES -------\n        // J  = Jacobian Matrix J(i,j)=dy(i)/dp(j)\ti=1:n; j=1:m\n\n        //   Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. November 2005\n        //   modified from: ftp://fly.cnuce.cnr.it/pub/software/octave/leasqr/\n        //   Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\n        var m = y.length;\t\t\t// number of data points\n        var n = p.length;\t\t\t// number of parameters\n\n        dp = dp || math.multiply( Matrix.ones(n, 1), 0.001);\n\n        var ps = p.clone();//JSON.parse(JSON.stringify(p));\n        //var ps = $.extend(true, [], p);\n        var J = new Matrix(m,n), del =new Array(n);         // initialize Jacobian to Zero\n\n        for (var j = 0;j < n; j++) {\n            //console.log(j+\" \"+dp[j]+\" \"+p[j]+\" \"+ps[j]+\" \"+del[j]);\n            del[j] = dp[j]*(1+Math.abs(p[j][0]));  // parameter perturbation\n            p[j] = [ps[j][0]+del[j]];\t      // perturb parameter p(j)\n            //console.log(j+\" \"+dp[j]+\" \"+p[j]+\" \"+ps[j]+\" \"+del[j]);\n\n            if (del[j] != 0){\n                y1 = func(t, p, c);\n                //func_calls = func_calls + 1;\n                if (dp[j][0] < 0) {\t\t// backwards difference\n                    //J(:,j) = math.dotDivide(math.subtract(y1, y),del[j]);//. / del[j];\n                    //console.log(del[j]);\n                    //console.log(y);\n                    var column = math.dotDivide(math.subtract(y1, y),del[j]);\n                    for(var k=0;k< m;k++){\n                        J[k][j]=column[k][0];\n                    }\n                    //console.log(column);\n                }\n                else{\n                    p[j][0] = ps[j][0] - del[j];\n                    //J(:,j) = (y1 - feval(func, t, p, c)). / (2. * del[j]);\n                    var column = math.dotDivide(math.subtract(y1,func(t,p,c)),2*del[j]);\n                    for(var k=0;k< m;k++){\n                        J[k][j]=column[k][0];\n                    }\n\n                }\t\t\t// central difference, additional func call\n            }\n\n            p[j] = ps[j];\t\t// restore p(j)\n\n        }\n        //console.log(\"lm_FD_J: \"+ JSON.stringify(J));\n        return J;\n\n    },\n\n    // endfunction # -------------------------------------------------- LM_FD_J\n    lm_Broyden_J: function(p_old,y_old,J,p,y){\n        // J = lm_Broyden_J(p_old,y_old,J,p,y)\n        // carry out a rank-1 update to the Jacobian matrix using Broyden's equation\n        //---------- INPUT VARIABLES -------\n        // p_old = previous set of parameters\n        // y_old = model evaluation at previous set of parameters, y_hat(t;p_old)\n        // J  = current version of the Jacobian matrix\n        // p     = current  set of parameters\n        // y     = model evaluation at current  set of parameters, y_hat(t;p)\n        //---------- OUTPUT VARIABLES -------\n        // J = rank-1 update to Jacobian Matrix J(i,j)=dy(i)/dp(j)\ti=1:n; j=1:m\n        //console.log(p+\" X \"+ p_old)\n        var h  = math.subtract(p, p_old);\n\n        //console.log(\"hhh \"+h);\n        var h_t = math.transpose(h);\n        h_t.div(math.multiply(h_t,h));\n\n        //console.log(h_t);\n        //J = J + ( y - y_old - J*h )*h' / (h'*h);\t// Broyden rank-1 update eq'n\n        J = math.add(J, math.multiply(math.subtract(y, math.add(y_old,math.multiply(J,h))),h_t));\n        return J;\n        // endfunction # ---------------------------------------------- LM_Broyden_J\n    },\n\n    lm_matx : function (func,t,p_old,y_old,dX2,J,p,y_dat,weight_sq,dp,c,iteration){\n        // [JtWJ,JtWdy,Chi_sq,y_hat,J] = this.lm_matx(func,t,p_old,y_old,dX2,J,p,y_dat,weight_sq,{da},{c})\n        //\n        // Evaluate the linearized fitting matrix, JtWJ, and vector JtWdy,\n        // and calculate the Chi-squared error function, Chi_sq\n        // Used by Levenberg-Marquard algorithm, lm.m\n        // -------- INPUT VARIABLES ---------\n        // func   = function ofpn independent variables, p, and m parameters, p,\n        //         returning the simulated model: y_hat = func(t,p,c)\n        // t      = m-vectors or matrix of independent variables (used as arg to func)\n        // p_old  = n-vector of previous parameter values\n        // y_old  = m-vector of previous model ... y_old = y_hat(t;p_old);\n        // dX2    = previous change in Chi-squared criteria\n        // J   = m-by-n Jacobian of model, y_hat, with respect to parameters, p\n        // p      = n-vector of current  parameter values\n        // y_dat  = n-vector of data to be fit by func(t,p,c)\n        // weight_sq = square of the weighting vector for least squares fit ...\n        //\t    inverse of the standard measurement errors\n        // dp     = fractional increment of 'p' for numerical derivatives\n        //          dp(j)>0 central differences calculated\n        //          dp(j)<0 one sided differences calculated\n        //          dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n        //          Default:  0.001;\n        // c      = optional vector of constants passed to y_hat = func(t,p,c)\n        //---------- OUTPUT VARIABLES -------\n        // JtWJ\t = linearized Hessian matrix (inverse of covariance matrix)\n        // JtWdy   = linearized fitting vector\n        // Chi_sq = Chi-squared criteria: weighted sum of the squared residuals WSSR\n        // y_hat  = model evaluated with parameters 'p'\n        // J   = m-by-n Jacobian of model, y_hat, with respect to parameters, p\n\n        //   Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. November 2005\n        //   modified from: ftp://fly.cnuce.cnr.it/pub/software/octave/leasqr/\n        //   Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\n\n        var Npnt = y_dat.length;\t\t// number of data points\n        var Npar = p.length;\t\t// number of parameters\n\n        dp = dp || 0.001;\n\n\n        //var JtWJ = new Matrix.zeros(Npar);\n        //var JtWdy  = new Matrix.zeros(Npar,1);\n\n        var y_hat = func(t,p,c);\t// evaluate model using parameters 'p'\n        //func_calls = func_calls + 1;\n        //console.log(J);\n        if ( (iteration%(2*Npar))==0 || dX2 > 0 ) {\n            //console.log(\"Par\");\n            J = this.lm_FD_J(func, t, p, y_hat, dp, c);\t\t// finite difference\n        }\n        else{\n            //console.log(\"ImPar\");\n            J = this.lm_Broyden_J(p_old, y_old, J, p, y_hat); // rank-1 update\n        }\n        var delta_y = math.subtract(y_dat, y_hat);\t// residual error between model and data\n        //console.log(delta_y[0][0]);\n        //console.log(delta_y.rows+\" \"+delta_y.columns+\" \"+JSON.stringify(weight_sq));\n        //var Chi_sq = delta_y' * ( delta_y .* weight_sq ); \t// Chi-squared error criteria\n        var Chi_sq = math.multiply(math.transpose(delta_y),math.dotMultiply(delta_y,weight_sq));\n        //JtWJ  = J' * ( J .* ( weight_sq * ones(1,Npar) ) );\n        var Jt = math.transpose(J);\n\n        //console.log(weight_sq);\n\n        var JtWJ = math.multiply(Jt, math.dotMultiply(J,math.multiply(weight_sq, Matrix.ones(1,Npar))));\n\n        //JtWdy = J' * ( weight_sq .* delta_y );\n        var JtWdy = math.multiply(Jt, math.dotMultiply(weight_sq,delta_y));\n\n\n        return {JtWJ:JtWJ,JtWdy:JtWdy,Chi_sq:Chi_sq,y_hat:y_hat,J:J};\n        // endfunction  # ------------------------------------------------------ LM_MATX\n    }\n\n\n\n};\n\nmodule.exports = LM;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-curve-fitting/src/LM.js\n ** module id = 16\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = require('./matrix');\nmodule.exports.Decompositions = module.exports.DC = require('./decompositions');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-curve-fitting/~/ml-matrix/src/index.js\n ** module id = 17\n ** module chunks = 0\n **/","'use strict';\n\nvar Asplice = Array.prototype.splice,\n    Aconcat = Array.prototype.concat;\n\n// For performance : http://jsperf.com/clone-array-slice-vs-while-vs-for\nfunction slice(arr) {\n    var i = 0,\n        ii = arr.length,\n        result = new Array(ii);\n    for (; i < ii; i++) {\n        result[i] = arr[i];\n    }\n    return result;\n}\n\n/**\n * Real matrix.\n * @constructor\n * @param {number|Array} nRows - Number of rows of the new matrix or a 2D array containing the data.\n * @param {number|boolean} [nColumns] - Number of columns of the new matrix or a boolean specifying if the input array should be cloned\n */\nfunction Matrix(nRows, nColumns) {\n    var i = 0, rows, columns, matrix, newInstance;\n    if (Array.isArray(nRows)) {\n        newInstance = nColumns;\n        matrix = newInstance ? slice(nRows) : nRows;\n        nRows = matrix.length;\n        nColumns = matrix[0].length;\n        if (typeof nColumns === 'undefined') {\n            throw new TypeError('Data must be a 2D array');\n        }\n        if (nRows > 0 && nColumns > 0) {\n            for (; i < nRows; i++) {\n                if (matrix[i].length !== nColumns) {\n                    throw new RangeError('Inconsistent array dimensions');\n                } else if (newInstance) {\n                    matrix[i] = slice(matrix[i]);\n                }\n            }\n        } else {\n            throw new RangeError('Invalid dimensions: ' + nRows + 'x' + nColumns);\n        }\n    } else if (typeof nRows === 'number') { // Create empty matrix\n        if (nRows > 0 && nColumns > 0) {\n            matrix = new Array(nRows);\n            for (; i < nRows; i++) {\n                matrix[i] = new Array(nColumns);\n            }\n        } else {\n            throw new RangeError('Invalid dimensions: ' + nRows + 'x' + nColumns);\n        }\n    } else {\n        throw new TypeError('Invalid arguments');\n    }\n\n    Object.defineProperty(matrix, 'rows', {writable: true, value: nRows});\n    Object.defineProperty(matrix, 'columns', {writable: true, value: nColumns});\n\n    matrix.__proto__ = Matrix.prototype;\n\n    return matrix;\n}\n\n/**\n * Constructs a Matrix with the chosen dimensions from a 1D array.\n * @param {number} newRows - Number of rows\n * @param {number} newColumns - Number of columns\n * @param {Array} newData - A 1D array containing data for the matrix\n * @returns {Matrix} - The new matrix\n */\nMatrix.from1DArray = function from1DArray(newRows, newColumns, newData) {\n    var length, data, i = 0;\n\n    length = newRows * newColumns;\n    if (length !== newData.length)\n        throw new RangeError('Data length does not match given dimensions');\n\n    data = new Array(newRows);\n    for (; i < newRows; i++) {\n        data[i] = newData.slice(i * newColumns, (i + 1) * newColumns);\n    }\n    return new Matrix(data);\n};\n\n/**\n * Creates a row vector, a matrix with only one row.\n * @param {Array} newData - A 1D array containing data for the vector\n * @returns {Matrix} - The new matrix\n */\nMatrix.rowVector = function rowVector(newData) {\n    return new Matrix([newData]);\n};\n\n/**\n * Creates a column vector, a matrix with only one column.\n * @param {Array} newData - A 1D array containing data for the vector\n * @returns {Matrix} - The new matrix\n */\nMatrix.columnVector = function columnVector(newData) {\n    var l = newData.length, vector = new Array(l);\n    for (var i = 0; i < l; i++)\n        vector[i] = [newData[i]];\n    return new Matrix(vector);\n};\n\n/**\n * Creates an empty matrix with the given dimensions. Values will be undefined. Same as using new Matrix(rows, columns).\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.empty = function empty(rows, columns) {\n    return new Matrix(rows, columns);\n};\n\n/**\n * Creates a matrix with the given dimensions. Values will be set to zero.\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.zeros = function zeros(rows, columns) {\n    return Matrix.empty(rows, columns).fill(0);\n};\n\n/**\n * Creates a matrix with the given dimensions. Values will be set to one.\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.ones = function ones(rows, columns) {\n    return Matrix.empty(rows, columns).fill(1);\n};\n\n/**\n * Creates a matrix with the given dimensions. Values will be randomly set using Math.random().\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} The new matrix\n */\nMatrix.rand = function rand(rows, columns) {\n    var matrix = Matrix.empty(rows, columns);\n    for (var i = 0, ii = matrix.rows; i < ii; i++) {\n        for (var j = 0, jj = matrix.columns; j < jj; j++) {\n            matrix[i][j] = Math.random();\n        }\n    }\n    return matrix;\n};\n\n/**\n * Creates an identity matrix with the given dimension. Values of the diagonal will be 1 and other will be 0.\n * @param {number} n - Number of rows and columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.eye = function eye(n) {\n    var matrix = Matrix.zeros(n, n), l = matrix.rows;\n    for (var i = 0; i < l; i++) {\n        matrix[i][i] = 1;\n    }\n    return matrix;\n};\n\n/**\n * Creates a diagonal matrix based on the given array.\n * @param {Array} data - Array containing the data for the diagonal\n * @returns {Matrix} - The new matrix\n */\nMatrix.diag = function diag(data) {\n    var l = data.length, matrix = Matrix.zeros(l, l);\n    for (var i = 0; i < l; i++) {\n        matrix[i][i] = data[i];\n    }\n    return matrix;\n};\n\n/**\n * Creates an array of indices between two values\n * @param {number} from\n * @param {number} to\n * @returns {Array}\n */\nMatrix.indices = function indices(from, to) {\n    var vector = new Array(to - from);\n    for (var i = 0; i < vector.length; i++)\n        vector[i] = from++;\n    return vector;\n};\n\n// TODO DOC\nMatrix.stack = function stack(arg1) {\n    var i, j, k;\n    if (Matrix.isMatrix(arg1)) {\n        var rows = 0,\n            cols = 0;\n        for (i = 0; i < arguments.length; i++) {\n            rows += arguments[i].rows;\n            if (arguments[i].columns > cols)\n                cols = arguments[i].columns;\n        }\n\n        var r = Matrix.zeros(rows, cols);\n        var c = 0;\n        for (i = 0; i < arguments.length; i++) {\n            var current = arguments[i];\n            for (j = 0; j < current.rows; j++) {\n                for (k = 0; k < current.columns; k++)\n                    r[c][k] = current[j][k];\n                c++;\n            }\n        }\n        return r;\n    }\n    else if (Array.isArray(arg1)) {\n        var matrix = Matrix.empty(arguments.length, arg1.length);\n        for (i = 0; i < arguments.length; i++)\n            matrix.setRow(i, arguments[i]);\n        return matrix;\n    }\n};\n\n// TODO DOC\nMatrix.expand = function expand(base, count) {\n    var expansion = [];\n    for (var i = 0; i < count.length; i++)\n        for (var j = 0; j < count[i]; j++)\n            expansion.push(base[i]);\n    return new Matrix(expansion);\n};\n\n/**\n * Check that the provided value is a Matrix and tries to instantiate one if not\n * @param value - The value to check\n * @returns {Matrix}\n * @throws {TypeError}\n */\nMatrix.checkMatrix = function checkMatrix(value) {\n    if (!value) {\n        throw new TypeError('Argument has to be a matrix');\n    }\n    if (value.klass !== 'Matrix') {\n        value = new Matrix(value);\n    }\n    return value;\n};\n\n/**\n * Returns true if the argument is a Matrix, false otherwise\n * @param value - The value to check\n * @returns {boolean}\n */\nMatrix.isMatrix = function isMatrix(value) {\n    return value ? value.klass === 'Matrix' : false;\n};\n\n/**\n * @property {string} - The name of this class.\n */\nObject.defineProperty(Matrix.prototype, 'klass', {\n    get: function klass() {\n        return 'Matrix';\n    }\n});\n\n/**\n * @property {number} - The number of elements in the matrix.\n */\nObject.defineProperty(Matrix.prototype, 'size', {\n    get: function size() {\n        return this.rows * this.columns;\n    }\n});\n\n/**\n * @private\n * Internal check that a row index is not out of bounds\n * @param {number} index\n */\nMatrix.prototype.checkRowIndex = function checkRowIndex(index) {\n    if (index < 0 || index > this.rows - 1)\n        throw new RangeError('Row index out of range.');\n};\n\n/**\n * @private\n * Internal check that a column index is not out of bounds\n * @param {number} index\n */\nMatrix.prototype.checkColumnIndex = function checkColumnIndex(index) {\n    if (index < 0 || index > this.columns - 1)\n        throw new RangeError('Column index out of range.');\n};\n\n/**\n * @private\n * Internal check that two matrices have the same dimensions\n * @param {Matrix} otherMatrix\n */\nMatrix.prototype.checkDimensions = function checkDimensions(otherMatrix) {\n    if ((this.rows !== otherMatrix.rows) || (this.columns !== otherMatrix.columns))\n        throw new RangeError('Matrices dimensions must be equal.');\n};\n\n/**\n * Applies a callback for each element of the matrix. The function is called in the matrix (this) context.\n * @param {function} callback - Function that will be called with two parameters : i (row) and j (column)\n * @returns {Matrix} this\n */\nMatrix.prototype.apply = function apply(callback) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            callback.call(this, i, j);\n        }\n    }\n    return this;\n};\n\n/**\n * Creates an exact and independent copy of the matrix\n * @returns {Matrix}\n */\nMatrix.prototype.clone = function clone() {\n    return new Matrix(this.to2DArray());\n};\n\n/**\n * Returns a new 1D array filled row by row with the matrix values\n * @returns {Array}\n */\nMatrix.prototype.to1DArray = function to1DArray() {\n    return Aconcat.apply([], this);\n};\n\n/**\n * Returns a 2D array containing a copy of the data\n * @returns {Array}\n */\nMatrix.prototype.to2DArray = function to2DArray() {\n    var l = this.rows, copy = new Array(l);\n    for (var i = 0; i < l; i++) {\n        copy[i] = slice(this[i]);\n    }\n    return copy;\n};\n\n/**\n * @returns {boolean} true if the matrix has one row\n */\nMatrix.prototype.isRowVector = function isRowVector() {\n    return this.rows === 1;\n};\n\n/**\n * @returns {boolean} true if the matrix has one column\n */\nMatrix.prototype.isColumnVector = function isColumnVector() {\n    return this.columns === 1;\n};\n\n/**\n * @returns {boolean} true if the matrix has one row or one column\n */\nMatrix.prototype.isVector = function isVector() {\n    return (this.rows === 1) || (this.columns === 1);\n};\n\n/**\n * @returns {boolean} true if the matrix has the same number of rows and columns\n */\nMatrix.prototype.isSquare = function isSquare() {\n    return this.rows === this.columns;\n};\n\n/**\n * @returns {boolean} true if the matrix is square and has the same values on both sides of the diagonal\n */\nMatrix.prototype.isSymmetric = function isSymmetric() {\n    if (this.isSquare()) {\n        var l = this.rows;\n        for (var i = 0; i < l; i++) {\n            for (var j = 0; j <= i; j++) {\n                if (this[i][j] !== this[j][i]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    return false;\n};\n\n/**\n * Sets a given element of the matrix. mat.set(3,4,1) is equivalent to mat[3][4]=1\n * @param {number} rowIndex - Index of the row\n * @param {number} columnIndex - Index of the column\n * @param {number} value - The new value for the element\n * @returns {Matrix} this\n */\nMatrix.prototype.set = function set(rowIndex, columnIndex, value) {\n    this[rowIndex][columnIndex] = value;\n    return this;\n};\n\n/**\n * Returns the given element of the matrix. mat.get(3,4) is equivalent to matrix[3][4]\n * @param {number} rowIndex - Index of the row\n * @param {number} columnIndex - Index of the column\n * @returns {number}\n */\nMatrix.prototype.get = function get(rowIndex, columnIndex) {\n    return this[rowIndex][columnIndex];\n};\n\n/**\n * Fills the matrix with a given value. All elements will be set to this value.\n * @param {number} value - New value\n * @returns {Matrix} this\n */\nMatrix.prototype.fill = function fill(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] = value;\n        }\n    }\n    return this;\n};\n\n/**\n * Negates the matrix. All elements will be multiplied by (-1)\n * @returns {Matrix} this\n */\nMatrix.prototype.neg = function neg() {\n    return this.mulS(-1);\n};\n\n/**\n * Adds a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.add = function add(value) {\n    if (typeof value === 'number')\n        return this.addS(value);\n    value = Matrix.checkMatrix(value);\n        return this.addM(value);\n};\n\n/**\n * Adds a scalar to each element of the matrix\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.addS = function addS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += value;\n        }\n    }\n    return this;\n};\n\n/**\n * Adds the value of each element of matrix to the corresponding element of this\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.addM = function addM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.sub = function sub(value) {\n    if (typeof value === 'number')\n        return this.subS(value);\n    value = Matrix.checkMatrix(value);\n        return this.subM(value);\n};\n\n/**\n * Subtracts a scalar from each element of the matrix\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.subS = function subS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= value;\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts the value of each element of matrix from the corresponding element of this\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.subM = function subM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mul = function mul(value) {\n    if (typeof value === 'number')\n        return this.mulS(value);\n    value = Matrix.checkMatrix(value);\n        return this.mulM(value);\n};\n\n/**\n * Multiplies a scalar with each element of the matrix\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mulS = function mulS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= value;\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the value of each element of matrix with the corresponding element of this\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.mulM = function mulM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Divides by a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.div = function div(value) {\n    if (typeof value === 'number')\n        return this.divS(value);\n    value = Matrix.checkMatrix(value);\n        return this.divM(value);\n};\n\n/**\n * Divides each element of the matrix by a scalar\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.divS = function divS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= value;\n        }\n    }\n    return this;\n};\n\n/**\n * Divides each element of this by the corresponding element of matrix\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.divM = function divM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Returns a new array from the given row index\n * @param {number} index - Row index\n * @returns {Array}\n */\nMatrix.prototype.getRow = function getRow(index) {\n    this.checkRowIndex(index);\n    return slice(this[index]);\n};\n\n/**\n * Returns a new row vector from the given row index\n * @param {number} index - Row index\n * @returns {Matrix}\n */\nMatrix.prototype.getRowVector = function getRowVector(index) {\n    return Matrix.rowVector(this.getRow(index));\n};\n\n/**\n * Sets a row at the given index\n * @param {number} index - Row index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.setRow = function setRow(index, array) {\n    this.checkRowIndex(index);\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    if (array.length !== this.columns)\n        throw new RangeError('Invalid row size');\n    this[index] = slice(array);\n    return this;\n};\n\n/**\n * Removes a row from the given index\n * @param {number} index - Row index\n * @returns {Matrix} this\n */\nMatrix.prototype.removeRow = function removeRow(index) {\n    this.checkRowIndex(index);\n    if (this.rows === 1)\n        throw new RangeError('A matrix cannot have less than one row');\n    Asplice.call(this, index, 1);\n    this.rows -= 1;\n    return this;\n};\n\n/**\n * Adds a row at the given index\n * @param {number} [index = this.rows] - Row index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addRow = function addRow(index, array) {\n    if (typeof array === 'undefined') {\n        array = index;\n        index = this.rows;\n    }\n    if (index < 0 || index > this.rows)\n        throw new RangeError('Row index out of range.');\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    if (array.length !== this.columns)\n        throw new RangeError('Invalid row size');\n    Asplice.call(this, index, 0, slice(array));\n    this.rows += 1;\n    return this;\n};\n\n/**\n * Swaps two rows\n * @param {number} row1 - First row index\n * @param {number} row2 - Second row index\n * @returns {Matrix} this\n */\nMatrix.prototype.swapRows = function swapRows(row1, row2) {\n    this.checkRowIndex(row1);\n    this.checkRowIndex(row2);\n    var temp = this[row1];\n    this[row1] = this[row2];\n    this[row2] = temp;\n    return this;\n};\n\n/**\n * Returns a new array from the given column index\n * @param {number} index - Column index\n * @returns {Array}\n */\nMatrix.prototype.getColumn = function getColumn(index) {\n    this.checkColumnIndex(index);\n    var l = this.rows, column = new Array(l);\n    for (var i = 0; i < l; i++) {\n        column[i] = this[i][index];\n    }\n    return column;\n};\n\n/**\n * Returns a new column vector from the given column index\n * @param {number} index - Column index\n * @returns {Matrix}\n */\nMatrix.prototype.getColumnVector = function getColumnVector(index) {\n    return Matrix.columnVector(this.getColumn(index));\n};\n\n/**\n * Sets a column at the given index\n * @param {number} index - Column index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.setColumn = function setColumn(index, array) {\n    this.checkColumnIndex(index);\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    var l = this.rows;\n    if (array.length !== l)\n        throw new RangeError('Invalid column size');\n    for (var i = 0; i < l; i++) {\n        this[i][index] = array[i];\n    }\n    return this;\n};\n\n/**\n * Removes a column from the given index\n * @param {number} index - Column index\n * @returns {Matrix} this\n */\nMatrix.prototype.removeColumn = function removeColumn(index) {\n    this.checkColumnIndex(index);\n    if (this.columns === 1)\n        throw new RangeError('A matrix cannot have less than one column');\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        this[i].splice(index, 1);\n    }\n    this.columns -= 1;\n    return this;\n};\n\n/**\n * Adds a column at the given index\n * @param {number} [index = this.columns] - Column index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addColumn = function addColumn(index, array) {\n    if (typeof array === 'undefined') {\n        array = index;\n        index = this.columns;\n    }\n    if (index < 0 || index > this.columns)\n        throw new RangeError('Column index out of range.');\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    var l = this.rows;\n    if (array.length !== l)\n        throw new RangeError('Invalid column size');\n    for (var i = 0; i < l; i++) {\n        this[i].splice(index, 0, array[i]);\n    }\n    this.columns += 1;\n    return this;\n};\n\n/**\n * Swaps two columns\n * @param {number} column1 - First column index\n * @param {number} column2 - Second column index\n * @returns {Matrix} this\n */\nMatrix.prototype.swapColumns = function swapColumns(column1, column2) {\n    this.checkRowIndex(column1);\n    this.checkRowIndex(column2);\n    var l = this.rows, temp, row;\n    for (var i = 0; i < l; i++) {\n        row = this[i];\n        temp = row[column1];\n        row[column1] = row[column2];\n        row[column2] = temp;\n    }\n    return this;\n};\n\n/**\n * @private\n * Internal check that the provided vector is an array with the right length\n * @param {Array|Matrix} vector\n * @returns {Array}\n * @throws {RangeError}\n */\nMatrix.prototype.checkRowVector = function checkRowVector(vector) {\n    if (Matrix.isMatrix(vector))\n        vector = vector.to1DArray();\n    if (vector.length !== this.columns)\n        throw new RangeError('vector size must be the same as the number of columns');\n    return vector;\n};\n\n/**\n * @private\n * Internal check that the provided vector is an array with the right length\n * @param {Array|Matrix} vector\n * @returns {Array}\n * @throws {RangeError}\n */\nMatrix.prototype.checkColumnVector = function checkColumnVector(vector) {\n    if (Matrix.isMatrix(vector))\n        vector = vector.to1DArray();\n    if (vector.length !== this.rows)\n        throw new RangeError('vector size must be the same as the number of rows');\n    return vector;\n};\n\n/**\n * Adds the values of a vector to each row\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addRowVector = function addRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts the values of a vector from each row\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.subRowVector = function subRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a vector with each row\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.mulRowVector = function mulRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Divides the values of each row by those of a vector\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.divRowVector = function divRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Adds the values of a vector to each column\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addColumnVector = function addColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts the values of a vector from each column\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.subColumnVector = function subColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a vector with each column\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.mulColumnVector = function mulColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Divides the values of each column by those of a vector\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.divColumnVector = function divColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a row with a scalar\n * @param {number} index - Row index\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mulRow = function mulRow(index, value) {\n    this.checkRowIndex(index);\n    var i = 0, l = this.columns;\n    for (; i < l; i++) {\n        this[index][i] *= value;\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a column with a scalar\n * @param {number} index - Column index\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mulColumn = function mulColumn(index, value) {\n    this.checkColumnIndex(index);\n    var i = 0, l = this.rows;\n    for (; i < l; i++) {\n        this[i][index] *= value;\n    }\n};\n\n/**\n * A matrix index\n * @typedef {Object} MatrixIndex\n * @property {number} row\n * @property {number} column\n */\n\n/**\n * Returns the maximum value of the matrix\n * @returns {number}\n */\nMatrix.prototype.max = function max() {\n    var v = -Infinity;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] > v) {\n                v = this[i][j];\n            }\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value\n * @returns {MatrixIndex}\n */\nMatrix.prototype.maxIndex = function maxIndex() {\n    var v = -Infinity;\n    var idx = {};\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] > v) {\n                v = this[i][j];\n                idx.row = i;\n                idx.column = j;\n            }\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the minimum value of the matrix\n * @returns {number}\n */\nMatrix.prototype.min = function min() {\n    var v = Infinity;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] < v) {\n                v = this[i][j];\n            }\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the minimum value\n * @returns {MatrixIndex}\n */\nMatrix.prototype.minIndex = function minIndex() {\n    var v = Infinity;\n    var idx = {};\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] < v) {\n                v = this[i][j];\n                idx.row = i;\n                idx.column = j;\n            }\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the maximum value of one row\n * @param {number} index - Row index\n * @returns {number}\n */\nMatrix.prototype.maxRow = function maxRow(index) {\n    this.checkRowIndex(index);\n    var v = -Infinity;\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] > v) {\n            v = this[index][i];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value of one row\n * @param {number} index - Row index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.maxRowIndex = function maxRowIndex(index) {\n    this.checkRowIndex(index);\n    var v = -Infinity;\n    var idx = {\n            row: index\n        };\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] > v) {\n            v = this[index][i];\n            idx.column = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the minimum value of one row\n * @param {number} index - Row index\n * @returns {number}\n */\nMatrix.prototype.minRow = function minRow(index) {\n    this.checkRowIndex(index);\n    var v = Infinity;\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] < v) {\n            v = this[index][i];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value of one row\n * @param {number} index - Row index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.minRowIndex = function minRowIndex(index) {\n    this.checkRowIndex(index);\n    var v = Infinity;\n    var idx = {\n        row: index,\n        column: 0\n    };\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] < v) {\n            v = this[index][i];\n            idx.column = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the maximum value of one column\n * @param {number} index - Column index\n * @returns {number}\n */\nMatrix.prototype.maxColumn = function maxColumn(index) {\n    this.checkColumnIndex(index);\n    var v = -Infinity;\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] > v) {\n            v = this[i][index];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value of one column\n * @param {number} index - Column index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.maxColumnIndex = function maxColumnIndex(index) {\n    this.checkColumnIndex(index);\n    var v = -Infinity;\n    var idx = {\n        row: 0,\n        column: index\n    };\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] > v) {\n            v = this[i][index];\n            idx.row = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the minimum value of one column\n * @param {number} index - Column index\n * @returns {number}\n */\nMatrix.prototype.minColumn = function minColumn(index) {\n    this.checkColumnIndex(index);\n    var v = Infinity;\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] < v) {\n            v = this[i][index];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the minimum value of one column\n * @param {number} index - Column index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.minColumnIndex = function minColumnIndex(index) {\n    this.checkColumnIndex(index);\n    var v = Infinity;\n    var idx = {\n        row: 0,\n        column: index\n    };\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] < v) {\n            v = this[i][index];\n            idx.row = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns an array containing the diagonal values of the matrix\n * @returns {Array}\n */\nMatrix.prototype.diag = function diag() {\n    if (!this.isSquare())\n        throw new TypeError('Only square matrices have a diagonal.');\n    var diag = new Array(this.rows);\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        diag[i] = this[i][i];\n    }\n    return diag;\n};\n\n/**\n * Returns the sum of all elements of the matrix\n * @returns {number}\n */\nMatrix.prototype.sum = function sum() {\n    var v = 0;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            v += this[i][j];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the mean of all elements of the matrix\n * @returns {number}\n */\nMatrix.prototype.mean = function mean() {\n    return this.sum() / this.size;\n};\n\n/**\n * Returns the product of all elements of the matrix\n * @returns {number}\n */\nMatrix.prototype.prod = function prod() {\n    var prod = 1;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            prod *= this[i][j];\n        }\n    }\n    return prod;\n};\n\n/**\n * Computes the cumulative sum of the matrix elements (in place, row by row)\n * @returns {Matrix} this\n */\nMatrix.prototype.cumulativeSum = function cumulativeSum() {\n    var sum = 0;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            sum += this[i][j];\n            this[i][j] = sum;\n        }\n    }\n    return this;\n};\n\n/**\n * Computes the dot (scalar) product between the matrix and another\n * @param {Matrix} other vector\n * @returns {number}\n */\nMatrix.prototype.dot = function dot(other) {\n    if (this.size !== other.size)\n        throw new RangeError('vectors do not have the same size');\n    var vector1 = this.to1DArray();\n    var vector2 = other.to1DArray();\n    var dot = 0, l = vector1.length;\n    for (var i = 0; i < l; i++) {\n        dot += vector1[i] * vector2[i];\n    }\n    return dot;\n};\n\n/**\n * Returns the matrix product between this and other\n * @returns {Matrix}\n */\nMatrix.prototype.mmul = function mmul(other) {\n    if (!Matrix.isMatrix(other))\n        throw new TypeError('parameter \"other\" must be a matrix');\n    if (this.columns !== other.rows)\n        console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');\n\n    var m = this.rows, n = this.columns, p = other.columns;\n    var result = new Matrix(m, p);\n\n    var Bcolj = new Array(n);\n    var i, j, k;\n    for (j = 0; j < p; j++) {\n        for (k = 0; k < n; k++)\n            Bcolj[k] = other[k][j];\n\n        for (i = 0; i < m; i++) {\n            var Arowi = this[i];\n\n            var s = 0;\n            for (k = 0; k < n; k++)\n                s += Arowi[k] * Bcolj[k];\n\n            result[i][j] = s;\n        }\n    }\n    return result;\n};\n\n/**\n * Sorts the rows (in place)\n * @param {function} compareFunction - usual Array.prototype.sort comparison function\n * @returns {Matrix} this\n */\nMatrix.prototype.sortRows = function sortRows(compareFunction) {\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        this[i].sort(compareFunction);\n    }\n    return this;\n};\n\n/**\n * Sorts the columns (in place)\n * @param {function} compareFunction - usual Array.prototype.sort comparison function\n * @returns {Matrix} this\n */\nMatrix.prototype.sortColumns = function sortColumns(compareFunction) {\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        this.setColumn(i, this.getColumn(i).sort(compareFunction));\n    }\n    return this;\n};\n\n/**\n * Transposes the matrix and returns a new one containing the result\n * @returns {Matrix}\n */\nMatrix.prototype.transpose = function transpose() {\n    var result = new Matrix(this.columns, this.rows);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[j][i] = this[i][j];\n        }\n    }\n    return result;\n};\n\n/**\n * Returns a subset of the matrix\n * @param {number} startRow - First row index\n * @param {number} endRow - Last row index\n * @param {number} startColumn - First column index\n * @param {number} endColumn - Last column index\n * @returns {Matrix}\n */\nMatrix.prototype.subMatrix = function subMatrix(startRow, endRow, startColumn, endColumn) {\n    if ((startRow > endRow) || (startColumn > endColumn) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns))\n        throw new RangeError('Argument out of range');\n    var newMatrix = new Matrix(endRow - startRow + 1, endColumn - startColumn + 1);\n    for (var i = startRow; i <= endRow; i++) {\n        for (var j = startColumn; j <= endColumn; j++) {\n            newMatrix[i - startRow][j - startColumn] = this[i][j];\n        }\n    }\n    return newMatrix;\n};\n\n/**\n * Returns a subset of the matrix based on an array of row indices\n * @param {Array} indices - Array containing the row indices\n * @param {number} [startColumn = 0] - First column index\n * @param {number} [endColumn = this.columns-1] - Last column index\n * @returns {Matrix}\n */\nMatrix.prototype.subMatrixRow = function subMatrixRow(indices, startColumn, endColumn) {\n    if (typeof startColumn === 'undefined') {\n        startColumn = 0;\n        endColumn = this.columns - 1;\n    } else if (typeof endColumn === 'undefined') {\n        endColumn = this.columns - 1;\n    }\n    if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns))\n        throw new RangeError('Argument out of range.');\n    var l = indices.length, rows = this.rows,\n        X = new Matrix(l, endColumn - startColumn + 1);\n    for (var i = 0; i < l; i++) {\n        for (var j = startColumn; j <= endColumn; j++) {\n            if ((indices[i] < 0) || (indices[i] >= rows))\n                throw new RangeError('Argument out of range.');\n            X[i][j - startColumn] = this[indices[i]][j];\n        }\n    }\n    return X;\n};\n\n/**\n * Returns a subset of the matrix based on an array of column indices\n * @param {Array} indices - Array containing the column indices\n * @param {number} [startRow = 0] - First row index\n * @param {number} [endRow = this.rows-1] - Last row index\n * @returns {Matrix}\n */\nMatrix.prototype.subMatrixColumn = function subMatrixColumn(indices, startRow, endRow) {\n    if (typeof startRow === 'undefined') {\n        startRow = 0;\n        endRow = this.rows - 1;\n    } else if (typeof endRow === 'undefined') {\n        endRow = this.rows - 1;\n    }\n    if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows))\n        throw new RangeError('Argument out of range.');\n    var l = indices.length, columns = this.columns,\n        X = new Matrix(endRow - startRow + 1, l);\n    for (var i = 0; i < l; i++) {\n        for (var j = startRow; j <= endRow; j++) {\n            if ((indices[i] < 0) || (indices[i] >= columns))\n                throw new RangeError('Argument out of range.');\n            X[j - startRow][i] = this[j][indices[i]];\n        }\n    }\n    return X;\n};\n\n/**\n * Returns the trace of the matrix (sum of the diagonal elements)\n * @returns {number}\n */\nMatrix.prototype.trace = function trace() {\n    if (!this.isSquare())\n        throw new TypeError('The matrix is not square');\n    var trace = 0, i = 0, l = this.rows;\n    for (; i < l; i++) {\n        trace += this[i][i];\n    }\n    return trace;\n};\n\n/**\n * Sets each element of the matrix to its absolute value\n * @returns {Matrix} this\n */\nMatrix.prototype.abs = function abs() {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] = Math.abs(this[i][j]);\n        }\n    }\n};\n\nmodule.exports = Matrix;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-curve-fitting/~/ml-matrix/src/matrix.js\n ** module id = 18\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('./matrix');\n\nvar SingularValueDecomposition = require('./dc/svd');\nvar EigenvalueDecomposition = require('./dc/evd');\nvar LuDecomposition = require('./dc/lu');\nvar QrDecomposition = require('./dc/qr');\nvar CholeskyDecomposition = require('./dc/cholesky');\n\nfunction inverse(matrix) {\n    return solve(matrix, Matrix.eye(matrix.rows));\n}\n\nMatrix.prototype.inverse = function () {\n    return inverse(this);\n};\n\nfunction solve(leftHandSide, rightHandSide) {\n    return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).solve(rightHandSide);\n}\n\nMatrix.prototype.solve = function (other) {\n    return solve(this, other);\n};\n\nmodule.exports = {\n    SingularValueDecomposition: SingularValueDecomposition,\n    SVD: SingularValueDecomposition,\n    EigenvalueDecomposition: EigenvalueDecomposition,\n    EVD: EigenvalueDecomposition,\n    LuDecomposition: LuDecomposition,\n    LU: LuDecomposition,\n    QrDecomposition: QrDecomposition,\n    QR: QrDecomposition,\n    CholeskyDecomposition: CholeskyDecomposition,\n    CHO: CholeskyDecomposition,\n    inverse: inverse,\n    solve: solve\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-curve-fitting/~/ml-matrix/src/decompositions.js\n ** module id = 19\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\nvar hypotenuse = require('./util').hypotenuse;\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/SingularValueDecomposition.cs\nfunction SingularValueDecomposition(value, options) {\n    if (!(this instanceof SingularValueDecomposition)) {\n        return new SingularValueDecomposition(value, options);\n    }\n    value = Matrix.checkMatrix(value);\n\n    options = options || {};\n\n    var a = value.clone(),\n        m = value.rows,\n        n = value.columns,\n        nu = Math.min(m, n);\n\n    var wantu = true, wantv = true;\n    if (options.computeLeftSingularVectors === false)\n        wantu = false;\n    if (options.computeRightSingularVectors === false)\n        wantv = false;\n    var autoTranspose = options.autoTranspose === true;\n\n    var swapped = false;\n    if (m < n) {\n        if (!autoTranspose) {\n            console.warn('Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose');\n        } else {\n            a = a.transpose();\n            m = a.rows;\n            n = a.columns;\n            swapped = true;\n            var aux = wantu;\n            wantu = wantv;\n            wantv = aux;\n        }\n    }\n\n    var s = new Array(Math.min(m + 1, n)),\n        U = Matrix.zeros(m, nu),\n        V = Matrix.zeros(n, n),\n        e = new Array(n),\n        work = new Array(m);\n\n    var nct = Math.min(m - 1, n);\n    var nrt = Math.max(0, Math.min(n - 2, m));\n\n    var i, j, k, p, t, ks, f, cs, sn, max, kase,\n        scale, sp, spm1, epm1, sk, ek, b, c, shift, g;\n\n    for (k = 0, max = Math.max(nct, nrt); k < max; k++) {\n        if (k < nct) {\n            s[k] = 0;\n            for (i = k; i < m; i++) {\n                s[k] = hypotenuse(s[k], a[i][k]);\n            }\n            if (s[k] !== 0) {\n                if (a[k][k] < 0) {\n                    s[k] = -s[k];\n                }\n                for (i = k; i < m; i++) {\n                    a[i][k] /= s[k];\n                }\n                a[k][k] += 1;\n            }\n            s[k] = -s[k];\n        }\n\n        for (j = k + 1; j < n; j++) {\n            if ((k < nct) && (s[k] !== 0)) {\n                t = 0;\n                for (i = k; i < m; i++) {\n                    t += a[i][k] * a[i][j];\n                }\n                t = -t / a[k][k];\n                for (i = k; i < m; i++) {\n                    a[i][j] += t * a[i][k];\n                }\n            }\n            e[j] = a[k][j];\n        }\n\n        if (wantu && (k < nct)) {\n            for (i = k; i < m; i++) {\n                U[i][k] = a[i][k];\n            }\n        }\n\n        if (k < nrt) {\n            e[k] = 0;\n            for (i = k + 1; i < n; i++) {\n                e[k] = hypotenuse(e[k], e[i]);\n            }\n            if (e[k] !== 0) {\n                if (e[k + 1] < 0)\n                    e[k] = -e[k];\n                for (i = k + 1; i < n; i++) {\n                    e[i] /= e[k];\n                }\n                e[k + 1] += 1;\n            }\n            e[k] = -e[k];\n            if ((k + 1 < m) && (e[k] !== 0)) {\n                for (i = k + 1; i < m; i++) {\n                    work[i] = 0;\n                }\n                for (j = k + 1; j < n; j++) {\n                    for (i = k + 1; i < m; i++) {\n                        work[i] += e[j] * a[i][j];\n                    }\n                }\n                for (j = k + 1; j < n; j++) {\n                    t = -e[j] / e[k + 1];\n                    for (i = k + 1; i < m; i++) {\n                        a[i][j] += t * work[i];\n                    }\n                }\n            }\n            if (wantv) {\n                for (i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n    }\n\n    p = Math.min(n, m + 1);\n    if (nct < n) {\n        s[nct] = a[nct][nct];\n    }\n    if (m < p) {\n        s[p - 1] = 0;\n    }\n    if (nrt + 1 < p) {\n        e[nrt] = a[nrt][p - 1];\n    }\n    e[p - 1] = 0;\n\n    if (wantu) {\n        for (j = nct; j < nu; j++) {\n            for (i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (k = nct - 1; k >= 0; k--) {\n            if (s[k] !== 0) {\n                for (j = k + 1; j < nu; j++) {\n                    t = 0;\n                    for (i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n    }\n\n    if (wantv) {\n        for (k = n - 1; k >= 0; k--) {\n            if ((k < nrt) && (e[k] !== 0)) {\n                for (j = k + 1; j < n; j++) {\n                    t = 0;\n                    for (i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n    }\n\n    var pp = p - 1,\n        iter = 0,\n        eps = Math.pow(2, -52);\n    while (p > 0) {\n        for (k = p - 2; k >= -1; k--) {\n            if (k === -1) {\n                break;\n            }\n            if (Math.abs(e[k]) <= eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {\n                e[k] = 0;\n                break;\n            }\n        }\n        if (k === p - 2) {\n            kase = 4;\n        } else {\n            for (ks = p - 1; ks >= k; ks--) {\n                if (ks === k) {\n                    break;\n                }\n                t = (ks !== p ? Math.abs(e[ks]) : 0) + (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);\n                if (Math.abs(s[ks]) <= eps * t) {\n                    s[ks] = 0;\n                    break;\n                }\n            }\n            if (ks === k) {\n                kase = 3;\n            } else if (ks === p - 1) {\n                kase = 1;\n            } else {\n                kase = 2;\n                k = ks;\n            }\n        }\n\n        k++;\n\n        switch (kase) {\n            case 1: {\n                f = e[p - 2];\n                e[p - 2] = 0;\n                for (j = p - 2; j >= k; j--) {\n                    t = hypotenuse(s[j], f);\n                    cs = s[j] / t;\n                    sn = f / t;\n                    s[j] = t;\n                    if (j !== k) {\n                        f = -sn * e[j - 1];\n                        e[j - 1] = cs * e[j - 1];\n                    }\n                    if (wantv) {\n                        for (i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n            }\n            case 2 : {\n                f = e[k - 1];\n                e[k - 1] = 0;\n                for (j = k; j < p; j++) {\n                    t = hypotenuse(s[j], f);\n                    cs = s[j] / t;\n                    sn = f / t;\n                    s[j] = t;\n                    f = -sn * e[j];\n                    e[j] = cs * e[j];\n                    if (wantu) {\n                        for (i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n            }\n            case 3 : {\n                scale = Math.max(Math.max(Math.max(Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2])), Math.abs(e[p - 2])), Math.abs(s[k])), Math.abs(e[k]));\n                sp = s[p - 1] / scale;\n                spm1 = s[p - 2] / scale;\n                epm1 = e[p - 2] / scale;\n                sk = s[k] / scale;\n                ek = e[k] / scale;\n                b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;\n                c = (sp * epm1) * (sp * epm1);\n                shift = 0;\n                if ((b !== 0) || (c !== 0)) {\n                    shift = Math.sqrt(b * b + c);\n                    if (b < 0) {\n                        shift = -shift;\n                    }\n                    shift = c / (b + shift);\n                }\n                f = (sk + sp) * (sk - sp) + shift;\n                g = sk * ek;\n                for (j = k; j < p - 1; j++) {\n                    t = hypotenuse(f, g);\n                    cs = f / t;\n                    sn = g / t;\n                    if (j !== k) {\n                        e[j - 1] = t;\n                    }\n                    f = cs * s[j] + sn * e[j];\n                    e[j] = cs * e[j] - sn * s[j];\n                    g = sn * s[j + 1];\n                    s[j + 1] = cs * s[j + 1];\n                    if (wantv) {\n                        for (i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                    }\n                    t = hypotenuse(f, g);\n                    cs = f / t;\n                    sn = g / t;\n                    s[j] = t;\n                    f = cs * e[j] + sn * s[j + 1];\n                    s[j + 1] = -sn * e[j] + cs * s[j + 1];\n                    g = sn * e[j + 1];\n                    e[j + 1] = cs * e[j + 1];\n                    if (wantu && (j < m - 1)) {\n                        for (i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][j + 1];\n                            U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                e[p - 2] = f;\n                iter = iter + 1;\n                break;\n            }\n            case 4: {\n                if (s[k] <= 0) {\n                    s[k] = (s[k] < 0 ? -s[k] : 0);\n                    if (wantv) {\n                        for (i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                }\n                while (k < pp) {\n                    if (s[k] >= s[k + 1]) {\n                        break;\n                    }\n                    t = s[k];\n                    s[k] = s[k + 1];\n                    s[k + 1] = t;\n                    if (wantv && (k < n - 1)) {\n                        for (i = 0; i < n; i++) {\n                            t = V[i][k + 1];\n                            V[i][k + 1] = V[i][k];\n                            V[i][k] = t;\n                        }\n                    }\n                    if (wantu && (k < m - 1)) {\n                        for (i = 0; i < m; i++) {\n                            t = U[i][k + 1];\n                            U[i][k + 1] = U[i][k];\n                            U[i][k] = t;\n                        }\n                    }\n                    k++;\n                }\n                iter = 0;\n                p--;\n                break;\n            }\n        }\n    }\n\n    if (swapped) {\n        var tmp = V;\n        V = U;\n        U = tmp;\n    }\n\n    this.m = m;\n    this.n = n;\n    this.s = s;\n    this.U = U;\n    this.V = V;\n}\n\nSingularValueDecomposition.prototype = {\n    get condition() {\n        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];\n    },\n    get norm2() {\n        return this.s[0];\n    },\n    get rank() {\n        var eps = Math.pow(2, -52),\n            tol = Math.max(this.m, this.n) * this.s[0] * eps,\n            r = 0,\n            s = this.s;\n        for (var i = 0, ii = s.length; i < ii; i++) {\n            if (s[i] > tol) {\n                r++;\n            }\n        }\n        return r;\n    },\n    get diagonal() {\n        return this.s;\n    },\n    // https://github.com/accord-net/framework/blob/development/Sources/Accord.Math/Decompositions/SingularValueDecomposition.cs\n    get threshold() {\n        return (Math.pow(2, -52) / 2) * Math.max(this.m, this.n) * this.s[0];\n    },\n    get leftSingularVectors() {\n        return this.U;\n    },\n    get rightSingularVectors() {\n        return this.V;\n    },\n    get diagonalMatrix() {\n        return Matrix.diag(this.s);\n    },\n    solve: function (value) {\n\n        var Y = value,\n            e = this.threshold,\n            scols = this.s.length,\n            Ls = Matrix.zeros(scols, scols),\n            i;\n\n        for (i = 0; i < scols; i++) {\n            if (Math.abs(this.s[i]) <= e) {\n                Ls[i][i] = 0;\n            } else {\n                Ls[i][i] = 1 / this.s[i];\n            }\n        }\n\n\n        var VL = this.V.mmul(Ls),\n            vrows = this.V.rows,\n            urows = this.U.rows,\n            VLU = Matrix.zeros(vrows, urows),\n            j, k, sum;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < urows; j++) {\n                sum = 0;\n                for (k = 0; k < scols; k++) {\n                    sum += VL[i][k] * this.U[j][k];\n                }\n                VLU[i][j] = sum;\n            }\n        }\n\n        return VLU.mmul(Y);\n    },\n    solveForDiagonal: function (value) {\n        return this.solve(Matrix.diag(value));\n    },\n    inverse: function () {\n        var e = this.threshold,\n            vrows = this.V.rows,\n            vcols = this.V.columns,\n            X = new Matrix(vrows, this.s.length),\n            i, j;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < vcols; j++) {\n                if (Math.abs(this.s[j]) > e) {\n                    X[i][j] = this.V[i][j] / this.s[j];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n\n        var urows = this.U.rows,\n            ucols = this.U.columns,\n            Y = new Matrix(vrows, urows),\n            k, sum;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < urows; j++) {\n                sum = 0;\n                for (k = 0; k < ucols; k++) {\n                    sum += X[i][k] * this.U[j][k];\n                }\n                Y[i][j] = sum;\n            }\n        }\n\n        return Y;\n    }\n};\n\nmodule.exports = SingularValueDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-curve-fitting/~/ml-matrix/src/dc/svd.js\n ** module id = 20\n ** module chunks = 0\n **/","'use strict';\n\nexports.hypotenuse = function hypotenuse(a, b) {\n    var r;\n    if (Math.abs(a) > Math.abs(b)) {\n        r = b / a;\n        return Math.abs(a) * Math.sqrt(1 + r * r);\n    }\n    if (b !== 0) {\n        r = a / b;\n        return Math.abs(b) * Math.sqrt(1 + r * r);\n    }\n    return 0;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-curve-fitting/~/ml-matrix/src/dc/util.js\n ** module id = 21\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\nvar hypotenuse = require('./util').hypotenuse;\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/EigenvalueDecomposition.cs\nfunction EigenvalueDecomposition(matrix) {\n    if (!(this instanceof EigenvalueDecomposition)) {\n        return new EigenvalueDecomposition(matrix);\n    }\n    matrix = Matrix.checkMatrix(matrix);\n    if (!matrix.isSquare()) {\n        throw new Error('Matrix is not a square matrix');\n    }\n\n    var n = matrix.columns,\n        V = Matrix.zeros(n, n),\n        d = new Array(n),\n        e = new Array(n),\n        value = matrix,\n        i, j;\n\n    if (matrix.isSymmetric()) {\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                V[i][j] = value[i][j];\n            }\n        }\n        tred2(n, e, d, V);\n        tql2(n, e, d, V);\n    }\n    else {\n        var H = Matrix.zeros(n, n),\n            ort = new Array(n);\n        for (j = 0; j < n; j++) {\n            for (i = 0; i < n; i++) {\n                H[i][j] = value[i][j];\n            }\n        }\n        orthes(n, H, ort, V);\n        hqr2(n, e, d, V, H);\n    }\n\n    this.n = n;\n    this.e = e;\n    this.d = d;\n    this.V = V;\n}\n\nEigenvalueDecomposition.prototype = {\n    get realEigenvalues() {\n        return this.d;\n    },\n    get imaginaryEigenvalues() {\n        return this.e;\n    },\n    get eigenvectorMatrix() {\n        return this.V;\n    },\n    get diagonalMatrix() {\n        var n = this.n,\n            e = this.e,\n            d = this.d,\n            X = new Matrix(n, n),\n            i, j;\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                X[i][j] = 0;\n            }\n            X[i][i] = d[i];\n            if (e[i] > 0) {\n                X[i][i + 1] = e[i];\n            }\n            else if (e[i] < 0) {\n                X[i][i - 1] = e[i];\n            }\n        }\n        return X;\n    }\n};\n\nfunction tred2(n, e, d, V) {\n\n    var f, g, h, i, j, k,\n        hh, scale;\n\n    for (j = 0; j < n; j++) {\n        d[j] = V[n - 1][j];\n    }\n\n    for (i = n - 1; i > 0; i--) {\n        scale = 0;\n        h = 0;\n        for (k = 0; k < i; k++) {\n            scale = scale + Math.abs(d[k]);\n        }\n\n        if (scale === 0) {\n            e[i] = d[i - 1];\n            for (j = 0; j < i; j++) {\n                d[j] = V[i - 1][j];\n                V[i][j] = 0;\n                V[j][i] = 0;\n            }\n        } else {\n            for (k = 0; k < i; k++) {\n                d[k] /= scale;\n                h += d[k] * d[k];\n            }\n\n            f = d[i - 1];\n            g = Math.sqrt(h);\n            if (f > 0) {\n                g = -g;\n            }\n\n            e[i] = scale * g;\n            h = h - f * g;\n            d[i - 1] = f - g;\n            for (j = 0; j < i; j++) {\n                e[j] = 0;\n            }\n\n            for (j = 0; j < i; j++) {\n                f = d[j];\n                V[j][i] = f;\n                g = e[j] + V[j][j] * f;\n                for (k = j + 1; k <= i - 1; k++) {\n                    g += V[k][j] * d[k];\n                    e[k] += V[k][j] * f;\n                }\n                e[j] = g;\n            }\n\n            f = 0;\n            for (j = 0; j < i; j++) {\n                e[j] /= h;\n                f += e[j] * d[j];\n            }\n\n            hh = f / (h + h);\n            for (j = 0; j < i; j++) {\n                e[j] -= hh * d[j];\n            }\n\n            for (j = 0; j < i; j++) {\n                f = d[j];\n                g = e[j];\n                for (k = j; k <= i - 1; k++) {\n                    V[k][j] -= (f * e[k] + g * d[k]);\n                }\n                d[j] = V[i - 1][j];\n                V[i][j] = 0;\n            }\n        }\n        d[i] = h;\n    }\n\n    for (i = 0; i < n - 1; i++) {\n        V[n - 1][i] = V[i][i];\n        V[i][i] = 1;\n        h = d[i + 1];\n        if (h !== 0) {\n            for (k = 0; k <= i; k++) {\n                d[k] = V[k][i + 1] / h;\n            }\n\n            for (j = 0; j <= i; j++) {\n                g = 0;\n                for (k = 0; k <= i; k++) {\n                    g += V[k][i + 1] * V[k][j];\n                }\n                for (k = 0; k <= i; k++) {\n                    V[k][j] -= g * d[k];\n                }\n            }\n        }\n\n        for (k = 0; k <= i; k++) {\n            V[k][i + 1] = 0;\n        }\n    }\n\n    for (j = 0; j < n; j++) {\n        d[j] = V[n - 1][j];\n        V[n - 1][j] = 0;\n    }\n\n    V[n - 1][n - 1] = 1;\n    e[0] = 0;\n}\n\nfunction tql2(n, e, d, V) {\n\n    var g, h, i, j, k, l, m, p, r,\n        dl1, c, c2, c3, el1, s, s2,\n        iter;\n\n    for (i = 1; i < n; i++) {\n        e[i - 1] = e[i];\n    }\n\n    e[n - 1] = 0;\n\n    var f = 0,\n        tst1 = 0,\n        eps = Math.pow(2, -52);\n\n    for (l = 0; l < n; l++) {\n        tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));\n        m = l;\n        while (m < n) {\n            if (Math.abs(e[m]) <= eps * tst1) {\n                break;\n            }\n            m++;\n        }\n\n        if (m > l) {\n            iter = 0;\n            do {\n                iter = iter + 1;\n\n                g = d[l];\n                p = (d[l + 1] - g) / (2 * e[l]);\n                r = hypotenuse(p, 1);\n                if (p < 0) {\n                    r = -r;\n                }\n\n                d[l] = e[l] / (p + r);\n                d[l + 1] = e[l] * (p + r);\n                dl1 = d[l + 1];\n                h = g - d[l];\n                for (i = l + 2; i < n; i++) {\n                    d[i] -= h;\n                }\n\n                f = f + h;\n\n                p = d[m];\n                c = 1;\n                c2 = c;\n                c3 = c;\n                el1 = e[l + 1];\n                s = 0;\n                s2 = 0;\n                for (i = m - 1; i >= l; i--) {\n                    c3 = c2;\n                    c2 = c;\n                    s2 = s;\n                    g = c * e[i];\n                    h = c * p;\n                    r = hypotenuse(p, e[i]);\n                    e[i + 1] = s * r;\n                    s = e[i] / r;\n                    c = p / r;\n                    p = c * d[i] - s * g;\n                    d[i + 1] = h + s * (c * g + s * d[i]);\n\n                    for (k = 0; k < n; k++) {\n                        h = V[k][i + 1];\n                        V[k][i + 1] = s * V[k][i] + c * h;\n                        V[k][i] = c * V[k][i] - s * h;\n                    }\n                }\n\n                p = -s * s2 * c3 * el1 * e[l] / dl1;\n                e[l] = s * p;\n                d[l] = c * p;\n\n            }\n            while (Math.abs(e[l]) > eps * tst1);\n        }\n        d[l] = d[l] + f;\n        e[l] = 0;\n    }\n\n    for (i = 0; i < n - 1; i++) {\n        k = i;\n        p = d[i];\n        for (j = i + 1; j < n; j++) {\n            if (d[j] < p) {\n                k = j;\n                p = d[j];\n            }\n        }\n\n        if (k !== i) {\n            d[k] = d[i];\n            d[i] = p;\n            for (j = 0; j < n; j++) {\n                p = V[j][i];\n                V[j][i] = V[j][k];\n                V[j][k] = p;\n            }\n        }\n    }\n}\n\nfunction orthes(n, H, ort, V) {\n\n    var low = 0,\n        high = n - 1,\n        f, g, h, i, j, m,\n        scale;\n\n    for (m = low + 1; m <= high - 1; m++) {\n        scale = 0;\n        for (i = m; i <= high; i++) {\n            scale = scale + Math.abs(H[i][m - 1]);\n        }\n\n        if (scale !== 0) {\n            h = 0;\n            for (i = high; i >= m; i--) {\n                ort[i] = H[i][m - 1] / scale;\n                h += ort[i] * ort[i];\n            }\n\n            g = Math.sqrt(h);\n            if (ort[m] > 0) {\n                g = -g;\n            }\n\n            h = h - ort[m] * g;\n            ort[m] = ort[m] - g;\n\n            for (j = m; j < n; j++) {\n                f = 0;\n                for (i = high; i >= m; i--) {\n                    f += ort[i] * H[i][j];\n                }\n\n                f = f / h;\n                for (i = m; i <= high; i++) {\n                    H[i][j] -= f * ort[i];\n                }\n            }\n\n            for (i = 0; i <= high; i++) {\n                f = 0;\n                for (j = high; j >= m; j--) {\n                    f += ort[j] * H[i][j];\n                }\n\n                f = f / h;\n                for (j = m; j <= high; j++) {\n                    H[i][j] -= f * ort[j];\n                }\n            }\n\n            ort[m] = scale * ort[m];\n            H[m][m - 1] = scale * g;\n        }\n    }\n\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            V[i][j] = (i === j ? 1 : 0);\n        }\n    }\n\n    for (m = high - 1; m >= low + 1; m--) {\n        if (H[m][m - 1] !== 0) {\n            for (i = m + 1; i <= high; i++) {\n                ort[i] = H[i][m - 1];\n            }\n\n            for (j = m; j <= high; j++) {\n                g = 0;\n                for (i = m; i <= high; i++) {\n                    g += ort[i] * V[i][j];\n                }\n\n                g = (g / ort[m]) / H[m][m - 1];\n                for (i = m; i <= high; i++) {\n                    V[i][j] += g * ort[i];\n                }\n            }\n        }\n    }\n}\n\nfunction hqr2(nn, e, d, V, H) {\n    var n = nn - 1,\n        low = 0,\n        high = nn - 1,\n        eps = Math.pow(2, -52),\n        exshift = 0,\n        norm = 0,\n        p = 0,\n        q = 0,\n        r = 0,\n        s = 0,\n        z = 0,\n        iter = 0,\n        i, j, k, l, m, t, w, x, y,\n        ra, sa, vr, vi,\n        notlast, cdivres;\n\n    for (i = 0; i < nn; i++) {\n        if (i < low || i > high) {\n            d[i] = H[i][i];\n            e[i] = 0;\n        }\n\n        for (j = Math.max(i - 1, 0); j < nn; j++) {\n            norm = norm + Math.abs(H[i][j]);\n        }\n    }\n\n    while (n >= low) {\n        l = n;\n        while (l > low) {\n            s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);\n            if (s === 0) {\n                s = norm;\n            }\n            if (Math.abs(H[l][l - 1]) < eps * s) {\n                break;\n            }\n            l--;\n        }\n\n        if (l === n) {\n            H[n][n] = H[n][n] + exshift;\n            d[n] = H[n][n];\n            e[n] = 0;\n            n--;\n            iter = 0;\n        } else if (l === n - 1) {\n            w = H[n][n - 1] * H[n - 1][n];\n            p = (H[n - 1][n - 1] - H[n][n]) / 2;\n            q = p * p + w;\n            z = Math.sqrt(Math.abs(q));\n            H[n][n] = H[n][n] + exshift;\n            H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;\n            x = H[n][n];\n\n            if (q >= 0) {\n                z = (p >= 0) ? (p + z) : (p - z);\n                d[n - 1] = x + z;\n                d[n] = d[n - 1];\n                if (z !== 0) {\n                    d[n] = x - w / z;\n                }\n                e[n - 1] = 0;\n                e[n] = 0;\n                x = H[n][n - 1];\n                s = Math.abs(x) + Math.abs(z);\n                p = x / s;\n                q = z / s;\n                r = Math.sqrt(p * p + q * q);\n                p = p / r;\n                q = q / r;\n\n                for (j = n - 1; j < nn; j++) {\n                    z = H[n - 1][j];\n                    H[n - 1][j] = q * z + p * H[n][j];\n                    H[n][j] = q * H[n][j] - p * z;\n                }\n\n                for (i = 0; i <= n; i++) {\n                    z = H[i][n - 1];\n                    H[i][n - 1] = q * z + p * H[i][n];\n                    H[i][n] = q * H[i][n] - p * z;\n                }\n\n                for (i = low; i <= high; i++) {\n                    z = V[i][n - 1];\n                    V[i][n - 1] = q * z + p * V[i][n];\n                    V[i][n] = q * V[i][n] - p * z;\n                }\n            } else {\n                d[n - 1] = x + p;\n                d[n] = x + p;\n                e[n - 1] = z;\n                e[n] = -z;\n            }\n\n            n = n - 2;\n            iter = 0;\n        } else {\n            x = H[n][n];\n            y = 0;\n            w = 0;\n            if (l < n) {\n                y = H[n - 1][n - 1];\n                w = H[n][n - 1] * H[n - 1][n];\n            }\n\n            if (iter === 10) {\n                exshift += x;\n                for (i = low; i <= n; i++) {\n                    H[i][i] -= x;\n                }\n                s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);\n                x = y = 0.75 * s;\n                w = -0.4375 * s * s;\n            }\n\n            if (iter === 30) {\n                s = (y - x) / 2;\n                s = s * s + w;\n                if (s > 0) {\n                    s = Math.sqrt(s);\n                    if (y < x) {\n                        s = -s;\n                    }\n                    s = x - w / ((y - x) / 2 + s);\n                    for (i = low; i <= n; i++) {\n                        H[i][i] -= s;\n                    }\n                    exshift += s;\n                    x = y = w = 0.964;\n                }\n            }\n\n            iter = iter + 1;\n\n            m = n - 2;\n            while (m >= l) {\n                z = H[m][m];\n                r = x - z;\n                s = y - z;\n                p = (r * s - w) / H[m + 1][m] + H[m][m + 1];\n                q = H[m + 1][m + 1] - z - r - s;\n                r = H[m + 2][m + 1];\n                s = Math.abs(p) + Math.abs(q) + Math.abs(r);\n                p = p / s;\n                q = q / s;\n                r = r / s;\n                if (m === l) {\n                    break;\n                }\n                if (Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) < eps * (Math.abs(p) * (Math.abs(H[m - 1][m - 1]) + Math.abs(z) + Math.abs(H[m + 1][m + 1])))) {\n                    break;\n                }\n                m--;\n            }\n\n            for (i = m + 2; i <= n; i++) {\n                H[i][i - 2] = 0;\n                if (i > m + 2) {\n                    H[i][i - 3] = 0;\n                }\n            }\n\n            for (k = m; k <= n - 1; k++) {\n                notlast = (k !== n - 1);\n                if (k !== m) {\n                    p = H[k][k - 1];\n                    q = H[k + 1][k - 1];\n                    r = (notlast ? H[k + 2][k - 1] : 0);\n                    x = Math.abs(p) + Math.abs(q) + Math.abs(r);\n                    if (x !== 0) {\n                        p = p / x;\n                        q = q / x;\n                        r = r / x;\n                    }\n                }\n\n                if (x === 0) {\n                    break;\n                }\n\n                s = Math.sqrt(p * p + q * q + r * r);\n                if (p < 0) {\n                    s = -s;\n                }\n\n                if (s !== 0) {\n                    if (k !== m) {\n                        H[k][k - 1] = -s * x;\n                    } else if (l !== m) {\n                        H[k][k - 1] = -H[k][k - 1];\n                    }\n\n                    p = p + s;\n                    x = p / s;\n                    y = q / s;\n                    z = r / s;\n                    q = q / p;\n                    r = r / p;\n\n                    for (j = k; j < nn; j++) {\n                        p = H[k][j] + q * H[k + 1][j];\n                        if (notlast) {\n                            p = p + r * H[k + 2][j];\n                            H[k + 2][j] = H[k + 2][j] - p * z;\n                        }\n\n                        H[k][j] = H[k][j] - p * x;\n                        H[k + 1][j] = H[k + 1][j] - p * y;\n                    }\n\n                    for (i = 0; i <= Math.min(n, k + 3); i++) {\n                        p = x * H[i][k] + y * H[i][k + 1];\n                        if (notlast) {\n                            p = p + z * H[i][k + 2];\n                            H[i][k + 2] = H[i][k + 2] - p * r;\n                        }\n\n                        H[i][k] = H[i][k] - p;\n                        H[i][k + 1] = H[i][k + 1] - p * q;\n                    }\n\n                    for (i = low; i <= high; i++) {\n                        p = x * V[i][k] + y * V[i][k + 1];\n                        if (notlast) {\n                            p = p + z * V[i][k + 2];\n                            V[i][k + 2] = V[i][k + 2] - p * r;\n                        }\n\n                        V[i][k] = V[i][k] - p;\n                        V[i][k + 1] = V[i][k + 1] - p * q;\n                    }\n                }\n            }\n        }\n    }\n\n    if (norm === 0) {\n        return;\n    }\n\n    for (n = nn - 1; n >= 0; n--) {\n        p = d[n];\n        q = e[n];\n\n        if (q === 0) {\n            l = n;\n            H[n][n] = 1;\n            for (i = n - 1; i >= 0; i--) {\n                w = H[i][i] - p;\n                r = 0;\n                for (j = l; j <= n; j++) {\n                    r = r + H[i][j] * H[j][n];\n                }\n\n                if (e[i] < 0) {\n                    z = w;\n                    s = r;\n                } else {\n                    l = i;\n                    if (e[i] === 0) {\n                        H[i][n] = (w !== 0) ? (-r / w) : (-r / (eps * norm));\n                    } else {\n                        x = H[i][i + 1];\n                        y = H[i + 1][i];\n                        q = (d[i] - p) * (d[i] - p) + e[i] * e[i];\n                        t = (x * s - z * r) / q;\n                        H[i][n] = t;\n                        H[i + 1][n] = (Math.abs(x) > Math.abs(z)) ? ((-r - w * t) / x) : ((-s - y * t) / z);\n                    }\n\n                    t = Math.abs(H[i][n]);\n                    if ((eps * t) * t > 1) {\n                        for (j = i; j <= n; j++) {\n                            H[j][n] = H[j][n] / t;\n                        }\n                    }\n                }\n            }\n        } else if (q < 0) {\n            l = n - 1;\n\n            if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {\n                H[n - 1][n - 1] = q / H[n][n - 1];\n                H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];\n            } else {\n                cdivres = cdiv(0, -H[n - 1][n], H[n - 1][n - 1] - p, q);\n                H[n - 1][n - 1] = cdivres[0];\n                H[n - 1][n] = cdivres[1];\n            }\n\n            H[n][n - 1] = 0;\n            H[n][n] = 1;\n            for (i = n - 2; i >= 0; i--) {\n                ra = 0;\n                sa = 0;\n                for (j = l; j <= n; j++) {\n                    ra = ra + H[i][j] * H[j][n - 1];\n                    sa = sa + H[i][j] * H[j][n];\n                }\n\n                w = H[i][i] - p;\n\n                if (e[i] < 0) {\n                    z = w;\n                    r = ra;\n                    s = sa;\n                } else {\n                    l = i;\n                    if (e[i] === 0) {\n                        cdivres = cdiv(-ra, -sa, w, q);\n                        H[i][n - 1] = cdivres[0];\n                        H[i][n] = cdivres[1];\n                    } else {\n                        x = H[i][i + 1];\n                        y = H[i + 1][i];\n                        vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;\n                        vi = (d[i] - p) * 2 * q;\n                        if (vr === 0 && vi === 0) {\n                            vr = eps * norm * (Math.abs(w) + Math.abs(q) + Math.abs(x) + Math.abs(y) + Math.abs(z));\n                        }\n                        cdivres = cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);\n                        H[i][n - 1] = cdivres[0];\n                        H[i][n] = cdivres[1];\n                        if (Math.abs(x) > (Math.abs(z) + Math.abs(q))) {\n                            H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;\n                            H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;\n                        } else {\n                            cdivres = cdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);\n                            H[i + 1][n - 1] = cdivres[0];\n                            H[i + 1][n] = cdivres[1];\n                        }\n                    }\n\n                    t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));\n                    if ((eps * t) * t > 1) {\n                        for (j = i; j <= n; j++) {\n                            H[j][n - 1] = H[j][n - 1] / t;\n                            H[j][n] = H[j][n] / t;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < nn; i++) {\n        if (i < low || i > high) {\n            for (j = i; j < nn; j++) {\n                V[i][j] = H[i][j];\n            }\n        }\n    }\n\n    for (j = nn - 1; j >= low; j--) {\n        for (i = low; i <= high; i++) {\n            z = 0;\n            for (k = low; k <= Math.min(j, high); k++) {\n                z = z + V[i][k] * H[k][j];\n            }\n            V[i][j] = z;\n        }\n    }\n}\n\nfunction cdiv(xr, xi, yr, yi) {\n    var r, d;\n    if (Math.abs(yr) > Math.abs(yi)) {\n        r = yi / yr;\n        d = yr + r * yi;\n        return [(xr + r * xi) / d, (xi - r * xr) / d];\n    }\n    else {\n        r = yr / yi;\n        d = yi + r * yr;\n        return [(r * xr + xi) / d, (r * xi - xr) / d];\n    }\n}\n\nmodule.exports = EigenvalueDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-curve-fitting/~/ml-matrix/src/dc/evd.js\n ** module id = 22\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/LuDecomposition.cs\nfunction LuDecomposition(matrix) {\n    if (!(this instanceof LuDecomposition)) {\n        return new LuDecomposition(matrix);\n    }\n    matrix = Matrix.checkMatrix(matrix);\n\n    var lu = matrix.clone(),\n        rows = lu.rows,\n        columns = lu.columns,\n        pivotVector = new Array(rows),\n        pivotSign = 1,\n        i, j, k, p, s, t, v,\n        LUrowi, LUcolj, kmax;\n\n    for (i = 0; i < rows; i++) {\n        pivotVector[i] = i;\n    }\n\n    LUcolj = new Array(rows);\n\n    for (j = 0; j < columns; j++) {\n\n        for (i = 0; i < rows; i++) {\n            LUcolj[i] = lu[i][j];\n        }\n\n        for (i = 0; i < rows; i++) {\n            LUrowi = lu[i];\n            kmax = Math.min(i, j);\n            s = 0;\n            for (k = 0; k < kmax; k++) {\n                s += LUrowi[k] * LUcolj[k];\n            }\n            LUrowi[j] = LUcolj[i] -= s;\n        }\n\n        p = j;\n        for (i = j + 1; i < rows; i++) {\n            if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {\n                p = i;\n            }\n        }\n\n        if (p !== j) {\n            for (k = 0; k < columns; k++) {\n                t = lu[p][k];\n                lu[p][k] = lu[j][k];\n                lu[j][k] = t;\n            }\n\n            v = pivotVector[p];\n            pivotVector[p] = pivotVector[j];\n            pivotVector[j] = v;\n\n            pivotSign = -pivotSign;\n        }\n\n        if (j < rows && lu[j][j] !== 0) {\n            for (i = j + 1; i < rows; i++) {\n                lu[i][j] /= lu[j][j];\n            }\n        }\n    }\n\n    this.LU = lu;\n    this.pivotVector = pivotVector;\n    this.pivotSign = pivotSign;\n}\n\nLuDecomposition.prototype = {\n    isSingular: function () {\n        var data = this.LU,\n            col = data.columns;\n        for (var j = 0; j < col; j++) {\n            if (data[j][j] === 0) {\n                return true;\n            }\n        }\n        return false;\n    },\n    get determinant() {\n        var data = this.LU;\n        if (!data.isSquare())\n            throw new Error('Matrix must be square');\n        var determinant = this.pivotSign, col = data.columns;\n        for (var j = 0; j < col; j++)\n            determinant *= data[j][j];\n        return determinant;\n    },\n    get lowerTriangularFactor() {\n        var data = this.LU,\n            rows = data.rows,\n            columns = data.columns,\n            X = new Matrix(rows, columns);\n        for (var i = 0; i < rows; i++) {\n            for (var j = 0; j < columns; j++) {\n                if (i > j) {\n                    X[i][j] = data[i][j];\n                } else if (i === j) {\n                    X[i][j] = 1;\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get upperTriangularFactor() {\n        var data = this.LU,\n            rows = data.rows,\n            columns = data.columns,\n            X = new Matrix(rows, columns);\n        for (var i = 0; i < rows; i++) {\n            for (var j = 0; j < columns; j++) {\n                if (i <= j) {\n                    X[i][j] = data[i][j];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get pivotPermutationVector() {\n        return this.pivotVector.slice();\n    },\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var lu = this.LU,\n            rows = lu.rows;\n\n        if (rows !== value.rows)\n            throw new Error('Invalid matrix dimensions');\n        if (this.isSingular())\n            throw new Error('LU matrix is singular');\n\n        var count = value.columns,\n            X = value.subMatrixRow(this.pivotVector, 0, count - 1),\n            columns = lu.columns,\n            i, j, k;\n\n        for (k = 0; k < columns; k++) {\n            for (i = k + 1; i < columns; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * lu[i][k];\n                }\n            }\n        }\n        for (k = columns - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                X[k][j] /= lu[k][k];\n            }\n            for (i = 0; i < k; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * lu[i][k];\n                }\n            }\n        }\n        return X;\n    }\n};\n\nmodule.exports = LuDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-curve-fitting/~/ml-matrix/src/dc/lu.js\n ** module id = 23\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\nvar hypotenuse = require('./util').hypotenuse;\n\n//https://github.com/lutzroeder/Mapack/blob/master/Source/QrDecomposition.cs\nfunction QrDecomposition(value) {\n    if (!(this instanceof QrDecomposition)) {\n        return new QrDecomposition(value);\n    }\n    value = Matrix.checkMatrix(value);\n\n    var qr = value.clone(),\n        m = value.rows,\n        n = value.columns,\n        rdiag = new Array(n),\n        i, j, k, s;\n\n    for (k = 0; k < n; k++) {\n        var nrm = 0;\n        for (i = k; i < m; i++) {\n            nrm = hypotenuse(nrm, qr[i][k]);\n        }\n        if (nrm !== 0) {\n            if (qr[k][k] < 0) {\n                nrm = -nrm;\n            }\n            for (i = k; i < m; i++) {\n                qr[i][k] /= nrm;\n            }\n            qr[k][k] += 1;\n            for (j = k + 1; j < n; j++) {\n                s = 0;\n                for (i = k; i < m; i++) {\n                    s += qr[i][k] * qr[i][j];\n                }\n                s = -s / qr[k][k];\n                for (i = k; i < m; i++) {\n                    qr[i][j] += s * qr[i][k];\n                }\n            }\n        }\n        rdiag[k] = -nrm;\n    }\n\n    this.QR = qr;\n    this.Rdiag = rdiag;\n}\n\nQrDecomposition.prototype = {\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var qr = this.QR,\n            m = qr.rows;\n\n        if (value.rows !== m)\n            throw new Error('Matrix row dimensions must agree');\n        if (!this.isFullRank())\n            throw new Error('Matrix is rank deficient');\n\n        var count = value.columns,\n            X = value.clone(),\n            n = qr.columns,\n            i, j, k, s;\n\n        for (k = 0; k < n; k++) {\n            for (j = 0; j < count; j++) {\n                s = 0;\n                for (i = k; i < m; i++) {\n                    s += qr[i][k] * X[i][j];\n                }\n                s = -s / qr[k][k];\n                for (i = k; i < m; i++) {\n                    X[i][j] += s * qr[i][k];\n                }\n            }\n        }\n        for (k = n - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                X[k][j] /= this.Rdiag[k];\n            }\n            for (i = 0; i < k; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * qr[i][k];\n                }\n            }\n        }\n\n        return X.subMatrix(0, n - 1, 0, count - 1);\n    },\n    isFullRank: function () {\n        var columns = this.QR.columns;\n        for (var i = 0; i < columns; i++) {\n            if (this.Rdiag[i] === 0) {\n                return false;\n            }\n        }\n        return true;\n    },\n    get upperTriangularFactor() {\n        var qr = this.QR,\n            n = qr.columns,\n            X = new Matrix(n, n),\n            i, j;\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                if (i < j) {\n                    X[i][j] = qr[i][j];\n                } else if (i === j) {\n                    X[i][j] = this.Rdiag[i];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get orthogonalFactor() {\n        var qr = this.QR,\n            rows = qr.rows,\n            columns = qr.columns,\n            X = new Matrix(rows, columns),\n            i, j, k, s;\n\n        for (k = columns - 1; k >= 0; k--) {\n            for (i = 0; i < rows; i++) {\n                X[i][k] = 0;\n            }\n            X[k][k] = 1;\n            for (j = k; j < columns; j++) {\n                if (qr[k][k] !== 0) {\n                    s = 0;\n                    for (i = k; i < rows; i++) {\n                        s += qr[i][k] * X[i][j];\n                    }\n\n                    s = -s / qr[k][k];\n\n                    for (i = k; i < rows; i++) {\n                        X[i][j] += s * qr[i][k];\n                    }\n                }\n            }\n        }\n        return X;\n    }\n};\n\nmodule.exports = QrDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-curve-fitting/~/ml-matrix/src/dc/qr.js\n ** module id = 24\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/CholeskyDecomposition.cs\nfunction CholeskyDecomposition(value) {\n    if (!(this instanceof CholeskyDecomposition)) {\n        return new CholeskyDecomposition(value);\n    }\n    value = Matrix.checkMatrix(value);\n    if (!value.isSymmetric())\n        throw new Error('Matrix is not symmetric');\n\n    var a = value,\n        dimension = a.rows,\n        l = new Matrix(dimension, dimension),\n        positiveDefinite = true,\n        i, j, k;\n\n    for (j = 0; j < dimension; j++) {\n        var Lrowj = l[j];\n        var d = 0;\n        for (k = 0; k < j; k++) {\n            var Lrowk = l[k];\n            var s = 0;\n            for (i = 0; i < k; i++) {\n                s += Lrowk[i] * Lrowj[i];\n            }\n            Lrowj[k] = s = (a[j][k] - s) / l[k][k];\n            d = d + s * s;\n        }\n\n        d = a[j][j] - d;\n\n        positiveDefinite &= (d > 0);\n        l[j][j] = Math.sqrt(Math.max(d, 0));\n        for (k = j + 1; k < dimension; k++) {\n            l[j][k] = 0;\n        }\n    }\n\n    if (!positiveDefinite) {\n        throw new Error('Matrix is not positive definite');\n    }\n\n    this.L = l;\n}\n\nCholeskyDecomposition.prototype = {\n    get leftTriangularFactor() {\n        return this.L;\n    },\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var l = this.L,\n            dimension = l.rows;\n\n        if (value.rows !== dimension) {\n            throw new Error('Matrix dimensions do not match');\n        }\n\n        var count = value.columns,\n            B = value.clone(),\n            i, j, k;\n\n        for (k = 0; k < dimension; k++) {\n            for (j = 0; j < count; j++) {\n                for (i = 0; i < k; i++) {\n                    B[k][j] -= B[i][j] * l[k][i];\n                }\n                B[k][j] /= l[k][k];\n            }\n        }\n\n        for (k = dimension - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                for (i = k + 1; i < dimension; i++) {\n                    B[k][j] -= B[i][j] * l[i][k];\n                }\n                B[k][j] /= l[k][k];\n            }\n        }\n\n        return B;\n    }\n};\n\nmodule.exports = CholeskyDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-curve-fitting/~/ml-matrix/src/dc/cholesky.js\n ** module id = 25\n ** module chunks = 0\n **/","/**\n * Created by acastillo on 8/24/15.\n */\n/**\n * Non in-place function definitions, compatible with mathjs code *\n */\n\n'use strict';\n\nvar Matrix = require('ml-matrix');\n\nfunction matrix(A,B){\n    return new Matrix(A,B);\n}\n\nfunction ones(rows, cols){\n    return Matrix.ones(rows,cols);\n}\n\nfunction eye(rows, cols){\n    return Matrix.eye(rows, cols);\n}\n\nfunction zeros(rows, cols){\n    return Matrix.zeros(rows, cols);\n}\n\nfunction random(rows, cols){\n    return Matrix.rand(rows,cols);\n}\n\nfunction transpose(A){\n    if(typeof A == 'number')\n        return A;\n    var result = A.clone();\n    return result.transpose();\n}\n\nfunction add(A, B){\n    if(typeof A == 'number'&&typeof B === 'number')\n        return A+B;\n    if(typeof A == 'number')\n        return this.add(B,A);\n\n    var result = A.clone();\n    return result.add(B);\n\n}\n\nfunction subtract(A, B){\n    if(typeof A == 'number'&&typeof B === 'number')\n        return A-B;\n    if(typeof A == 'number')\n        return this.subtract(B,A);\n    var result = A.clone();\n    return result.sub(B);\n}\n\nfunction multiply(A, B){\n    if(typeof A == 'number'&&typeof B === 'number')\n        return A*B;\n    if(typeof A == 'number')\n        return this.multiply(B,A);\n\n    var result = A.clone();\n\n    if(typeof B === 'number')\n        result.mul(B);\n    else\n        result = result.mmul(B);\n\n    if(result.rows==1&&result.columns==1)\n        return result[0][0];\n    else\n        return result;\n\n}\n\nfunction dotMultiply(A, B){\n    var result = A.clone();\n    return result.mul(B);\n}\n\nfunction dotDivide(A, B){\n    var result = A.clone();\n    return result.div(B);\n}\n\nfunction diag(A){\n    var diag = null;\n    var rows = A.rows, cols = A.columns, j, r;\n    //It is an array\n    if(typeof cols === \"undefined\" && (typeof A)=='object'){\n        if(A[0]&&A[0].length){\n            rows = A.length;\n            cols = A[0].length;\n            r = Math.min(rows,cols);\n            diag = Matrix.zeros(cols, cols);\n            for (j = 0; j < cols; j++) {\n                diag[j][j]=A[j][j];\n            }\n        }\n        else{\n            cols = A.length;\n            diag = Matrix.zeros(cols, cols);\n            for (j = 0; j < cols; j++) {\n                diag[j][j]=A[j];\n            }\n        }\n\n    }\n    if(rows == 1){\n        diag = Matrix.zeros(cols, cols);\n        for (j = 0; j < cols; j++) {\n            diag[j][j]=A[0][j];\n        }\n    }\n    else{\n        if(rows>0 && cols > 0){\n            r = Math.min(rows,cols);\n            diag = new Array(r);\n            for (j = 0; j < r; j++) {\n                diag[j] = A[j][j];\n            }\n        }\n    }\n    return diag;\n}\n\nfunction min(A, B){\n    if(typeof A==='number' && typeof B ==='number')\n        return Math.min(A,B);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (A[i][j] < B[i][j]) {\n                result[i][j] = A[i][j];\n            }\n            else{\n                result[i][j] = B[i][j];\n            }\n        }\n    }\n    return result;\n}\n\nfunction max(A, B){\n    if(typeof A==='number' && typeof B ==='number')\n        return Math.max(A,B);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (A[i][j] > B[i][j]) {\n                result[i][j] = A[i][j];\n            }\n            else{\n                result[i][j] = B[i][j];\n            }\n        }\n    }\n    return result;\n}\n\nfunction sqrt(A){\n    if(typeof A==='number' )\n        return Math.sqrt(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.sqrt(A[i][j]);\n\n        }\n    }\n    return result;\n}\n\nfunction abs(A){\n    if(typeof A==='number' )\n        return Math.abs(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.abs(A[i][j]);\n\n        }\n    }\n    return result;\n}\n\nfunction exp(A){\n    if(typeof A==='number' )\n        return Math.sqrt(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.exp(A[i][j]);\n        }\n    }\n    return result;\n}\n\nfunction dotPow(A, b){\n    if(typeof A==='number' )\n        return Math.pow(A,b);\n    //console.log(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.pow(A[i][j],b);\n        }\n    }\n    return result;\n}\n\nfunction solve(A, B){\n    return A.solve(B);\n}\n\nfunction inv(A){\n    if(typeof A ===\"number\")\n        return 1/A;\n    return A.inverse();\n}\n\nmodule.exports = {\n    transpose:transpose,\n    add:add,\n    subtract:subtract,\n    multiply:multiply,\n    dotMultiply:dotMultiply,\n    dotDivide:dotDivide,\n    diag:diag,\n    min:min,\n    max:max,\n    solve:solve,\n    inv:inv,\n    sqrt:sqrt,\n    exp:exp,\n    dotPow:dotPow,\n    abs:abs,\n    matrix:matrix,\n    ones:ones,\n    zeros:zeros,\n    random:random,\n    eye:eye\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-curve-fitting/src/algebra.js\n ** module id = 26\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = require('./matrix');\nmodule.exports.Decompositions = module.exports.DC = require('./decompositions');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-optimize-lorentzian/~/ml-matrix/src/index.js\n ** module id = 27\n ** module chunks = 0\n **/","'use strict';\n\nvar Asplice = Array.prototype.splice,\n    Aconcat = Array.prototype.concat;\n\n// For performance : http://jsperf.com/clone-array-slice-vs-while-vs-for\nfunction slice(arr) {\n    var i = 0,\n        ii = arr.length,\n        result = new Array(ii);\n    for (; i < ii; i++) {\n        result[i] = arr[i];\n    }\n    return result;\n}\n\n/**\n * Real matrix.\n * @constructor\n * @param {number|Array} nRows - Number of rows of the new matrix or a 2D array containing the data.\n * @param {number|boolean} [nColumns] - Number of columns of the new matrix or a boolean specifying if the input array should be cloned\n */\nfunction Matrix(nRows, nColumns) {\n    var i = 0, rows, columns, matrix, newInstance;\n    if (Array.isArray(nRows)) {\n        newInstance = nColumns;\n        matrix = newInstance ? slice(nRows) : nRows;\n        nRows = matrix.length;\n        nColumns = matrix[0].length;\n        if (typeof nColumns === 'undefined') {\n            throw new TypeError('Data must be a 2D array');\n        }\n        if (nRows > 0 && nColumns > 0) {\n            for (; i < nRows; i++) {\n                if (matrix[i].length !== nColumns) {\n                    throw new RangeError('Inconsistent array dimensions');\n                } else if (newInstance) {\n                    matrix[i] = slice(matrix[i]);\n                }\n            }\n        } else {\n            throw new RangeError('Invalid dimensions: ' + nRows + 'x' + nColumns);\n        }\n    } else if (typeof nRows === 'number') { // Create empty matrix\n        if (nRows > 0 && nColumns > 0) {\n            matrix = new Array(nRows);\n            for (; i < nRows; i++) {\n                matrix[i] = new Array(nColumns);\n            }\n        } else {\n            throw new RangeError('Invalid dimensions: ' + nRows + 'x' + nColumns);\n        }\n    } else {\n        throw new TypeError('Invalid arguments');\n    }\n\n    Object.defineProperty(matrix, 'rows', {writable: true, value: nRows});\n    Object.defineProperty(matrix, 'columns', {writable: true, value: nColumns});\n\n    matrix.__proto__ = Matrix.prototype;\n\n    return matrix;\n}\n\n/**\n * Constructs a Matrix with the chosen dimensions from a 1D array.\n * @param {number} newRows - Number of rows\n * @param {number} newColumns - Number of columns\n * @param {Array} newData - A 1D array containing data for the matrix\n * @returns {Matrix} - The new matrix\n */\nMatrix.from1DArray = function from1DArray(newRows, newColumns, newData) {\n    var length, data, i = 0;\n\n    length = newRows * newColumns;\n    if (length !== newData.length)\n        throw new RangeError('Data length does not match given dimensions');\n\n    data = new Array(newRows);\n    for (; i < newRows; i++) {\n        data[i] = newData.slice(i * newColumns, (i + 1) * newColumns);\n    }\n    return new Matrix(data);\n};\n\n/**\n * Creates a row vector, a matrix with only one row.\n * @param {Array} newData - A 1D array containing data for the vector\n * @returns {Matrix} - The new matrix\n */\nMatrix.rowVector = function rowVector(newData) {\n    return new Matrix([newData]);\n};\n\n/**\n * Creates a column vector, a matrix with only one column.\n * @param {Array} newData - A 1D array containing data for the vector\n * @returns {Matrix} - The new matrix\n */\nMatrix.columnVector = function columnVector(newData) {\n    var l = newData.length, vector = new Array(l);\n    for (var i = 0; i < l; i++)\n        vector[i] = [newData[i]];\n    return new Matrix(vector);\n};\n\n/**\n * Creates an empty matrix with the given dimensions. Values will be undefined. Same as using new Matrix(rows, columns).\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.empty = function empty(rows, columns) {\n    return new Matrix(rows, columns);\n};\n\n/**\n * Creates a matrix with the given dimensions. Values will be set to zero.\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.zeros = function zeros(rows, columns) {\n    return Matrix.empty(rows, columns).fill(0);\n};\n\n/**\n * Creates a matrix with the given dimensions. Values will be set to one.\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.ones = function ones(rows, columns) {\n    return Matrix.empty(rows, columns).fill(1);\n};\n\n/**\n * Creates a matrix with the given dimensions. Values will be randomly set using Math.random().\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} The new matrix\n */\nMatrix.rand = function rand(rows, columns) {\n    var matrix = Matrix.empty(rows, columns);\n    for (var i = 0, ii = matrix.rows; i < ii; i++) {\n        for (var j = 0, jj = matrix.columns; j < jj; j++) {\n            matrix[i][j] = Math.random();\n        }\n    }\n    return matrix;\n};\n\n/**\n * Creates an identity matrix with the given dimension. Values of the diagonal will be 1 and other will be 0.\n * @param {number} n - Number of rows and columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.eye = function eye(n) {\n    var matrix = Matrix.zeros(n, n), l = matrix.rows;\n    for (var i = 0; i < l; i++) {\n        matrix[i][i] = 1;\n    }\n    return matrix;\n};\n\n/**\n * Creates a diagonal matrix based on the given array.\n * @param {Array} data - Array containing the data for the diagonal\n * @returns {Matrix} - The new matrix\n */\nMatrix.diag = function diag(data) {\n    var l = data.length, matrix = Matrix.zeros(l, l);\n    for (var i = 0; i < l; i++) {\n        matrix[i][i] = data[i];\n    }\n    return matrix;\n};\n\n/**\n * Creates an array of indices between two values\n * @param {number} from\n * @param {number} to\n * @returns {Array}\n */\nMatrix.indices = function indices(from, to) {\n    var vector = new Array(to - from);\n    for (var i = 0; i < vector.length; i++)\n        vector[i] = from++;\n    return vector;\n};\n\n// TODO DOC\nMatrix.stack = function stack(arg1) {\n    var i, j, k;\n    if (Matrix.isMatrix(arg1)) {\n        var rows = 0,\n            cols = 0;\n        for (i = 0; i < arguments.length; i++) {\n            rows += arguments[i].rows;\n            if (arguments[i].columns > cols)\n                cols = arguments[i].columns;\n        }\n\n        var r = Matrix.zeros(rows, cols);\n        var c = 0;\n        for (i = 0; i < arguments.length; i++) {\n            var current = arguments[i];\n            for (j = 0; j < current.rows; j++) {\n                for (k = 0; k < current.columns; k++)\n                    r[c][k] = current[j][k];\n                c++;\n            }\n        }\n        return r;\n    }\n    else if (Array.isArray(arg1)) {\n        var matrix = Matrix.empty(arguments.length, arg1.length);\n        for (i = 0; i < arguments.length; i++)\n            matrix.setRow(i, arguments[i]);\n        return matrix;\n    }\n};\n\n// TODO DOC\nMatrix.expand = function expand(base, count) {\n    var expansion = [];\n    for (var i = 0; i < count.length; i++)\n        for (var j = 0; j < count[i]; j++)\n            expansion.push(base[i]);\n    return new Matrix(expansion);\n};\n\n/**\n * Check that the provided value is a Matrix and tries to instantiate one if not\n * @param value - The value to check\n * @returns {Matrix}\n * @throws {TypeError}\n */\nMatrix.checkMatrix = function checkMatrix(value) {\n    if (!value) {\n        throw new TypeError('Argument has to be a matrix');\n    }\n    if (value.klass !== 'Matrix') {\n        value = new Matrix(value);\n    }\n    return value;\n};\n\n/**\n * Returns true if the argument is a Matrix, false otherwise\n * @param value - The value to check\n * @returns {boolean}\n */\nMatrix.isMatrix = function isMatrix(value) {\n    return value ? value.klass === 'Matrix' : false;\n};\n\n/**\n * @property {string} - The name of this class.\n */\nObject.defineProperty(Matrix.prototype, 'klass', {\n    get: function klass() {\n        return 'Matrix';\n    }\n});\n\n/**\n * @property {number} - The number of elements in the matrix.\n */\nObject.defineProperty(Matrix.prototype, 'size', {\n    get: function size() {\n        return this.rows * this.columns;\n    }\n});\n\n/**\n * @private\n * Internal check that a row index is not out of bounds\n * @param {number} index\n */\nMatrix.prototype.checkRowIndex = function checkRowIndex(index) {\n    if (index < 0 || index > this.rows - 1)\n        throw new RangeError('Row index out of range.');\n};\n\n/**\n * @private\n * Internal check that a column index is not out of bounds\n * @param {number} index\n */\nMatrix.prototype.checkColumnIndex = function checkColumnIndex(index) {\n    if (index < 0 || index > this.columns - 1)\n        throw new RangeError('Column index out of range.');\n};\n\n/**\n * @private\n * Internal check that two matrices have the same dimensions\n * @param {Matrix} otherMatrix\n */\nMatrix.prototype.checkDimensions = function checkDimensions(otherMatrix) {\n    if ((this.rows !== otherMatrix.rows) || (this.columns !== otherMatrix.columns))\n        throw new RangeError('Matrices dimensions must be equal.');\n};\n\n/**\n * Applies a callback for each element of the matrix. The function is called in the matrix (this) context.\n * @param {function} callback - Function that will be called with two parameters : i (row) and j (column)\n * @returns {Matrix} this\n */\nMatrix.prototype.apply = function apply(callback) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            callback.call(this, i, j);\n        }\n    }\n    return this;\n};\n\n/**\n * Creates an exact and independent copy of the matrix\n * @returns {Matrix}\n */\nMatrix.prototype.clone = function clone() {\n    return new Matrix(this.to2DArray());\n};\n\n/**\n * Returns a new 1D array filled row by row with the matrix values\n * @returns {Array}\n */\nMatrix.prototype.to1DArray = function to1DArray() {\n    return Aconcat.apply([], this);\n};\n\n/**\n * Returns a 2D array containing a copy of the data\n * @returns {Array}\n */\nMatrix.prototype.to2DArray = function to2DArray() {\n    var l = this.rows, copy = new Array(l);\n    for (var i = 0; i < l; i++) {\n        copy[i] = slice(this[i]);\n    }\n    return copy;\n};\n\n/**\n * @returns {boolean} true if the matrix has one row\n */\nMatrix.prototype.isRowVector = function isRowVector() {\n    return this.rows === 1;\n};\n\n/**\n * @returns {boolean} true if the matrix has one column\n */\nMatrix.prototype.isColumnVector = function isColumnVector() {\n    return this.columns === 1;\n};\n\n/**\n * @returns {boolean} true if the matrix has one row or one column\n */\nMatrix.prototype.isVector = function isVector() {\n    return (this.rows === 1) || (this.columns === 1);\n};\n\n/**\n * @returns {boolean} true if the matrix has the same number of rows and columns\n */\nMatrix.prototype.isSquare = function isSquare() {\n    return this.rows === this.columns;\n};\n\n/**\n * @returns {boolean} true if the matrix is square and has the same values on both sides of the diagonal\n */\nMatrix.prototype.isSymmetric = function isSymmetric() {\n    if (this.isSquare()) {\n        var l = this.rows;\n        for (var i = 0; i < l; i++) {\n            for (var j = 0; j <= i; j++) {\n                if (this[i][j] !== this[j][i]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    return false;\n};\n\n/**\n * Sets a given element of the matrix. mat.set(3,4,1) is equivalent to mat[3][4]=1\n * @param {number} rowIndex - Index of the row\n * @param {number} columnIndex - Index of the column\n * @param {number} value - The new value for the element\n * @returns {Matrix} this\n */\nMatrix.prototype.set = function set(rowIndex, columnIndex, value) {\n    this[rowIndex][columnIndex] = value;\n    return this;\n};\n\n/**\n * Returns the given element of the matrix. mat.get(3,4) is equivalent to matrix[3][4]\n * @param {number} rowIndex - Index of the row\n * @param {number} columnIndex - Index of the column\n * @returns {number}\n */\nMatrix.prototype.get = function get(rowIndex, columnIndex) {\n    return this[rowIndex][columnIndex];\n};\n\n/**\n * Fills the matrix with a given value. All elements will be set to this value.\n * @param {number} value - New value\n * @returns {Matrix} this\n */\nMatrix.prototype.fill = function fill(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] = value;\n        }\n    }\n    return this;\n};\n\n/**\n * Negates the matrix. All elements will be multiplied by (-1)\n * @returns {Matrix} this\n */\nMatrix.prototype.neg = function neg() {\n    return this.mulS(-1);\n};\n\n/**\n * Adds a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.add = function add(value) {\n    if (typeof value === 'number')\n        return this.addS(value);\n    value = Matrix.checkMatrix(value);\n        return this.addM(value);\n};\n\n/**\n * Adds a scalar to each element of the matrix\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.addS = function addS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += value;\n        }\n    }\n    return this;\n};\n\n/**\n * Adds the value of each element of matrix to the corresponding element of this\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.addM = function addM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.sub = function sub(value) {\n    if (typeof value === 'number')\n        return this.subS(value);\n    value = Matrix.checkMatrix(value);\n        return this.subM(value);\n};\n\n/**\n * Subtracts a scalar from each element of the matrix\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.subS = function subS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= value;\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts the value of each element of matrix from the corresponding element of this\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.subM = function subM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mul = function mul(value) {\n    if (typeof value === 'number')\n        return this.mulS(value);\n    value = Matrix.checkMatrix(value);\n        return this.mulM(value);\n};\n\n/**\n * Multiplies a scalar with each element of the matrix\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mulS = function mulS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= value;\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the value of each element of matrix with the corresponding element of this\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.mulM = function mulM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Divides by a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.div = function div(value) {\n    if (typeof value === 'number')\n        return this.divS(value);\n    value = Matrix.checkMatrix(value);\n        return this.divM(value);\n};\n\n/**\n * Divides each element of the matrix by a scalar\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.divS = function divS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= value;\n        }\n    }\n    return this;\n};\n\n/**\n * Divides each element of this by the corresponding element of matrix\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.divM = function divM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Returns a new array from the given row index\n * @param {number} index - Row index\n * @returns {Array}\n */\nMatrix.prototype.getRow = function getRow(index) {\n    this.checkRowIndex(index);\n    return slice(this[index]);\n};\n\n/**\n * Returns a new row vector from the given row index\n * @param {number} index - Row index\n * @returns {Matrix}\n */\nMatrix.prototype.getRowVector = function getRowVector(index) {\n    return Matrix.rowVector(this.getRow(index));\n};\n\n/**\n * Sets a row at the given index\n * @param {number} index - Row index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.setRow = function setRow(index, array) {\n    this.checkRowIndex(index);\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    if (array.length !== this.columns)\n        throw new RangeError('Invalid row size');\n    this[index] = slice(array);\n    return this;\n};\n\n/**\n * Removes a row from the given index\n * @param {number} index - Row index\n * @returns {Matrix} this\n */\nMatrix.prototype.removeRow = function removeRow(index) {\n    this.checkRowIndex(index);\n    if (this.rows === 1)\n        throw new RangeError('A matrix cannot have less than one row');\n    Asplice.call(this, index, 1);\n    this.rows -= 1;\n    return this;\n};\n\n/**\n * Adds a row at the given index\n * @param {number} [index = this.rows] - Row index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addRow = function addRow(index, array) {\n    if (typeof array === 'undefined') {\n        array = index;\n        index = this.rows;\n    }\n    if (index < 0 || index > this.rows)\n        throw new RangeError('Row index out of range.');\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    if (array.length !== this.columns)\n        throw new RangeError('Invalid row size');\n    Asplice.call(this, index, 0, slice(array));\n    this.rows += 1;\n    return this;\n};\n\n/**\n * Swaps two rows\n * @param {number} row1 - First row index\n * @param {number} row2 - Second row index\n * @returns {Matrix} this\n */\nMatrix.prototype.swapRows = function swapRows(row1, row2) {\n    this.checkRowIndex(row1);\n    this.checkRowIndex(row2);\n    var temp = this[row1];\n    this[row1] = this[row2];\n    this[row2] = temp;\n    return this;\n};\n\n/**\n * Returns a new array from the given column index\n * @param {number} index - Column index\n * @returns {Array}\n */\nMatrix.prototype.getColumn = function getColumn(index) {\n    this.checkColumnIndex(index);\n    var l = this.rows, column = new Array(l);\n    for (var i = 0; i < l; i++) {\n        column[i] = this[i][index];\n    }\n    return column;\n};\n\n/**\n * Returns a new column vector from the given column index\n * @param {number} index - Column index\n * @returns {Matrix}\n */\nMatrix.prototype.getColumnVector = function getColumnVector(index) {\n    return Matrix.columnVector(this.getColumn(index));\n};\n\n/**\n * Sets a column at the given index\n * @param {number} index - Column index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.setColumn = function setColumn(index, array) {\n    this.checkColumnIndex(index);\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    var l = this.rows;\n    if (array.length !== l)\n        throw new RangeError('Invalid column size');\n    for (var i = 0; i < l; i++) {\n        this[i][index] = array[i];\n    }\n    return this;\n};\n\n/**\n * Removes a column from the given index\n * @param {number} index - Column index\n * @returns {Matrix} this\n */\nMatrix.prototype.removeColumn = function removeColumn(index) {\n    this.checkColumnIndex(index);\n    if (this.columns === 1)\n        throw new RangeError('A matrix cannot have less than one column');\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        this[i].splice(index, 1);\n    }\n    this.columns -= 1;\n    return this;\n};\n\n/**\n * Adds a column at the given index\n * @param {number} [index = this.columns] - Column index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addColumn = function addColumn(index, array) {\n    if (typeof array === 'undefined') {\n        array = index;\n        index = this.columns;\n    }\n    if (index < 0 || index > this.columns)\n        throw new RangeError('Column index out of range.');\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    var l = this.rows;\n    if (array.length !== l)\n        throw new RangeError('Invalid column size');\n    for (var i = 0; i < l; i++) {\n        this[i].splice(index, 0, array[i]);\n    }\n    this.columns += 1;\n    return this;\n};\n\n/**\n * Swaps two columns\n * @param {number} column1 - First column index\n * @param {number} column2 - Second column index\n * @returns {Matrix} this\n */\nMatrix.prototype.swapColumns = function swapColumns(column1, column2) {\n    this.checkRowIndex(column1);\n    this.checkRowIndex(column2);\n    var l = this.rows, temp, row;\n    for (var i = 0; i < l; i++) {\n        row = this[i];\n        temp = row[column1];\n        row[column1] = row[column2];\n        row[column2] = temp;\n    }\n    return this;\n};\n\n/**\n * @private\n * Internal check that the provided vector is an array with the right length\n * @param {Array|Matrix} vector\n * @returns {Array}\n * @throws {RangeError}\n */\nMatrix.prototype.checkRowVector = function checkRowVector(vector) {\n    if (Matrix.isMatrix(vector))\n        vector = vector.to1DArray();\n    if (vector.length !== this.columns)\n        throw new RangeError('vector size must be the same as the number of columns');\n    return vector;\n};\n\n/**\n * @private\n * Internal check that the provided vector is an array with the right length\n * @param {Array|Matrix} vector\n * @returns {Array}\n * @throws {RangeError}\n */\nMatrix.prototype.checkColumnVector = function checkColumnVector(vector) {\n    if (Matrix.isMatrix(vector))\n        vector = vector.to1DArray();\n    if (vector.length !== this.rows)\n        throw new RangeError('vector size must be the same as the number of rows');\n    return vector;\n};\n\n/**\n * Adds the values of a vector to each row\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addRowVector = function addRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts the values of a vector from each row\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.subRowVector = function subRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a vector with each row\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.mulRowVector = function mulRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Divides the values of each row by those of a vector\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.divRowVector = function divRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Adds the values of a vector to each column\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addColumnVector = function addColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts the values of a vector from each column\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.subColumnVector = function subColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a vector with each column\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.mulColumnVector = function mulColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Divides the values of each column by those of a vector\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.divColumnVector = function divColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a row with a scalar\n * @param {number} index - Row index\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mulRow = function mulRow(index, value) {\n    this.checkRowIndex(index);\n    var i = 0, l = this.columns;\n    for (; i < l; i++) {\n        this[index][i] *= value;\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a column with a scalar\n * @param {number} index - Column index\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mulColumn = function mulColumn(index, value) {\n    this.checkColumnIndex(index);\n    var i = 0, l = this.rows;\n    for (; i < l; i++) {\n        this[i][index] *= value;\n    }\n};\n\n/**\n * A matrix index\n * @typedef {Object} MatrixIndex\n * @property {number} row\n * @property {number} column\n */\n\n/**\n * Returns the maximum value of the matrix\n * @returns {number}\n */\nMatrix.prototype.max = function max() {\n    var v = -Infinity;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] > v) {\n                v = this[i][j];\n            }\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value\n * @returns {MatrixIndex}\n */\nMatrix.prototype.maxIndex = function maxIndex() {\n    var v = -Infinity;\n    var idx = {};\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] > v) {\n                v = this[i][j];\n                idx.row = i;\n                idx.column = j;\n            }\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the minimum value of the matrix\n * @returns {number}\n */\nMatrix.prototype.min = function min() {\n    var v = Infinity;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] < v) {\n                v = this[i][j];\n            }\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the minimum value\n * @returns {MatrixIndex}\n */\nMatrix.prototype.minIndex = function minIndex() {\n    var v = Infinity;\n    var idx = {};\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] < v) {\n                v = this[i][j];\n                idx.row = i;\n                idx.column = j;\n            }\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the maximum value of one row\n * @param {number} index - Row index\n * @returns {number}\n */\nMatrix.prototype.maxRow = function maxRow(index) {\n    this.checkRowIndex(index);\n    var v = -Infinity;\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] > v) {\n            v = this[index][i];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value of one row\n * @param {number} index - Row index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.maxRowIndex = function maxRowIndex(index) {\n    this.checkRowIndex(index);\n    var v = -Infinity;\n    var idx = {\n            row: index\n        };\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] > v) {\n            v = this[index][i];\n            idx.column = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the minimum value of one row\n * @param {number} index - Row index\n * @returns {number}\n */\nMatrix.prototype.minRow = function minRow(index) {\n    this.checkRowIndex(index);\n    var v = Infinity;\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] < v) {\n            v = this[index][i];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value of one row\n * @param {number} index - Row index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.minRowIndex = function minRowIndex(index) {\n    this.checkRowIndex(index);\n    var v = Infinity;\n    var idx = {\n        row: index,\n        column: 0\n    };\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] < v) {\n            v = this[index][i];\n            idx.column = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the maximum value of one column\n * @param {number} index - Column index\n * @returns {number}\n */\nMatrix.prototype.maxColumn = function maxColumn(index) {\n    this.checkColumnIndex(index);\n    var v = -Infinity;\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] > v) {\n            v = this[i][index];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value of one column\n * @param {number} index - Column index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.maxColumnIndex = function maxColumnIndex(index) {\n    this.checkColumnIndex(index);\n    var v = -Infinity;\n    var idx = {\n        row: 0,\n        column: index\n    };\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] > v) {\n            v = this[i][index];\n            idx.row = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the minimum value of one column\n * @param {number} index - Column index\n * @returns {number}\n */\nMatrix.prototype.minColumn = function minColumn(index) {\n    this.checkColumnIndex(index);\n    var v = Infinity;\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] < v) {\n            v = this[i][index];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the minimum value of one column\n * @param {number} index - Column index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.minColumnIndex = function minColumnIndex(index) {\n    this.checkColumnIndex(index);\n    var v = Infinity;\n    var idx = {\n        row: 0,\n        column: index\n    };\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] < v) {\n            v = this[i][index];\n            idx.row = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns an array containing the diagonal values of the matrix\n * @returns {Array}\n */\nMatrix.prototype.diag = function diag() {\n    if (!this.isSquare())\n        throw new TypeError('Only square matrices have a diagonal.');\n    var diag = new Array(this.rows);\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        diag[i] = this[i][i];\n    }\n    return diag;\n};\n\n/**\n * Returns the sum of all elements of the matrix\n * @returns {number}\n */\nMatrix.prototype.sum = function sum() {\n    var v = 0;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            v += this[i][j];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the mean of all elements of the matrix\n * @returns {number}\n */\nMatrix.prototype.mean = function mean() {\n    return this.sum() / this.size;\n};\n\n/**\n * Returns the product of all elements of the matrix\n * @returns {number}\n */\nMatrix.prototype.prod = function prod() {\n    var prod = 1;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            prod *= this[i][j];\n        }\n    }\n    return prod;\n};\n\n/**\n * Computes the cumulative sum of the matrix elements (in place, row by row)\n * @returns {Matrix} this\n */\nMatrix.prototype.cumulativeSum = function cumulativeSum() {\n    var sum = 0;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            sum += this[i][j];\n            this[i][j] = sum;\n        }\n    }\n    return this;\n};\n\n/**\n * Computes the dot (scalar) product between the matrix and another\n * @param {Matrix} other vector\n * @returns {number}\n */\nMatrix.prototype.dot = function dot(other) {\n    if (this.size !== other.size)\n        throw new RangeError('vectors do not have the same size');\n    var vector1 = this.to1DArray();\n    var vector2 = other.to1DArray();\n    var dot = 0, l = vector1.length;\n    for (var i = 0; i < l; i++) {\n        dot += vector1[i] * vector2[i];\n    }\n    return dot;\n};\n\n/**\n * Returns the matrix product between this and other\n * @returns {Matrix}\n */\nMatrix.prototype.mmul = function mmul(other) {\n    if (!Matrix.isMatrix(other))\n        throw new TypeError('parameter \"other\" must be a matrix');\n    if (this.columns !== other.rows)\n        console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');\n\n    var m = this.rows, n = this.columns, p = other.columns;\n    var result = new Matrix(m, p);\n\n    var Bcolj = new Array(n);\n    var i, j, k;\n    for (j = 0; j < p; j++) {\n        for (k = 0; k < n; k++)\n            Bcolj[k] = other[k][j];\n\n        for (i = 0; i < m; i++) {\n            var Arowi = this[i];\n\n            var s = 0;\n            for (k = 0; k < n; k++)\n                s += Arowi[k] * Bcolj[k];\n\n            result[i][j] = s;\n        }\n    }\n    return result;\n};\n\n/**\n * Sorts the rows (in place)\n * @param {function} compareFunction - usual Array.prototype.sort comparison function\n * @returns {Matrix} this\n */\nMatrix.prototype.sortRows = function sortRows(compareFunction) {\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        this[i].sort(compareFunction);\n    }\n    return this;\n};\n\n/**\n * Sorts the columns (in place)\n * @param {function} compareFunction - usual Array.prototype.sort comparison function\n * @returns {Matrix} this\n */\nMatrix.prototype.sortColumns = function sortColumns(compareFunction) {\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        this.setColumn(i, this.getColumn(i).sort(compareFunction));\n    }\n    return this;\n};\n\n/**\n * Transposes the matrix and returns a new one containing the result\n * @returns {Matrix}\n */\nMatrix.prototype.transpose = function transpose() {\n    var result = new Matrix(this.columns, this.rows);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[j][i] = this[i][j];\n        }\n    }\n    return result;\n};\n\n/**\n * Returns a subset of the matrix\n * @param {number} startRow - First row index\n * @param {number} endRow - Last row index\n * @param {number} startColumn - First column index\n * @param {number} endColumn - Last column index\n * @returns {Matrix}\n */\nMatrix.prototype.subMatrix = function subMatrix(startRow, endRow, startColumn, endColumn) {\n    if ((startRow > endRow) || (startColumn > endColumn) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns))\n        throw new RangeError('Argument out of range');\n    var newMatrix = new Matrix(endRow - startRow + 1, endColumn - startColumn + 1);\n    for (var i = startRow; i <= endRow; i++) {\n        for (var j = startColumn; j <= endColumn; j++) {\n            newMatrix[i - startRow][j - startColumn] = this[i][j];\n        }\n    }\n    return newMatrix;\n};\n\n/**\n * Returns a subset of the matrix based on an array of row indices\n * @param {Array} indices - Array containing the row indices\n * @param {number} [startColumn = 0] - First column index\n * @param {number} [endColumn = this.columns-1] - Last column index\n * @returns {Matrix}\n */\nMatrix.prototype.subMatrixRow = function subMatrixRow(indices, startColumn, endColumn) {\n    if (typeof startColumn === 'undefined') {\n        startColumn = 0;\n        endColumn = this.columns - 1;\n    } else if (typeof endColumn === 'undefined') {\n        endColumn = this.columns - 1;\n    }\n    if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns))\n        throw new RangeError('Argument out of range.');\n    var l = indices.length, rows = this.rows,\n        X = new Matrix(l, endColumn - startColumn + 1);\n    for (var i = 0; i < l; i++) {\n        for (var j = startColumn; j <= endColumn; j++) {\n            if ((indices[i] < 0) || (indices[i] >= rows))\n                throw new RangeError('Argument out of range.');\n            X[i][j - startColumn] = this[indices[i]][j];\n        }\n    }\n    return X;\n};\n\n/**\n * Returns a subset of the matrix based on an array of column indices\n * @param {Array} indices - Array containing the column indices\n * @param {number} [startRow = 0] - First row index\n * @param {number} [endRow = this.rows-1] - Last row index\n * @returns {Matrix}\n */\nMatrix.prototype.subMatrixColumn = function subMatrixColumn(indices, startRow, endRow) {\n    if (typeof startRow === 'undefined') {\n        startRow = 0;\n        endRow = this.rows - 1;\n    } else if (typeof endRow === 'undefined') {\n        endRow = this.rows - 1;\n    }\n    if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows))\n        throw new RangeError('Argument out of range.');\n    var l = indices.length, columns = this.columns,\n        X = new Matrix(endRow - startRow + 1, l);\n    for (var i = 0; i < l; i++) {\n        for (var j = startRow; j <= endRow; j++) {\n            if ((indices[i] < 0) || (indices[i] >= columns))\n                throw new RangeError('Argument out of range.');\n            X[j - startRow][i] = this[j][indices[i]];\n        }\n    }\n    return X;\n};\n\n/**\n * Returns the trace of the matrix (sum of the diagonal elements)\n * @returns {number}\n */\nMatrix.prototype.trace = function trace() {\n    if (!this.isSquare())\n        throw new TypeError('The matrix is not square');\n    var trace = 0, i = 0, l = this.rows;\n    for (; i < l; i++) {\n        trace += this[i][i];\n    }\n    return trace;\n};\n\n/**\n * Sets each element of the matrix to its absolute value\n * @returns {Matrix} this\n */\nMatrix.prototype.abs = function abs() {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] = Math.abs(this[i][j]);\n        }\n    }\n};\n\nmodule.exports = Matrix;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-optimize-lorentzian/~/ml-matrix/src/matrix.js\n ** module id = 28\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('./matrix');\n\nvar SingularValueDecomposition = require('./dc/svd');\nvar EigenvalueDecomposition = require('./dc/evd');\nvar LuDecomposition = require('./dc/lu');\nvar QrDecomposition = require('./dc/qr');\nvar CholeskyDecomposition = require('./dc/cholesky');\n\nfunction inverse(matrix) {\n    return solve(matrix, Matrix.eye(matrix.rows));\n}\n\nMatrix.prototype.inverse = function () {\n    return inverse(this);\n};\n\nfunction solve(leftHandSide, rightHandSide) {\n    return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).solve(rightHandSide);\n}\n\nMatrix.prototype.solve = function (other) {\n    return solve(this, other);\n};\n\nmodule.exports = {\n    SingularValueDecomposition: SingularValueDecomposition,\n    SVD: SingularValueDecomposition,\n    EigenvalueDecomposition: EigenvalueDecomposition,\n    EVD: EigenvalueDecomposition,\n    LuDecomposition: LuDecomposition,\n    LU: LuDecomposition,\n    QrDecomposition: QrDecomposition,\n    QR: QrDecomposition,\n    CholeskyDecomposition: CholeskyDecomposition,\n    CHO: CholeskyDecomposition,\n    inverse: inverse,\n    solve: solve\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-optimize-lorentzian/~/ml-matrix/src/decompositions.js\n ** module id = 29\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\nvar hypotenuse = require('./util').hypotenuse;\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/SingularValueDecomposition.cs\nfunction SingularValueDecomposition(value, options) {\n    if (!(this instanceof SingularValueDecomposition)) {\n        return new SingularValueDecomposition(value, options);\n    }\n    value = Matrix.checkMatrix(value);\n\n    options = options || {};\n\n    var a = value.clone(),\n        m = value.rows,\n        n = value.columns,\n        nu = Math.min(m, n);\n\n    var wantu = true, wantv = true;\n    if (options.computeLeftSingularVectors === false)\n        wantu = false;\n    if (options.computeRightSingularVectors === false)\n        wantv = false;\n    var autoTranspose = options.autoTranspose === true;\n\n    var swapped = false;\n    if (m < n) {\n        if (!autoTranspose) {\n            console.warn('Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose');\n        } else {\n            a = a.transpose();\n            m = a.rows;\n            n = a.columns;\n            swapped = true;\n            var aux = wantu;\n            wantu = wantv;\n            wantv = aux;\n        }\n    }\n\n    var s = new Array(Math.min(m + 1, n)),\n        U = Matrix.zeros(m, nu),\n        V = Matrix.zeros(n, n),\n        e = new Array(n),\n        work = new Array(m);\n\n    var nct = Math.min(m - 1, n);\n    var nrt = Math.max(0, Math.min(n - 2, m));\n\n    var i, j, k, p, t, ks, f, cs, sn, max, kase,\n        scale, sp, spm1, epm1, sk, ek, b, c, shift, g;\n\n    for (k = 0, max = Math.max(nct, nrt); k < max; k++) {\n        if (k < nct) {\n            s[k] = 0;\n            for (i = k; i < m; i++) {\n                s[k] = hypotenuse(s[k], a[i][k]);\n            }\n            if (s[k] !== 0) {\n                if (a[k][k] < 0) {\n                    s[k] = -s[k];\n                }\n                for (i = k; i < m; i++) {\n                    a[i][k] /= s[k];\n                }\n                a[k][k] += 1;\n            }\n            s[k] = -s[k];\n        }\n\n        for (j = k + 1; j < n; j++) {\n            if ((k < nct) && (s[k] !== 0)) {\n                t = 0;\n                for (i = k; i < m; i++) {\n                    t += a[i][k] * a[i][j];\n                }\n                t = -t / a[k][k];\n                for (i = k; i < m; i++) {\n                    a[i][j] += t * a[i][k];\n                }\n            }\n            e[j] = a[k][j];\n        }\n\n        if (wantu && (k < nct)) {\n            for (i = k; i < m; i++) {\n                U[i][k] = a[i][k];\n            }\n        }\n\n        if (k < nrt) {\n            e[k] = 0;\n            for (i = k + 1; i < n; i++) {\n                e[k] = hypotenuse(e[k], e[i]);\n            }\n            if (e[k] !== 0) {\n                if (e[k + 1] < 0)\n                    e[k] = -e[k];\n                for (i = k + 1; i < n; i++) {\n                    e[i] /= e[k];\n                }\n                e[k + 1] += 1;\n            }\n            e[k] = -e[k];\n            if ((k + 1 < m) && (e[k] !== 0)) {\n                for (i = k + 1; i < m; i++) {\n                    work[i] = 0;\n                }\n                for (j = k + 1; j < n; j++) {\n                    for (i = k + 1; i < m; i++) {\n                        work[i] += e[j] * a[i][j];\n                    }\n                }\n                for (j = k + 1; j < n; j++) {\n                    t = -e[j] / e[k + 1];\n                    for (i = k + 1; i < m; i++) {\n                        a[i][j] += t * work[i];\n                    }\n                }\n            }\n            if (wantv) {\n                for (i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n    }\n\n    p = Math.min(n, m + 1);\n    if (nct < n) {\n        s[nct] = a[nct][nct];\n    }\n    if (m < p) {\n        s[p - 1] = 0;\n    }\n    if (nrt + 1 < p) {\n        e[nrt] = a[nrt][p - 1];\n    }\n    e[p - 1] = 0;\n\n    if (wantu) {\n        for (j = nct; j < nu; j++) {\n            for (i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (k = nct - 1; k >= 0; k--) {\n            if (s[k] !== 0) {\n                for (j = k + 1; j < nu; j++) {\n                    t = 0;\n                    for (i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n    }\n\n    if (wantv) {\n        for (k = n - 1; k >= 0; k--) {\n            if ((k < nrt) && (e[k] !== 0)) {\n                for (j = k + 1; j < n; j++) {\n                    t = 0;\n                    for (i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n    }\n\n    var pp = p - 1,\n        iter = 0,\n        eps = Math.pow(2, -52);\n    while (p > 0) {\n        for (k = p - 2; k >= -1; k--) {\n            if (k === -1) {\n                break;\n            }\n            if (Math.abs(e[k]) <= eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {\n                e[k] = 0;\n                break;\n            }\n        }\n        if (k === p - 2) {\n            kase = 4;\n        } else {\n            for (ks = p - 1; ks >= k; ks--) {\n                if (ks === k) {\n                    break;\n                }\n                t = (ks !== p ? Math.abs(e[ks]) : 0) + (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);\n                if (Math.abs(s[ks]) <= eps * t) {\n                    s[ks] = 0;\n                    break;\n                }\n            }\n            if (ks === k) {\n                kase = 3;\n            } else if (ks === p - 1) {\n                kase = 1;\n            } else {\n                kase = 2;\n                k = ks;\n            }\n        }\n\n        k++;\n\n        switch (kase) {\n            case 1: {\n                f = e[p - 2];\n                e[p - 2] = 0;\n                for (j = p - 2; j >= k; j--) {\n                    t = hypotenuse(s[j], f);\n                    cs = s[j] / t;\n                    sn = f / t;\n                    s[j] = t;\n                    if (j !== k) {\n                        f = -sn * e[j - 1];\n                        e[j - 1] = cs * e[j - 1];\n                    }\n                    if (wantv) {\n                        for (i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n            }\n            case 2 : {\n                f = e[k - 1];\n                e[k - 1] = 0;\n                for (j = k; j < p; j++) {\n                    t = hypotenuse(s[j], f);\n                    cs = s[j] / t;\n                    sn = f / t;\n                    s[j] = t;\n                    f = -sn * e[j];\n                    e[j] = cs * e[j];\n                    if (wantu) {\n                        for (i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n            }\n            case 3 : {\n                scale = Math.max(Math.max(Math.max(Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2])), Math.abs(e[p - 2])), Math.abs(s[k])), Math.abs(e[k]));\n                sp = s[p - 1] / scale;\n                spm1 = s[p - 2] / scale;\n                epm1 = e[p - 2] / scale;\n                sk = s[k] / scale;\n                ek = e[k] / scale;\n                b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;\n                c = (sp * epm1) * (sp * epm1);\n                shift = 0;\n                if ((b !== 0) || (c !== 0)) {\n                    shift = Math.sqrt(b * b + c);\n                    if (b < 0) {\n                        shift = -shift;\n                    }\n                    shift = c / (b + shift);\n                }\n                f = (sk + sp) * (sk - sp) + shift;\n                g = sk * ek;\n                for (j = k; j < p - 1; j++) {\n                    t = hypotenuse(f, g);\n                    cs = f / t;\n                    sn = g / t;\n                    if (j !== k) {\n                        e[j - 1] = t;\n                    }\n                    f = cs * s[j] + sn * e[j];\n                    e[j] = cs * e[j] - sn * s[j];\n                    g = sn * s[j + 1];\n                    s[j + 1] = cs * s[j + 1];\n                    if (wantv) {\n                        for (i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                    }\n                    t = hypotenuse(f, g);\n                    cs = f / t;\n                    sn = g / t;\n                    s[j] = t;\n                    f = cs * e[j] + sn * s[j + 1];\n                    s[j + 1] = -sn * e[j] + cs * s[j + 1];\n                    g = sn * e[j + 1];\n                    e[j + 1] = cs * e[j + 1];\n                    if (wantu && (j < m - 1)) {\n                        for (i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][j + 1];\n                            U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                e[p - 2] = f;\n                iter = iter + 1;\n                break;\n            }\n            case 4: {\n                if (s[k] <= 0) {\n                    s[k] = (s[k] < 0 ? -s[k] : 0);\n                    if (wantv) {\n                        for (i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                }\n                while (k < pp) {\n                    if (s[k] >= s[k + 1]) {\n                        break;\n                    }\n                    t = s[k];\n                    s[k] = s[k + 1];\n                    s[k + 1] = t;\n                    if (wantv && (k < n - 1)) {\n                        for (i = 0; i < n; i++) {\n                            t = V[i][k + 1];\n                            V[i][k + 1] = V[i][k];\n                            V[i][k] = t;\n                        }\n                    }\n                    if (wantu && (k < m - 1)) {\n                        for (i = 0; i < m; i++) {\n                            t = U[i][k + 1];\n                            U[i][k + 1] = U[i][k];\n                            U[i][k] = t;\n                        }\n                    }\n                    k++;\n                }\n                iter = 0;\n                p--;\n                break;\n            }\n        }\n    }\n\n    if (swapped) {\n        var tmp = V;\n        V = U;\n        U = tmp;\n    }\n\n    this.m = m;\n    this.n = n;\n    this.s = s;\n    this.U = U;\n    this.V = V;\n}\n\nSingularValueDecomposition.prototype = {\n    get condition() {\n        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];\n    },\n    get norm2() {\n        return this.s[0];\n    },\n    get rank() {\n        var eps = Math.pow(2, -52),\n            tol = Math.max(this.m, this.n) * this.s[0] * eps,\n            r = 0,\n            s = this.s;\n        for (var i = 0, ii = s.length; i < ii; i++) {\n            if (s[i] > tol) {\n                r++;\n            }\n        }\n        return r;\n    },\n    get diagonal() {\n        return this.s;\n    },\n    // https://github.com/accord-net/framework/blob/development/Sources/Accord.Math/Decompositions/SingularValueDecomposition.cs\n    get threshold() {\n        return (Math.pow(2, -52) / 2) * Math.max(this.m, this.n) * this.s[0];\n    },\n    get leftSingularVectors() {\n        return this.U;\n    },\n    get rightSingularVectors() {\n        return this.V;\n    },\n    get diagonalMatrix() {\n        return Matrix.diag(this.s);\n    },\n    solve: function (value) {\n\n        var Y = value,\n            e = this.threshold,\n            scols = this.s.length,\n            Ls = Matrix.zeros(scols, scols),\n            i;\n\n        for (i = 0; i < scols; i++) {\n            if (Math.abs(this.s[i]) <= e) {\n                Ls[i][i] = 0;\n            } else {\n                Ls[i][i] = 1 / this.s[i];\n            }\n        }\n\n\n        var VL = this.V.mmul(Ls),\n            vrows = this.V.rows,\n            urows = this.U.rows,\n            VLU = Matrix.zeros(vrows, urows),\n            j, k, sum;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < urows; j++) {\n                sum = 0;\n                for (k = 0; k < scols; k++) {\n                    sum += VL[i][k] * this.U[j][k];\n                }\n                VLU[i][j] = sum;\n            }\n        }\n\n        return VLU.mmul(Y);\n    },\n    solveForDiagonal: function (value) {\n        return this.solve(Matrix.diag(value));\n    },\n    inverse: function () {\n        var e = this.threshold,\n            vrows = this.V.rows,\n            vcols = this.V.columns,\n            X = new Matrix(vrows, this.s.length),\n            i, j;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < vcols; j++) {\n                if (Math.abs(this.s[j]) > e) {\n                    X[i][j] = this.V[i][j] / this.s[j];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n\n        var urows = this.U.rows,\n            ucols = this.U.columns,\n            Y = new Matrix(vrows, urows),\n            k, sum;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < urows; j++) {\n                sum = 0;\n                for (k = 0; k < ucols; k++) {\n                    sum += X[i][k] * this.U[j][k];\n                }\n                Y[i][j] = sum;\n            }\n        }\n\n        return Y;\n    }\n};\n\nmodule.exports = SingularValueDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-optimize-lorentzian/~/ml-matrix/src/dc/svd.js\n ** module id = 30\n ** module chunks = 0\n **/","'use strict';\n\nexports.hypotenuse = function hypotenuse(a, b) {\n    var r;\n    if (Math.abs(a) > Math.abs(b)) {\n        r = b / a;\n        return Math.abs(a) * Math.sqrt(1 + r * r);\n    }\n    if (b !== 0) {\n        r = a / b;\n        return Math.abs(b) * Math.sqrt(1 + r * r);\n    }\n    return 0;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-optimize-lorentzian/~/ml-matrix/src/dc/util.js\n ** module id = 31\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\nvar hypotenuse = require('./util').hypotenuse;\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/EigenvalueDecomposition.cs\nfunction EigenvalueDecomposition(matrix) {\n    if (!(this instanceof EigenvalueDecomposition)) {\n        return new EigenvalueDecomposition(matrix);\n    }\n    matrix = Matrix.checkMatrix(matrix);\n    if (!matrix.isSquare()) {\n        throw new Error('Matrix is not a square matrix');\n    }\n\n    var n = matrix.columns,\n        V = Matrix.zeros(n, n),\n        d = new Array(n),\n        e = new Array(n),\n        value = matrix,\n        i, j;\n\n    if (matrix.isSymmetric()) {\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                V[i][j] = value[i][j];\n            }\n        }\n        tred2(n, e, d, V);\n        tql2(n, e, d, V);\n    }\n    else {\n        var H = Matrix.zeros(n, n),\n            ort = new Array(n);\n        for (j = 0; j < n; j++) {\n            for (i = 0; i < n; i++) {\n                H[i][j] = value[i][j];\n            }\n        }\n        orthes(n, H, ort, V);\n        hqr2(n, e, d, V, H);\n    }\n\n    this.n = n;\n    this.e = e;\n    this.d = d;\n    this.V = V;\n}\n\nEigenvalueDecomposition.prototype = {\n    get realEigenvalues() {\n        return this.d;\n    },\n    get imaginaryEigenvalues() {\n        return this.e;\n    },\n    get eigenvectorMatrix() {\n        return this.V;\n    },\n    get diagonalMatrix() {\n        var n = this.n,\n            e = this.e,\n            d = this.d,\n            X = new Matrix(n, n),\n            i, j;\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                X[i][j] = 0;\n            }\n            X[i][i] = d[i];\n            if (e[i] > 0) {\n                X[i][i + 1] = e[i];\n            }\n            else if (e[i] < 0) {\n                X[i][i - 1] = e[i];\n            }\n        }\n        return X;\n    }\n};\n\nfunction tred2(n, e, d, V) {\n\n    var f, g, h, i, j, k,\n        hh, scale;\n\n    for (j = 0; j < n; j++) {\n        d[j] = V[n - 1][j];\n    }\n\n    for (i = n - 1; i > 0; i--) {\n        scale = 0;\n        h = 0;\n        for (k = 0; k < i; k++) {\n            scale = scale + Math.abs(d[k]);\n        }\n\n        if (scale === 0) {\n            e[i] = d[i - 1];\n            for (j = 0; j < i; j++) {\n                d[j] = V[i - 1][j];\n                V[i][j] = 0;\n                V[j][i] = 0;\n            }\n        } else {\n            for (k = 0; k < i; k++) {\n                d[k] /= scale;\n                h += d[k] * d[k];\n            }\n\n            f = d[i - 1];\n            g = Math.sqrt(h);\n            if (f > 0) {\n                g = -g;\n            }\n\n            e[i] = scale * g;\n            h = h - f * g;\n            d[i - 1] = f - g;\n            for (j = 0; j < i; j++) {\n                e[j] = 0;\n            }\n\n            for (j = 0; j < i; j++) {\n                f = d[j];\n                V[j][i] = f;\n                g = e[j] + V[j][j] * f;\n                for (k = j + 1; k <= i - 1; k++) {\n                    g += V[k][j] * d[k];\n                    e[k] += V[k][j] * f;\n                }\n                e[j] = g;\n            }\n\n            f = 0;\n            for (j = 0; j < i; j++) {\n                e[j] /= h;\n                f += e[j] * d[j];\n            }\n\n            hh = f / (h + h);\n            for (j = 0; j < i; j++) {\n                e[j] -= hh * d[j];\n            }\n\n            for (j = 0; j < i; j++) {\n                f = d[j];\n                g = e[j];\n                for (k = j; k <= i - 1; k++) {\n                    V[k][j] -= (f * e[k] + g * d[k]);\n                }\n                d[j] = V[i - 1][j];\n                V[i][j] = 0;\n            }\n        }\n        d[i] = h;\n    }\n\n    for (i = 0; i < n - 1; i++) {\n        V[n - 1][i] = V[i][i];\n        V[i][i] = 1;\n        h = d[i + 1];\n        if (h !== 0) {\n            for (k = 0; k <= i; k++) {\n                d[k] = V[k][i + 1] / h;\n            }\n\n            for (j = 0; j <= i; j++) {\n                g = 0;\n                for (k = 0; k <= i; k++) {\n                    g += V[k][i + 1] * V[k][j];\n                }\n                for (k = 0; k <= i; k++) {\n                    V[k][j] -= g * d[k];\n                }\n            }\n        }\n\n        for (k = 0; k <= i; k++) {\n            V[k][i + 1] = 0;\n        }\n    }\n\n    for (j = 0; j < n; j++) {\n        d[j] = V[n - 1][j];\n        V[n - 1][j] = 0;\n    }\n\n    V[n - 1][n - 1] = 1;\n    e[0] = 0;\n}\n\nfunction tql2(n, e, d, V) {\n\n    var g, h, i, j, k, l, m, p, r,\n        dl1, c, c2, c3, el1, s, s2,\n        iter;\n\n    for (i = 1; i < n; i++) {\n        e[i - 1] = e[i];\n    }\n\n    e[n - 1] = 0;\n\n    var f = 0,\n        tst1 = 0,\n        eps = Math.pow(2, -52);\n\n    for (l = 0; l < n; l++) {\n        tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));\n        m = l;\n        while (m < n) {\n            if (Math.abs(e[m]) <= eps * tst1) {\n                break;\n            }\n            m++;\n        }\n\n        if (m > l) {\n            iter = 0;\n            do {\n                iter = iter + 1;\n\n                g = d[l];\n                p = (d[l + 1] - g) / (2 * e[l]);\n                r = hypotenuse(p, 1);\n                if (p < 0) {\n                    r = -r;\n                }\n\n                d[l] = e[l] / (p + r);\n                d[l + 1] = e[l] * (p + r);\n                dl1 = d[l + 1];\n                h = g - d[l];\n                for (i = l + 2; i < n; i++) {\n                    d[i] -= h;\n                }\n\n                f = f + h;\n\n                p = d[m];\n                c = 1;\n                c2 = c;\n                c3 = c;\n                el1 = e[l + 1];\n                s = 0;\n                s2 = 0;\n                for (i = m - 1; i >= l; i--) {\n                    c3 = c2;\n                    c2 = c;\n                    s2 = s;\n                    g = c * e[i];\n                    h = c * p;\n                    r = hypotenuse(p, e[i]);\n                    e[i + 1] = s * r;\n                    s = e[i] / r;\n                    c = p / r;\n                    p = c * d[i] - s * g;\n                    d[i + 1] = h + s * (c * g + s * d[i]);\n\n                    for (k = 0; k < n; k++) {\n                        h = V[k][i + 1];\n                        V[k][i + 1] = s * V[k][i] + c * h;\n                        V[k][i] = c * V[k][i] - s * h;\n                    }\n                }\n\n                p = -s * s2 * c3 * el1 * e[l] / dl1;\n                e[l] = s * p;\n                d[l] = c * p;\n\n            }\n            while (Math.abs(e[l]) > eps * tst1);\n        }\n        d[l] = d[l] + f;\n        e[l] = 0;\n    }\n\n    for (i = 0; i < n - 1; i++) {\n        k = i;\n        p = d[i];\n        for (j = i + 1; j < n; j++) {\n            if (d[j] < p) {\n                k = j;\n                p = d[j];\n            }\n        }\n\n        if (k !== i) {\n            d[k] = d[i];\n            d[i] = p;\n            for (j = 0; j < n; j++) {\n                p = V[j][i];\n                V[j][i] = V[j][k];\n                V[j][k] = p;\n            }\n        }\n    }\n}\n\nfunction orthes(n, H, ort, V) {\n\n    var low = 0,\n        high = n - 1,\n        f, g, h, i, j, m,\n        scale;\n\n    for (m = low + 1; m <= high - 1; m++) {\n        scale = 0;\n        for (i = m; i <= high; i++) {\n            scale = scale + Math.abs(H[i][m - 1]);\n        }\n\n        if (scale !== 0) {\n            h = 0;\n            for (i = high; i >= m; i--) {\n                ort[i] = H[i][m - 1] / scale;\n                h += ort[i] * ort[i];\n            }\n\n            g = Math.sqrt(h);\n            if (ort[m] > 0) {\n                g = -g;\n            }\n\n            h = h - ort[m] * g;\n            ort[m] = ort[m] - g;\n\n            for (j = m; j < n; j++) {\n                f = 0;\n                for (i = high; i >= m; i--) {\n                    f += ort[i] * H[i][j];\n                }\n\n                f = f / h;\n                for (i = m; i <= high; i++) {\n                    H[i][j] -= f * ort[i];\n                }\n            }\n\n            for (i = 0; i <= high; i++) {\n                f = 0;\n                for (j = high; j >= m; j--) {\n                    f += ort[j] * H[i][j];\n                }\n\n                f = f / h;\n                for (j = m; j <= high; j++) {\n                    H[i][j] -= f * ort[j];\n                }\n            }\n\n            ort[m] = scale * ort[m];\n            H[m][m - 1] = scale * g;\n        }\n    }\n\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            V[i][j] = (i === j ? 1 : 0);\n        }\n    }\n\n    for (m = high - 1; m >= low + 1; m--) {\n        if (H[m][m - 1] !== 0) {\n            for (i = m + 1; i <= high; i++) {\n                ort[i] = H[i][m - 1];\n            }\n\n            for (j = m; j <= high; j++) {\n                g = 0;\n                for (i = m; i <= high; i++) {\n                    g += ort[i] * V[i][j];\n                }\n\n                g = (g / ort[m]) / H[m][m - 1];\n                for (i = m; i <= high; i++) {\n                    V[i][j] += g * ort[i];\n                }\n            }\n        }\n    }\n}\n\nfunction hqr2(nn, e, d, V, H) {\n    var n = nn - 1,\n        low = 0,\n        high = nn - 1,\n        eps = Math.pow(2, -52),\n        exshift = 0,\n        norm = 0,\n        p = 0,\n        q = 0,\n        r = 0,\n        s = 0,\n        z = 0,\n        iter = 0,\n        i, j, k, l, m, t, w, x, y,\n        ra, sa, vr, vi,\n        notlast, cdivres;\n\n    for (i = 0; i < nn; i++) {\n        if (i < low || i > high) {\n            d[i] = H[i][i];\n            e[i] = 0;\n        }\n\n        for (j = Math.max(i - 1, 0); j < nn; j++) {\n            norm = norm + Math.abs(H[i][j]);\n        }\n    }\n\n    while (n >= low) {\n        l = n;\n        while (l > low) {\n            s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);\n            if (s === 0) {\n                s = norm;\n            }\n            if (Math.abs(H[l][l - 1]) < eps * s) {\n                break;\n            }\n            l--;\n        }\n\n        if (l === n) {\n            H[n][n] = H[n][n] + exshift;\n            d[n] = H[n][n];\n            e[n] = 0;\n            n--;\n            iter = 0;\n        } else if (l === n - 1) {\n            w = H[n][n - 1] * H[n - 1][n];\n            p = (H[n - 1][n - 1] - H[n][n]) / 2;\n            q = p * p + w;\n            z = Math.sqrt(Math.abs(q));\n            H[n][n] = H[n][n] + exshift;\n            H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;\n            x = H[n][n];\n\n            if (q >= 0) {\n                z = (p >= 0) ? (p + z) : (p - z);\n                d[n - 1] = x + z;\n                d[n] = d[n - 1];\n                if (z !== 0) {\n                    d[n] = x - w / z;\n                }\n                e[n - 1] = 0;\n                e[n] = 0;\n                x = H[n][n - 1];\n                s = Math.abs(x) + Math.abs(z);\n                p = x / s;\n                q = z / s;\n                r = Math.sqrt(p * p + q * q);\n                p = p / r;\n                q = q / r;\n\n                for (j = n - 1; j < nn; j++) {\n                    z = H[n - 1][j];\n                    H[n - 1][j] = q * z + p * H[n][j];\n                    H[n][j] = q * H[n][j] - p * z;\n                }\n\n                for (i = 0; i <= n; i++) {\n                    z = H[i][n - 1];\n                    H[i][n - 1] = q * z + p * H[i][n];\n                    H[i][n] = q * H[i][n] - p * z;\n                }\n\n                for (i = low; i <= high; i++) {\n                    z = V[i][n - 1];\n                    V[i][n - 1] = q * z + p * V[i][n];\n                    V[i][n] = q * V[i][n] - p * z;\n                }\n            } else {\n                d[n - 1] = x + p;\n                d[n] = x + p;\n                e[n - 1] = z;\n                e[n] = -z;\n            }\n\n            n = n - 2;\n            iter = 0;\n        } else {\n            x = H[n][n];\n            y = 0;\n            w = 0;\n            if (l < n) {\n                y = H[n - 1][n - 1];\n                w = H[n][n - 1] * H[n - 1][n];\n            }\n\n            if (iter === 10) {\n                exshift += x;\n                for (i = low; i <= n; i++) {\n                    H[i][i] -= x;\n                }\n                s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);\n                x = y = 0.75 * s;\n                w = -0.4375 * s * s;\n            }\n\n            if (iter === 30) {\n                s = (y - x) / 2;\n                s = s * s + w;\n                if (s > 0) {\n                    s = Math.sqrt(s);\n                    if (y < x) {\n                        s = -s;\n                    }\n                    s = x - w / ((y - x) / 2 + s);\n                    for (i = low; i <= n; i++) {\n                        H[i][i] -= s;\n                    }\n                    exshift += s;\n                    x = y = w = 0.964;\n                }\n            }\n\n            iter = iter + 1;\n\n            m = n - 2;\n            while (m >= l) {\n                z = H[m][m];\n                r = x - z;\n                s = y - z;\n                p = (r * s - w) / H[m + 1][m] + H[m][m + 1];\n                q = H[m + 1][m + 1] - z - r - s;\n                r = H[m + 2][m + 1];\n                s = Math.abs(p) + Math.abs(q) + Math.abs(r);\n                p = p / s;\n                q = q / s;\n                r = r / s;\n                if (m === l) {\n                    break;\n                }\n                if (Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) < eps * (Math.abs(p) * (Math.abs(H[m - 1][m - 1]) + Math.abs(z) + Math.abs(H[m + 1][m + 1])))) {\n                    break;\n                }\n                m--;\n            }\n\n            for (i = m + 2; i <= n; i++) {\n                H[i][i - 2] = 0;\n                if (i > m + 2) {\n                    H[i][i - 3] = 0;\n                }\n            }\n\n            for (k = m; k <= n - 1; k++) {\n                notlast = (k !== n - 1);\n                if (k !== m) {\n                    p = H[k][k - 1];\n                    q = H[k + 1][k - 1];\n                    r = (notlast ? H[k + 2][k - 1] : 0);\n                    x = Math.abs(p) + Math.abs(q) + Math.abs(r);\n                    if (x !== 0) {\n                        p = p / x;\n                        q = q / x;\n                        r = r / x;\n                    }\n                }\n\n                if (x === 0) {\n                    break;\n                }\n\n                s = Math.sqrt(p * p + q * q + r * r);\n                if (p < 0) {\n                    s = -s;\n                }\n\n                if (s !== 0) {\n                    if (k !== m) {\n                        H[k][k - 1] = -s * x;\n                    } else if (l !== m) {\n                        H[k][k - 1] = -H[k][k - 1];\n                    }\n\n                    p = p + s;\n                    x = p / s;\n                    y = q / s;\n                    z = r / s;\n                    q = q / p;\n                    r = r / p;\n\n                    for (j = k; j < nn; j++) {\n                        p = H[k][j] + q * H[k + 1][j];\n                        if (notlast) {\n                            p = p + r * H[k + 2][j];\n                            H[k + 2][j] = H[k + 2][j] - p * z;\n                        }\n\n                        H[k][j] = H[k][j] - p * x;\n                        H[k + 1][j] = H[k + 1][j] - p * y;\n                    }\n\n                    for (i = 0; i <= Math.min(n, k + 3); i++) {\n                        p = x * H[i][k] + y * H[i][k + 1];\n                        if (notlast) {\n                            p = p + z * H[i][k + 2];\n                            H[i][k + 2] = H[i][k + 2] - p * r;\n                        }\n\n                        H[i][k] = H[i][k] - p;\n                        H[i][k + 1] = H[i][k + 1] - p * q;\n                    }\n\n                    for (i = low; i <= high; i++) {\n                        p = x * V[i][k] + y * V[i][k + 1];\n                        if (notlast) {\n                            p = p + z * V[i][k + 2];\n                            V[i][k + 2] = V[i][k + 2] - p * r;\n                        }\n\n                        V[i][k] = V[i][k] - p;\n                        V[i][k + 1] = V[i][k + 1] - p * q;\n                    }\n                }\n            }\n        }\n    }\n\n    if (norm === 0) {\n        return;\n    }\n\n    for (n = nn - 1; n >= 0; n--) {\n        p = d[n];\n        q = e[n];\n\n        if (q === 0) {\n            l = n;\n            H[n][n] = 1;\n            for (i = n - 1; i >= 0; i--) {\n                w = H[i][i] - p;\n                r = 0;\n                for (j = l; j <= n; j++) {\n                    r = r + H[i][j] * H[j][n];\n                }\n\n                if (e[i] < 0) {\n                    z = w;\n                    s = r;\n                } else {\n                    l = i;\n                    if (e[i] === 0) {\n                        H[i][n] = (w !== 0) ? (-r / w) : (-r / (eps * norm));\n                    } else {\n                        x = H[i][i + 1];\n                        y = H[i + 1][i];\n                        q = (d[i] - p) * (d[i] - p) + e[i] * e[i];\n                        t = (x * s - z * r) / q;\n                        H[i][n] = t;\n                        H[i + 1][n] = (Math.abs(x) > Math.abs(z)) ? ((-r - w * t) / x) : ((-s - y * t) / z);\n                    }\n\n                    t = Math.abs(H[i][n]);\n                    if ((eps * t) * t > 1) {\n                        for (j = i; j <= n; j++) {\n                            H[j][n] = H[j][n] / t;\n                        }\n                    }\n                }\n            }\n        } else if (q < 0) {\n            l = n - 1;\n\n            if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {\n                H[n - 1][n - 1] = q / H[n][n - 1];\n                H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];\n            } else {\n                cdivres = cdiv(0, -H[n - 1][n], H[n - 1][n - 1] - p, q);\n                H[n - 1][n - 1] = cdivres[0];\n                H[n - 1][n] = cdivres[1];\n            }\n\n            H[n][n - 1] = 0;\n            H[n][n] = 1;\n            for (i = n - 2; i >= 0; i--) {\n                ra = 0;\n                sa = 0;\n                for (j = l; j <= n; j++) {\n                    ra = ra + H[i][j] * H[j][n - 1];\n                    sa = sa + H[i][j] * H[j][n];\n                }\n\n                w = H[i][i] - p;\n\n                if (e[i] < 0) {\n                    z = w;\n                    r = ra;\n                    s = sa;\n                } else {\n                    l = i;\n                    if (e[i] === 0) {\n                        cdivres = cdiv(-ra, -sa, w, q);\n                        H[i][n - 1] = cdivres[0];\n                        H[i][n] = cdivres[1];\n                    } else {\n                        x = H[i][i + 1];\n                        y = H[i + 1][i];\n                        vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;\n                        vi = (d[i] - p) * 2 * q;\n                        if (vr === 0 && vi === 0) {\n                            vr = eps * norm * (Math.abs(w) + Math.abs(q) + Math.abs(x) + Math.abs(y) + Math.abs(z));\n                        }\n                        cdivres = cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);\n                        H[i][n - 1] = cdivres[0];\n                        H[i][n] = cdivres[1];\n                        if (Math.abs(x) > (Math.abs(z) + Math.abs(q))) {\n                            H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;\n                            H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;\n                        } else {\n                            cdivres = cdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);\n                            H[i + 1][n - 1] = cdivres[0];\n                            H[i + 1][n] = cdivres[1];\n                        }\n                    }\n\n                    t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));\n                    if ((eps * t) * t > 1) {\n                        for (j = i; j <= n; j++) {\n                            H[j][n - 1] = H[j][n - 1] / t;\n                            H[j][n] = H[j][n] / t;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < nn; i++) {\n        if (i < low || i > high) {\n            for (j = i; j < nn; j++) {\n                V[i][j] = H[i][j];\n            }\n        }\n    }\n\n    for (j = nn - 1; j >= low; j--) {\n        for (i = low; i <= high; i++) {\n            z = 0;\n            for (k = low; k <= Math.min(j, high); k++) {\n                z = z + V[i][k] * H[k][j];\n            }\n            V[i][j] = z;\n        }\n    }\n}\n\nfunction cdiv(xr, xi, yr, yi) {\n    var r, d;\n    if (Math.abs(yr) > Math.abs(yi)) {\n        r = yi / yr;\n        d = yr + r * yi;\n        return [(xr + r * xi) / d, (xi - r * xr) / d];\n    }\n    else {\n        r = yr / yi;\n        d = yi + r * yr;\n        return [(r * xr + xi) / d, (r * xi - xr) / d];\n    }\n}\n\nmodule.exports = EigenvalueDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-optimize-lorentzian/~/ml-matrix/src/dc/evd.js\n ** module id = 32\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/LuDecomposition.cs\nfunction LuDecomposition(matrix) {\n    if (!(this instanceof LuDecomposition)) {\n        return new LuDecomposition(matrix);\n    }\n    matrix = Matrix.checkMatrix(matrix);\n\n    var lu = matrix.clone(),\n        rows = lu.rows,\n        columns = lu.columns,\n        pivotVector = new Array(rows),\n        pivotSign = 1,\n        i, j, k, p, s, t, v,\n        LUrowi, LUcolj, kmax;\n\n    for (i = 0; i < rows; i++) {\n        pivotVector[i] = i;\n    }\n\n    LUcolj = new Array(rows);\n\n    for (j = 0; j < columns; j++) {\n\n        for (i = 0; i < rows; i++) {\n            LUcolj[i] = lu[i][j];\n        }\n\n        for (i = 0; i < rows; i++) {\n            LUrowi = lu[i];\n            kmax = Math.min(i, j);\n            s = 0;\n            for (k = 0; k < kmax; k++) {\n                s += LUrowi[k] * LUcolj[k];\n            }\n            LUrowi[j] = LUcolj[i] -= s;\n        }\n\n        p = j;\n        for (i = j + 1; i < rows; i++) {\n            if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {\n                p = i;\n            }\n        }\n\n        if (p !== j) {\n            for (k = 0; k < columns; k++) {\n                t = lu[p][k];\n                lu[p][k] = lu[j][k];\n                lu[j][k] = t;\n            }\n\n            v = pivotVector[p];\n            pivotVector[p] = pivotVector[j];\n            pivotVector[j] = v;\n\n            pivotSign = -pivotSign;\n        }\n\n        if (j < rows && lu[j][j] !== 0) {\n            for (i = j + 1; i < rows; i++) {\n                lu[i][j] /= lu[j][j];\n            }\n        }\n    }\n\n    this.LU = lu;\n    this.pivotVector = pivotVector;\n    this.pivotSign = pivotSign;\n}\n\nLuDecomposition.prototype = {\n    isSingular: function () {\n        var data = this.LU,\n            col = data.columns;\n        for (var j = 0; j < col; j++) {\n            if (data[j][j] === 0) {\n                return true;\n            }\n        }\n        return false;\n    },\n    get determinant() {\n        var data = this.LU;\n        if (!data.isSquare())\n            throw new Error('Matrix must be square');\n        var determinant = this.pivotSign, col = data.columns;\n        for (var j = 0; j < col; j++)\n            determinant *= data[j][j];\n        return determinant;\n    },\n    get lowerTriangularFactor() {\n        var data = this.LU,\n            rows = data.rows,\n            columns = data.columns,\n            X = new Matrix(rows, columns);\n        for (var i = 0; i < rows; i++) {\n            for (var j = 0; j < columns; j++) {\n                if (i > j) {\n                    X[i][j] = data[i][j];\n                } else if (i === j) {\n                    X[i][j] = 1;\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get upperTriangularFactor() {\n        var data = this.LU,\n            rows = data.rows,\n            columns = data.columns,\n            X = new Matrix(rows, columns);\n        for (var i = 0; i < rows; i++) {\n            for (var j = 0; j < columns; j++) {\n                if (i <= j) {\n                    X[i][j] = data[i][j];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get pivotPermutationVector() {\n        return this.pivotVector.slice();\n    },\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var lu = this.LU,\n            rows = lu.rows;\n\n        if (rows !== value.rows)\n            throw new Error('Invalid matrix dimensions');\n        if (this.isSingular())\n            throw new Error('LU matrix is singular');\n\n        var count = value.columns,\n            X = value.subMatrixRow(this.pivotVector, 0, count - 1),\n            columns = lu.columns,\n            i, j, k;\n\n        for (k = 0; k < columns; k++) {\n            for (i = k + 1; i < columns; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * lu[i][k];\n                }\n            }\n        }\n        for (k = columns - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                X[k][j] /= lu[k][k];\n            }\n            for (i = 0; i < k; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * lu[i][k];\n                }\n            }\n        }\n        return X;\n    }\n};\n\nmodule.exports = LuDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-optimize-lorentzian/~/ml-matrix/src/dc/lu.js\n ** module id = 33\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\nvar hypotenuse = require('./util').hypotenuse;\n\n//https://github.com/lutzroeder/Mapack/blob/master/Source/QrDecomposition.cs\nfunction QrDecomposition(value) {\n    if (!(this instanceof QrDecomposition)) {\n        return new QrDecomposition(value);\n    }\n    value = Matrix.checkMatrix(value);\n\n    var qr = value.clone(),\n        m = value.rows,\n        n = value.columns,\n        rdiag = new Array(n),\n        i, j, k, s;\n\n    for (k = 0; k < n; k++) {\n        var nrm = 0;\n        for (i = k; i < m; i++) {\n            nrm = hypotenuse(nrm, qr[i][k]);\n        }\n        if (nrm !== 0) {\n            if (qr[k][k] < 0) {\n                nrm = -nrm;\n            }\n            for (i = k; i < m; i++) {\n                qr[i][k] /= nrm;\n            }\n            qr[k][k] += 1;\n            for (j = k + 1; j < n; j++) {\n                s = 0;\n                for (i = k; i < m; i++) {\n                    s += qr[i][k] * qr[i][j];\n                }\n                s = -s / qr[k][k];\n                for (i = k; i < m; i++) {\n                    qr[i][j] += s * qr[i][k];\n                }\n            }\n        }\n        rdiag[k] = -nrm;\n    }\n\n    this.QR = qr;\n    this.Rdiag = rdiag;\n}\n\nQrDecomposition.prototype = {\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var qr = this.QR,\n            m = qr.rows;\n\n        if (value.rows !== m)\n            throw new Error('Matrix row dimensions must agree');\n        if (!this.isFullRank())\n            throw new Error('Matrix is rank deficient');\n\n        var count = value.columns,\n            X = value.clone(),\n            n = qr.columns,\n            i, j, k, s;\n\n        for (k = 0; k < n; k++) {\n            for (j = 0; j < count; j++) {\n                s = 0;\n                for (i = k; i < m; i++) {\n                    s += qr[i][k] * X[i][j];\n                }\n                s = -s / qr[k][k];\n                for (i = k; i < m; i++) {\n                    X[i][j] += s * qr[i][k];\n                }\n            }\n        }\n        for (k = n - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                X[k][j] /= this.Rdiag[k];\n            }\n            for (i = 0; i < k; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * qr[i][k];\n                }\n            }\n        }\n\n        return X.subMatrix(0, n - 1, 0, count - 1);\n    },\n    isFullRank: function () {\n        var columns = this.QR.columns;\n        for (var i = 0; i < columns; i++) {\n            if (this.Rdiag[i] === 0) {\n                return false;\n            }\n        }\n        return true;\n    },\n    get upperTriangularFactor() {\n        var qr = this.QR,\n            n = qr.columns,\n            X = new Matrix(n, n),\n            i, j;\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                if (i < j) {\n                    X[i][j] = qr[i][j];\n                } else if (i === j) {\n                    X[i][j] = this.Rdiag[i];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get orthogonalFactor() {\n        var qr = this.QR,\n            rows = qr.rows,\n            columns = qr.columns,\n            X = new Matrix(rows, columns),\n            i, j, k, s;\n\n        for (k = columns - 1; k >= 0; k--) {\n            for (i = 0; i < rows; i++) {\n                X[i][k] = 0;\n            }\n            X[k][k] = 1;\n            for (j = k; j < columns; j++) {\n                if (qr[k][k] !== 0) {\n                    s = 0;\n                    for (i = k; i < rows; i++) {\n                        s += qr[i][k] * X[i][j];\n                    }\n\n                    s = -s / qr[k][k];\n\n                    for (i = k; i < rows; i++) {\n                        X[i][j] += s * qr[i][k];\n                    }\n                }\n            }\n        }\n        return X;\n    }\n};\n\nmodule.exports = QrDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-optimize-lorentzian/~/ml-matrix/src/dc/qr.js\n ** module id = 34\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/CholeskyDecomposition.cs\nfunction CholeskyDecomposition(value) {\n    if (!(this instanceof CholeskyDecomposition)) {\n        return new CholeskyDecomposition(value);\n    }\n    value = Matrix.checkMatrix(value);\n    if (!value.isSymmetric())\n        throw new Error('Matrix is not symmetric');\n\n    var a = value,\n        dimension = a.rows,\n        l = new Matrix(dimension, dimension),\n        positiveDefinite = true,\n        i, j, k;\n\n    for (j = 0; j < dimension; j++) {\n        var Lrowj = l[j];\n        var d = 0;\n        for (k = 0; k < j; k++) {\n            var Lrowk = l[k];\n            var s = 0;\n            for (i = 0; i < k; i++) {\n                s += Lrowk[i] * Lrowj[i];\n            }\n            Lrowj[k] = s = (a[j][k] - s) / l[k][k];\n            d = d + s * s;\n        }\n\n        d = a[j][j] - d;\n\n        positiveDefinite &= (d > 0);\n        l[j][j] = Math.sqrt(Math.max(d, 0));\n        for (k = j + 1; k < dimension; k++) {\n            l[j][k] = 0;\n        }\n    }\n\n    if (!positiveDefinite) {\n        throw new Error('Matrix is not positive definite');\n    }\n\n    this.L = l;\n}\n\nCholeskyDecomposition.prototype = {\n    get leftTriangularFactor() {\n        return this.L;\n    },\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var l = this.L,\n            dimension = l.rows;\n\n        if (value.rows !== dimension) {\n            throw new Error('Matrix dimensions do not match');\n        }\n\n        var count = value.columns,\n            B = value.clone(),\n            i, j, k;\n\n        for (k = 0; k < dimension; k++) {\n            for (j = 0; j < count; j++) {\n                for (i = 0; i < k; i++) {\n                    B[k][j] -= B[i][j] * l[k][i];\n                }\n                B[k][j] /= l[k][k];\n            }\n        }\n\n        for (k = dimension - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                for (i = k + 1; i < dimension; i++) {\n                    B[k][j] -= B[i][j] * l[i][k];\n                }\n                B[k][j] /= l[k][k];\n            }\n        }\n\n        return B;\n    }\n};\n\nmodule.exports = CholeskyDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-optimize-lorentzian/~/ml-matrix/src/dc/cholesky.js\n ** module id = 35\n ** module chunks = 0\n **/","var Opt = require(\"ml-optimize-lorentzian\");\nvar stats = require(\"ml-stat\");\nvar extend = require('extend');\nvar SG = require('ml-savitzky-golay-generalized');\n\nvar sgDefOptions = {\n    windowSize: 9,\n    polynomial: 3\n};\n\n\nfunction gsd(x, y, options){\n    //options = extend({}, defaultOptions, options);\n    var options=Object.create(options || {});\n    if (options.minMaxRatio===undefined) options.minMaxRatio=0.00025;\n    if (options.broadRatio===undefined) options.broadRatio=0.00;\n    if (options.noiseLevel===undefined) options.noiseLevel=undefined;\n    if (options.noiseFactor===undefined) options.noiseFactor=3;\n    if (options.maxCriteria===undefined) options.maxCriteria=true;\n    if (options.smoothY===undefined) options.smoothY=true;\n    if (options.realTopDetection===undefined) options.realTopDetection=false;\n\n    var sgOptions = extend({}, sgDefOptions, options.sgOptions);\n\n    //console.log(JSON.stringify(stats.array.minMax(y)));\n    if(options.noiseLevel===undefined){\n        //We have to know if x is equally spaced\n        var maxDx=0, minDx=Number.MAX_VALUE,tmp;\n        for(var i=0;i< x.length-1;i++){\n            var tmp = Math.abs(x[i+1]-x[i]);\n            if(tmp<minDx){\n                minDx = tmp;\n            }\n            if(tmp>maxDx){\n                maxDx = tmp;\n            }\n        }\n\n        if((maxDx-minDx)/maxDx<0.05){\n\n            options.noiseLevel = getNoiseLevel(y);\n            //console.log(options.noiseLevel+\" \"+stats.array.median(y));\n        }\n        else{\n            options.noiseLevel = 0;\n        }\n    }\n    //console.log(\"options.noiseLevel \"+options.noiseLevel);\n    y=[].concat(y);\n    var yCorrection = {m:1, b:options.noiseLevel};\n    if(!options.maxCriteria){\n        yCorrection.m =-1;\n        yCorrection.b*=-1;\n    }\n\n    for (var i=0; i<y.length; i++){\n        y[i]=yCorrection.m*y[i]-yCorrection.b;\n    }\n\n    for (var i=0; i<y.length; i++) {\n        if (y[i] < 0) {\n            y[i] = 0;\n        }\n    }\n\n    //If the max difference between delta x is less than 5%, then, we can assume it to be equally spaced variable\n    var Y = y;\n    if((maxDx-minDx)/maxDx<0.05){\n        if(options.smoothY)\n            Y = SG(y, x[1]-x[0], {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:0});\n        var dY = SG(y, x[1]-x[0], {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:1});\n        var ddY = SG(y, x[1]-x[0], {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:2});\n    }\n    else{\n        if(options.smoothY)\n            Y = SG(y, x, {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:0});\n        var dY = SG(y, x, {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:1});\n        var ddY = SG(y, x, {windowSize:sgOptions.windowSize, polynomial:sgOptions.polynomial,derivative:2});\n    }\n\n    var X = x;\n    var dx = x[1]-x[0];\n    var maxDdy=0;\n    var maxY = 0;\n    //console.log(Y.length);\n    for (var i = 0; i < Y.length ; i++){\n        if(Math.abs(ddY[i])>maxDdy){\n            maxDdy = Math.abs(ddY[i]);\n        }\n        if(Math.abs(Y[i])>maxY){\n            maxY = Math.abs(Y[i]);\n        }\n    }\n    //console.log(maxY+\"x\"+maxDy+\"x\"+maxDdy);\n\n    var minddY = [];\n    var intervalL = [];\n    var intervalR = [];\n    var lastMax = null;\n    var lastMin = null;\n    var broadMask = new Array();\n    //console.log(dx);\n    //By the intermediate value theorem We cannot find 2 consecutive maxima or minima\n    for (var i = 1; i < Y.length -1 ; i++){\n        //console.log(dY[i]);\n        if ((dY[i] < dY[i-1]) && (dY[i] <= dY[i+1])||\n            (dY[i] <= dY[i-1]) && (dY[i] < dY[i+1])) {\n            lastMin = X[i];\n            //console.log(\"min \"+lastMin);\n            if(dx>0&&lastMax!=null){\n                intervalL.push(lastMax);\n                intervalR.push(lastMin);\n\n            }\n        }\n\n        if ((dY[i] >= dY[i-1]) && (dY[i] > dY[i+1])||\n            (dY[i] > dY[i-1]) && (dY[i] >= dY[i+1])) {\n            lastMax = X[i];\n            //console.log(\"max \"+lastMax);\n            if(dx<0&&lastMin!=null){\n                intervalL.push(lastMax);\n                intervalR.push(lastMin);\n            }\n        }\n        if ((ddY[i] < ddY[i-1]) && (ddY[i] < ddY[i+1])) {\n            minddY.push(i);//( [X[i], Y[i], i] );  // TODO should we change this to have 3 arrays ? Huge overhead creating arrays\n            if(Math.abs(ddY[i])>options.broadRatio*maxDdy){ // TODO should this be a parameter =\n                broadMask.push(false);\n            }\n            else{\n                broadMask.push(true);\n            }\n        }\n    }\n    //\n    //console.log(intervalL.length+\" \"+minddY.length+\" \"+broadMask.length);\n    var signals = [];\n    var lastK = 0,possible, k, f,frequency, distanceJ, minDistance, gettingCloser;\n    for (var j = 0; j < minddY.length; j++){\n        frequency = X[minddY[j]];//minddY[j][0];\n        possible = -1;\n        k=lastK+1;\n        minDistance = Number.MAX_VALUE;\n        distanceJ = 0;\n        gettingCloser=true;\n        while(possible==-1&&k<intervalL.length&&gettingCloser){\n            distanceJ = Math.abs(frequency-(intervalL[k]+intervalR[k])/2);\n            //Still getting closer?\n            if(distanceJ<minDistance){\n                minDistance = distanceJ;\n            }\n            else{\n                gettingCloser = false;\n            }\n            if( distanceJ <Math.abs(intervalL[k]-intervalR[k])/2){\n                possible=k;\n                lastK = k;\n            }\n            k++;\n        }\n        //console.log(lastK+\" \"+intervalL.length+\" possible \"+k);\n        if (possible!=-1){\n            //console.log(height);\n            if (Math.abs(Y[minddY[j]]) > options.minMaxRatio*maxY) {\n                signals.push({\n                    i:minddY[j],\n                    x: frequency,\n                    y: (Y[minddY[j]]-yCorrection.b)/yCorrection.m,\n                    width:Math.abs(intervalR[possible] - intervalL[possible]),//widthCorrection\n                    soft:broadMask[j]\n                })\n            }\n        }\n    }\n\n\n    if(options.realTopDetection){\n        realTopDetection(signals,X,Y);\n    }\n\n    //Correct the values to fit the original spectra data\n    for(var j=0;j<signals.length;j++){\n        signals[j].base=options.noiseLevel;\n    }\n\n    signals.sort(function (a, b) {\n        return a.x - b.x;\n    });\n\n    return signals;\n\n}\n\nfunction getNoiseLevel(y){\n    var mean = 0,stddev=0;\n    var length = y.length,i=0;\n    for(i = 0; i < length; i++){\n        mean+=y[i];\n    }\n    mean/=length;\n    var averageDeviations = new Array(length);\n    for (i = 0; i < length; i++)\n        averageDeviations[i] = Math.abs(y[i] - mean);\n    averageDeviations.sort();\n    if (length % 2 == 1) {\n        stddev = averageDeviations[(length-1)/2] / 0.6745;\n    } else {\n        stddev = 0.5*(averageDeviations[length/2]+averageDeviations[length/2-1]) / 0.6745;\n    }\n\n    return stddev;\n}\n\nfunction realTopDetection(peakList, x, y){\n    //console.log(peakList);\n    //console.log(x);\n    //console.log(y);\n    var listP = [];\n    var alpha, beta, gamma, p,currentPoint;\n    for(var j=0;j<peakList.length;j++){\n        currentPoint = peakList[j].i;//peakList[j][2];\n        var tmp = currentPoint;\n        //The detected peak could be moved 1 or 2 unit to left or right.\n        if(y[currentPoint-1]>=y[currentPoint-2]\n            &&y[currentPoint-1]>=y[currentPoint]) {\n            currentPoint--;\n        }\n        else{\n            if(y[currentPoint+1]>=y[currentPoint]\n                &&y[currentPoint+1]>=y[currentPoint+2]) {\n                currentPoint++;\n            }\n            else{\n                if(y[currentPoint-2]>=y[currentPoint-3]\n                    &&y[currentPoint-2]>=y[currentPoint-1]) {\n                    currentPoint-=2;\n                }\n                else{\n                    if(y[currentPoint+2]>=y[currentPoint+1]\n                        &&y[currentPoint+2]>=y[currentPoint+3]) {\n                        currentPoint+=2;\n                    }\n                }\n            }\n        }\n        if(y[currentPoint-1]>0&&y[currentPoint+1]>0\n            &&y[currentPoint]>=y[currentPoint-1]\n            &&y[currentPoint]>=y[currentPoint+1]) {\n            alpha = 20 * Math.log10(y[currentPoint - 1]);\n            beta = 20 * Math.log10(y[currentPoint]);\n            gamma = 20 * Math.log10(y[currentPoint + 1]);\n            p = 0.5 * (alpha - gamma) / (alpha - 2 * beta + gamma);\n            //console.log(\"p: \"+p);\n            //console.log(x[currentPoint]+\" \"+tmp+\" \"+currentPoint);\n            peakList[j].x = x[currentPoint] + (x[currentPoint]-x[currentPoint-1])*p;\n            peakList[j].y = y[currentPoint] - 0.25 * (y[currentPoint - 1]\n                - y[currentPoint + 1]) * p;//signal.peaks[j].intensity);\n            //console.log(y[tmp]+\" \"+peakList[j].y);\n        }\n    }\n}\n\nmodule.exports=gsd;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-gsd/src/gsd.js\n ** module id = 36\n ** module chunks = 0\n **/","'use strict';\n\nexports.array = require('./array');\nexports.matrix = require('./matrix');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-stat/index.js\n ** module id = 37\n ** module chunks = 0\n **/","'use strict';\nvar arrayStat = require('./array');\n\n// https://github.com/accord-net/framework/blob/development/Sources/Accord.Statistics/Tools.cs\n\nfunction entropy(matrix, eps) {\n    if (typeof(eps) === 'undefined') {\n        eps = 0;\n    }\n    var sum = 0,\n        l1 = matrix.length,\n        l2 = matrix[0].length;\n    for (var i = 0; i < l1; i++) {\n        for (var j = 0; j < l2; j++) {\n            sum += matrix[i][j] * Math.log(matrix[i][j] + eps);\n        }\n    }\n    return -sum;\n}\n\nfunction mean(matrix, dimension) {\n    if (typeof(dimension) === 'undefined') {\n        dimension = 0;\n    }\n    var rows = matrix.length,\n        cols = matrix[0].length,\n        theMean, N, i, j;\n\n    if (dimension === -1) {\n        theMean = [0];\n        N = rows * cols;\n        for (i = 0; i < rows; i++) {\n            for (j = 0; j < cols; j++) {\n                theMean[0] += matrix[i][j];\n            }\n        }\n        theMean[0] /= N;\n    } else if (dimension === 0) {\n        theMean = new Array(cols);\n        N = rows;\n        for (j = 0; j < cols; j++) {\n            theMean[j] = 0;\n            for (i = 0; i < rows; i++) {\n                theMean[j] += matrix[i][j];\n            }\n            theMean[j] /= N;\n        }\n    } else if (dimension === 1) {\n        theMean = new Array(rows);\n        N = cols;\n        for (j = 0; j < rows; j++) {\n            theMean[j] = 0;\n            for (i = 0; i < cols; i++) {\n                theMean[j] += matrix[j][i];\n            }\n            theMean[j] /= N;\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n    return theMean;\n}\n\nfunction standardDeviation(matrix, means, unbiased) {\n    var vari = variance(matrix, means, unbiased), l = vari.length;\n    for (var i = 0; i < l; i++) {\n        vari[i] = Math.sqrt(vari[i]);\n    }\n    return vari;\n}\n\nfunction variance(matrix, means, unbiased) {\n    if (typeof(unbiased) === 'undefined') {\n        unbiased = true;\n    }\n    means = means || mean(matrix);\n    var rows = matrix.length;\n    if (rows === 0) return [];\n    var cols = matrix[0].length;\n    var vari = new Array(cols);\n\n    for (var j = 0; j < cols; j++) {\n        var sum1 = 0, sum2 = 0, x = 0;\n        for (var i = 0; i < rows; i++) {\n            x = matrix[i][j] - means[j];\n            sum1 += x;\n            sum2 += x * x;\n        }\n        if (unbiased) {\n            vari[j] = (sum2 - ((sum1 * sum1) / rows)) / (rows - 1);\n        } else {\n            vari[j] = (sum2 - ((sum1 * sum1) / rows)) / rows;\n        }\n    }\n    return vari;\n}\n\nfunction median(matrix) {\n    var rows = matrix.length, cols = matrix[0].length;\n    var medians = new Array(cols);\n\n    for (var i = 0; i < cols; i++) {\n        var data = new Array(rows);\n        for (var j = 0; j < rows; j++) {\n            data[j] = matrix[j][i];\n        }\n        data.sort();\n        var N = data.length;\n        if (N % 2 === 0) {\n            medians[i] = (data[N / 2] + data[(N / 2) - 1]) * 0.5;\n        } else {\n            medians[i] = data[Math.floor(N / 2)];\n        }\n    }\n    return medians;\n}\n\nfunction mode(matrix) {\n    var rows = matrix.length,\n        cols = matrix[0].length,\n        modes = new Array(cols),\n        i, j;\n    for (i = 0; i < cols; i++) {\n        var itemCount = new Array(rows);\n        for (var k = 0; k < rows; k++) {\n            itemCount[k] = 0;\n        }\n        var itemArray = new Array(rows);\n        var count = 0;\n\n        for (j = 0; j < rows; j++) {\n            var index = itemArray.indexOf(matrix[j][i]);\n            if (index >= 0) {\n                itemCount[index]++;\n            } else {\n                itemArray[count] = matrix[j][i];\n                itemCount[count] = 1;\n                count++;\n            }\n        }\n\n        var maxValue = 0, maxIndex = 0;\n        for (j = 0; j < count; j++) {\n            if (itemCount[j] > maxValue) {\n                maxValue = itemCount[j];\n                maxIndex = j;\n            }\n        }\n\n        modes[i] = itemArray[maxIndex];\n    }\n    return modes;\n}\n\nfunction skewness(matrix, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var means = mean(matrix);\n    var n = matrix.length, l = means.length;\n    var skew = new Array(l);\n\n    for (var j = 0; j < l; j++) {\n        var s2 = 0, s3 = 0;\n        for (var i = 0; i < n; i++) {\n            var dev = matrix[i][j] - means[j];\n            s2 += dev * dev;\n            s3 += dev * dev * dev;\n        }\n\n        var m2 = s2 / n;\n        var m3 = s3 / n;\n        var g = m3 / Math.pow(m2, 3 / 2);\n\n        if (unbiased) {\n            var a = Math.sqrt(n * (n - 1));\n            var b = n - 2;\n            skew[j] = (a / b) * g;\n        } else {\n            skew[j] = g;\n        }\n    }\n    return skew;\n}\n\nfunction kurtosis(matrix, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var means = mean(matrix);\n    var n = matrix.length, m = matrix[0].length;\n    var kurt = new Array(m);\n\n    for (var j = 0; j < m; j++) {\n        var s2 = 0, s4 = 0;\n        for (var i = 0; i < n; i++) {\n            var dev = matrix[i][j] - means[j];\n            s2 += dev * dev;\n            s4 += dev * dev * dev * dev;\n        }\n        var m2 = s2 / n;\n        var m4 = s4 / n;\n\n        if (unbiased) {\n            var v = s2 / (n - 1);\n            var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n            var b = s4 / (v * v);\n            var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n            kurt[j] = a * b - 3 * c;\n        } else {\n            kurt[j] = m4 / (m2 * m2) - 3;\n        }\n    }\n    return kurt;\n}\n\nfunction standardError(matrix) {\n    var samples = matrix.length;\n    var standardDeviations = standardDeviation(matrix), l = standardDeviations.length;\n    var standardErrors = new Array(l);\n    var sqrtN = Math.sqrt(samples);\n\n    for (var i = 0; i < l; i++) {\n        standardErrors[i] = standardDeviations[i] / sqrtN;\n    }\n    return standardErrors;\n}\n\nfunction covariance(matrix, dimension) {\n    return scatter(matrix, undefined, dimension);\n}\n\nfunction scatter(matrix, divisor, dimension) {\n    if (typeof(dimension) === 'undefined') {\n        dimension = 0;\n    }\n    if (typeof(divisor) === 'undefined') {\n        if (dimension === 0) {\n            divisor = matrix.length - 1;\n        } else if (dimension === 1) {\n            divisor = matrix[0].length - 1;\n        }\n    }\n    var means = mean(matrix, dimension),\n        rows = matrix.length;\n    if (rows === 0) {\n        return [[]];\n    }\n    var cols = matrix[0].length,\n        cov, i, j, s, k;\n\n    if (dimension === 0) {\n        cov = new Array(cols);\n        for (i = 0; i < cols; i++) {\n            cov[i] = new Array(cols);\n        }\n        for (i = 0; i < cols; i++) {\n            for (j = i; j < cols; j++) {\n                s = 0;\n                for (k = 0; k < rows; k++) {\n                    s += (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);\n                }\n                s /= divisor;\n                cov[i][j] = s;\n                cov[j][i] = s;\n            }\n        }\n    } else if (dimension === 1) {\n        cov = new Array(rows);\n        for (i = 0; i < rows; i++) {\n            cov[i] = new Array(rows);\n        }\n        for (i = 0; i < rows; i++) {\n            for (j = i; j < rows; j++) {\n                s = 0;\n                for (k = 0; k < cols; k++) {\n                    s += (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);\n                }\n                s /= divisor;\n                cov[i][j] = s;\n                cov[j][i] = s;\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n\n    return cov;\n}\n\nfunction correlation(matrix) {\n    var means = mean(matrix),\n        standardDeviations = standardDeviation(matrix, true, means),\n        scores = zScores(matrix, means, standardDeviations),\n        rows = matrix.length,\n        cols = matrix[0].length,\n        i, j;\n\n    var cor = new Array(cols);\n    for (i = 0; i < cols; i++) {\n        cor[i] = new Array(cols);\n    }\n    for (i = 0; i < cols; i++) {\n        for (j = i; j < cols; j++) {\n            var c = 0;\n            for (var k = 0, l = scores.length; k < l; k++) {\n                c += scores[k][j] * scores[k][i];\n            }\n            c /= rows - 1;\n            cor[i][j] = c;\n            cor[j][i] = c;\n        }\n    }\n    return cor;\n}\n\nfunction zScores(matrix, means, standardDeviations) {\n    means = means || mean(matrix);\n    if (typeof(standardDeviations) === 'undefined') standardDeviations = standardDeviation(matrix, true, means);\n    return standardize(center(matrix, means, false), standardDeviations, true);\n}\n\nfunction center(matrix, means, inPlace) {\n    means = means || mean(matrix);\n    var result = matrix,\n        l = matrix.length,\n        i, j, jj;\n\n    if (!inPlace) {\n        result = new Array(l);\n        for (i = 0; i < l; i++) {\n            result[i] = new Array(matrix[i].length);\n        }\n    }\n\n    for (i = 0; i < l; i++) {\n        var row = result[i];\n        for (j = 0, jj = row.length; j < jj; j++) {\n            row[j] = matrix[i][j] - means[j];\n        }\n    }\n    return result;\n}\n\nfunction standardize(matrix, standardDeviations, inPlace) {\n    if (typeof(standardDeviations) === 'undefined') standardDeviations = standardDeviation(matrix);\n    var result = matrix,\n        l = matrix.length,\n        i, j, jj;\n\n    if (!inPlace) {\n        result = new Array(l);\n        for (i = 0; i < l; i++) {\n            result[i] = new Array(matrix[i].length);\n        }\n    }\n\n    for (i = 0; i < l; i++) {\n        var resultRow = result[i];\n        var sourceRow = matrix[i];\n        for (j = 0, jj = resultRow.length; j < jj; j++) {\n            if (standardDeviations[j] !== 0 && !isNaN(standardDeviations[j])) {\n                resultRow[j] = sourceRow[j] / standardDeviations[j];\n            }\n        }\n    }\n    return result;\n}\n\nfunction weightedVariance(matrix, weights) {\n    var means = mean(matrix);\n    var rows = matrix.length;\n    if (rows === 0) return [];\n    var cols = matrix[0].length;\n    var vari = new Array(cols);\n\n    for (var j = 0; j < cols; j++) {\n        var sum = 0;\n        var a = 0, b = 0;\n\n        for (var i = 0; i < rows; i++) {\n            var z = matrix[i][j] - means[j];\n            var w = weights[i];\n\n            sum += w * (z * z);\n            b += w;\n            a += w * w;\n        }\n\n        vari[j] = sum * (b / (b * b - a));\n    }\n\n    return vari;\n}\n\nfunction weightedMean(matrix, weights, dimension) {\n    if (typeof(dimension) === 'undefined') {\n        dimension = 0;\n    }\n    var rows = matrix.length;\n    if (rows === 0) return [];\n    var cols = matrix[0].length,\n        means, i, ii, j, w, row;\n\n    if (dimension === 0) {\n        means = new Array(cols);\n        for (i = 0; i < cols; i++) {\n            means[i] = 0;\n        }\n        for (i = 0; i < rows; i++) {\n            row = matrix[i];\n            w = weights[i];\n            for (j = 0; j < cols; j++) {\n                means[j] += row[j] * w;\n            }\n        }\n    } else if (dimension === 1) {\n        means = new Array(rows);\n        for (i = 0; i < rows; i++) {\n            means[i] = 0;\n        }\n        for (j = 0; j < rows; j++) {\n            row = matrix[j];\n            w = weights[j];\n            for (i = 0; i < cols; i++) {\n                means[j] += row[i] * w;\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n\n    var weightSum = arrayStat.sum(weights);\n    if (weightSum !== 0) {\n        for (i = 0, ii = means.length; i < ii; i++) {\n            means[i] /= weightSum;\n        }\n    }\n    return means;\n}\n\nfunction weightedCovariance(matrix, weights, means, dimension) {\n    dimension = dimension || 0;\n    means = means || weightedMean(matrix, weights, dimension);\n    var s1 = 0, s2 = 0;\n    for (var i = 0, ii = weights.length; i < ii; i++) {\n        s1 += weights[i];\n        s2 += weights[i] * weights[i];\n    }\n    var factor = s1 / (s1 * s1 - s2);\n    return weightedScatter(matrix, weights, means, factor, dimension);\n}\n\nfunction weightedScatter(matrix, weights, means, factor, dimension) {\n    dimension = dimension || 0;\n    means = means || weightedMean(matrix, weights, dimension);\n    if (typeof(factor) === 'undefined') {\n        factor = 1;\n    }\n    var rows = matrix.length;\n    if (rows === 0) {\n        return [[]];\n    }\n    var cols = matrix[0].length,\n        cov, i, j, k, s;\n\n    if (dimension === 0) {\n        cov = new Array(cols);\n        for (i = 0; i < cols; i++) {\n            cov[i] = new Array(cols);\n        }\n        for (i = 0; i < cols; i++) {\n            for (j = i; j < cols; j++) {\n                s = 0;\n                for (k = 0; k < rows; k++) {\n                    s += weights[k] * (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);\n                }\n                cov[i][j] = s * factor;\n                cov[j][i] = s * factor;\n            }\n        }\n    } else if (dimension === 1) {\n        cov = new Array(rows);\n        for (i = 0; i < rows; i++) {\n            cov[i] = new Array(rows);\n        }\n        for (i = 0; i < rows; i++) {\n            for (j = i; j < rows; j++) {\n                s = 0;\n                for (k = 0; k < cols; k++) {\n                    s += weights[k] * (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);\n                }\n                cov[i][j] = s * factor;\n                cov[j][i] = s * factor;\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n\n    return cov;\n}\n\nmodule.exports = {\n    entropy: entropy,\n    mean: mean,\n    standardDeviation: standardDeviation,\n    variance: variance,\n    median: median,\n    mode: mode,\n    skewness: skewness,\n    kurtosis: kurtosis,\n    standardError: standardError,\n    covariance: covariance,\n    scatter: scatter,\n    correlation: correlation,\n    zScores: zScores,\n    center: center,\n    standardize: standardize,\n    weightedVariance: weightedVariance,\n    weightedMean: weightedMean,\n    weightedCovariance: weightedCovariance,\n    weightedScatter: weightedScatter\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-stat/matrix.js\n ** module id = 38\n ** module chunks = 0\n **/","//Code translate from Pascal source in http://pubs.acs.org/doi/pdf/10.1021/ac00205a007\nvar extend = require('extend');\nvar stat = require('ml-stat');\n\nvar defaultOptions = {\n    windowSize: 9,\n    derivative: 0,\n    polynomial: 3,\n};\n\n\nfunction SavitzkyGolay(data, h, options) {\n    options = extend({}, defaultOptions, options);\n\n    if ((options.windowSize % 2 === 0) || (options.windowSize < 5) || !(Number.isInteger(options.windowSize)))\n            throw new RangeError('Invalid window size (should be odd and at least 5 integer number)')\n\n\n    if (options.windowSize>data.length)\n        throw new RangeError('Window size is higher than the data length '+options.windowSize+\">\"+data.length);\n    if ((options.derivative < 0) || !(Number.isInteger(options.derivative)))\n        throw new RangeError('Derivative should be a positive integer');\n    if ((options.polynomial < 1) || !(Number.isInteger(options.polynomial)))\n        throw new RangeError('Polynomial should be a positive integer');\n    if (options.polynomial >= 6)\n        console.warn('You should not use polynomial grade higher than 5 if you are' +\n            ' not sure that your data arises from such a model. Possible polynomial oscillation problems');\n\n    var windowSize = options.windowSize;\n\n    var half = Math.floor(windowSize/2);\n    var np = data.length;\n    var ans = new Array(np);\n    var weights = fullWeights(windowSize,options.polynomial,options.derivative);\n    var hs = 0;\n    var constantH = true;\n    if( Object.prototype.toString.call( h ) === '[object Array]' ) {\n        constantH = false;\n    }\n    else{\n        hs = Math.pow(h, options.derivative);\n    }\n    //console.log(\"Constant h: \"+constantH);\n    //For the borders\n    for(var i=0;i<half;i++){\n        var wg1=weights[half-i-1];\n        var wg2=weights[half+i+1];\n        var d1 = 0,d2=0;\n        for (var l = 0; l < windowSize; l++){\n            d1 += wg1[l] * data[l];\n            d2 += wg2[l] * data[np-windowSize+l-1];\n        }\n        if(constantH){\n            ans[half-i-1] = d1/hs;\n            ans[np-half+i] = d2/hs;\n        }\n        else{\n            hs = getHs(h,half-i-1,half, options.derivative);\n            ans[half-i-1] = d1/hs;\n            hs = getHs(h,np-half+i,half, options.derivative);\n            ans[np-half+i] = d2/hs;\n        }\n    }\n    //For the internal points\n    var wg = weights[half];\n    for(var i=windowSize;i<np+1;i++){\n        var d = 0;\n        for (var l = 0; l < windowSize; l++)\n            d += wg[l] * data[l+i-windowSize];\n        if(!constantH)\n            hs = getHs(h,i-half-1,half, options.derivative);\n        ans[i-half-1] = d/hs;\n    }\n    return ans;\n}\n\nfunction getHs(h,center,half,derivative){\n    var hs = 0;\n    var count = 0;\n    for(var i=center-half;i<center+half;i++){\n        if(i>=0 && i < h.length-1){\n            hs+= (h[i+1]-h[i]);\n            count++;\n        }\n    }\n    return Math.pow(hs/count,derivative);\n}\n\nfunction GramPoly(i,m,k,s){\n    var Grampoly = 0;\n    if(k>0){\n        Grampoly = (4*k-2)/(k*(2*m-k+1))*(i*GramPoly(i,m,k-1,s) +\n            s*GramPoly(i,m,k-1,s-1)) - ((k-1)*(2*m+k))/(k*(2*m-k+1))*GramPoly(i,m,k-2,s);\n    }\n    else{\n        if(k==0&&s==0){\n            Grampoly=1;\n        }\n        else{\n            Grampoly=0;\n        }\n    }\n    //console.log(Grampoly);\n    return Grampoly;\n}\n\nfunction GenFact(a,b){\n    var gf=1;\n    if(a>=b){\n        for(var j=a-b+1;j<=a;j++){\n            gf*=j;\n        }\n    }\n    return gf;\n}\n\nfunction Weight(i,t,m,n,s){\n    var sum=0;\n    for(var k=0;k<=n;k++){\n        //console.log(k);\n        sum+=(2*k+1)*(GenFact(2*m,k)/GenFact(2*m+k+1,k+1))*GramPoly(i,m,k,0)*GramPoly(t,m,k,s)\n    }\n    return sum;\n}\n\n/**\n *\n * @param m  Number of points\n * @param n  Polynomial grade\n * @param s  Derivative\n */\nfunction fullWeights(m,n,s){\n    var weights = new Array(m);\n    var np = Math.floor(m/2);\n    for(var t=-np;t<=np;t++){\n        weights[t+np] = new Array(m);\n        for(var j=-np;j<=np;j++){\n            weights[t+np][j+np]=Weight(j,t,np,n,s);\n        }\n    }\n    return weights;\n}\n\n/*function entropy(data,h,options){\n    var trend = SavitzkyGolay(data,h,trendOptions);\n    var copy = new Array(data.length);\n    var sum = 0;\n    var max = 0;\n    for(var i=0;i<data.length;i++){\n        copy[i] = data[i]-trend[i];\n    }\n\n    sum/=data.length;\n    console.log(sum+\" \"+max);\n    console.log(stat.array.standardDeviation(copy));\n    console.log(Math.abs(stat.array.mean(copy))/stat.array.standardDeviation(copy));\n    return sum;\n\n}\n\n\n\nfunction guessWindowSize(data, h){\n    console.log(\"entropy \"+entropy(data,h,trendOptions));\n    return 5;\n}\n*/\nmodule.exports = SavitzkyGolay;\n \n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-savitzky-golay-generalized/src/index.js\n ** module id = 39\n ** module chunks = 0\n **/","'use strict';\n\nvar impuritiesList = [\n    {\"solvent\":\"CDCl3\",\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"ds\",\"shift\":7.26}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"bs\",\"shift\":1.56}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.1}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.17}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.1}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.36}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.28}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.19},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.22}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.98},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.01},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.27},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.43}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.26}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.43}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.73}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.3}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.21},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.48}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.65},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.57},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.39}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.4},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.55}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.09},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.02},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.94}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":8.02},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.96},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.88}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.62}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.71}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.25},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.72},{\"proton\":\"OH\",\"coupling\":5,\"multiplicity\":\"s,t\",\"shift\":1.32}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.05},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.12},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.26}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.14},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.46},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.06}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.76}],\"name\":\"ethylene_glycol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":0.86},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"br_s\",\"shift\":1.26}],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.88},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.26}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.65}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.49},{\"proton\":\"OH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.09}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.33}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":7},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.27}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.22},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":4.04}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.62},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.29},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.68}],\"name\":\"pyridine\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.07}],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.85},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.76}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.36},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.17},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.25}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.03},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.53}],\"name\":\"triethylamine\"}]},\n    {\"solvent\":\"(CD3)2CO\",\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":2.05}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.84}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.96}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.09}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.05}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.36}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.18}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.13},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.13}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.96},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.22},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.41}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":8.02}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.43}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.87}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.63}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.11},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.41}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.56},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.47},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.28}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.28},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.46}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.97},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.83}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.96},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.94},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.78}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.52}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.59}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.12},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.57},{\"proton\":\"OH\",\"coupling\":5,\"multiplicity\":\"s,t\",\"shift\":3.39}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.97},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.05},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.2}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.07},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.45},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.28}],\"name\":\"ethylene_glycol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":0.87},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"br_s\",\"shift\":1.29}],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.88},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.28}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.59}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.31},{\"proton\":\"OH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.12}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.43}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.88},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.27}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.1},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":3.9}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.58},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.35},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.76}],\"name\":\"pyridine\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.13}],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.79},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.63}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.32},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.5},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.5}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.45}],\"name\":\"triethylamine\"}]},\n    {\"solvent\":\"(CD3)2SO/DMSO\",\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"quint\",\"shift\":2.5}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.33}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.91}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.09}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.07}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.37}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.11},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.19}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.11},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.08}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.87},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.65},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.18},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.36}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":8.32}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.4}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.9}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.76}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.09},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.38}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.51},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.38},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.24}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.24},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.43}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.96},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.94},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.78}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.95},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.89},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.73}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.54}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.57}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.06},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.44},{\"proton\":\"OH\",\"coupling\":5,\"multiplicity\":\"s,t\",\"shift\":4.63}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.99},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.03},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.17}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.07},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.43},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.91}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.34}],\"name\":\"ethylene_glycol\"},{\"shifts\":[],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.86},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.25}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.53}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.16},{\"proton\":\"OH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.01}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.42}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.88},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.27}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.04},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":3.78}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.58},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.39},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.79}],\"name\":\"pyridine\"},{\"shifts\":[],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.76},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.6}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.3},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.18},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.25}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.93},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.43}],\"name\":\"triethylamine\"}]},\n    {\"solvent\":\"C6D6\",\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":7.16}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.4}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.55}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.55}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.55}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.15}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.05},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.55}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.07},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.04}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.05},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.79},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.24},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.38}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.15}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.4}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.9}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.27}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.11},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.26}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.46},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.34},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.11}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.12},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.33}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.6},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.57},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.05}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.63},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.36},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.86}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.68}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.35}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.34}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.65},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.89},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.92}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.58},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":1.81},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.85}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.41}],\"name\":\"ethylene_glycol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":0.92},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"br_s\",\"shift\":1.36}],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.89},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.24}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.4}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.07}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.94}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.86},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.23}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":0.95},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":3.67}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.53},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":6.66},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":6.98}],\"name\":\"pyridine\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.29}],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.4},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.57}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.11},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.02},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.13}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.4}],\"name\":\"triethylamine\"}]},\n    {\"solvent\":\"CD3CN\",\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":1.94}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.13}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.96}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.08}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.96}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.37}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.16},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.18}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.14},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.13}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.97},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.2},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.22},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.39}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.58}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.44}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.81}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.44}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.12},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.42}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.53},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.45},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.29}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.28},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.45}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.97},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.96},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.83}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.92},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.89},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.77}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.5}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.6}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.12},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.54},{\"proton\":\"OH\",\"coupling\":5,\"multiplicity\":\"s,t\",\"shift\":2.47}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.97},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.06},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.2}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.06},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.43},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.51}],\"name\":\"ethylene_glycol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":0.86},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"br_s\",\"shift\":1.27}],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.89},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.28}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.57}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.28},{\"proton\":\"OH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.16}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.31}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.87},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.29}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.09},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":3.87}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.57},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.33},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.73}],\"name\":\"pyridine\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.08}],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.8},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.64}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.33},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.2},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.2}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.45}],\"name\":\"triethylamine\"}]},\n    {\"solvent\":\"CD3OD\",\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":3.31}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.87}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.99}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.15}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.03}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.33}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.4}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.15},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.2}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.92},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.21},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.4}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.9}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.45}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.78}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.49}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.18},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.49}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.61},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.58},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.35}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.35},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.52}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.07},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.31},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.92}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.97},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.99},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.86}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.65}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.66}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.19},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.6}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.01},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.09},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.24}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.12},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.5},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.01}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.59}],\"name\":\"ethylene_glycol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":0.88},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"br_s\",\"shift\":1.29}],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.9},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.29}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.64}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.34}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.34}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.89},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.29}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.5},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":3.92}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.53},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.44},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.85}],\"name\":\"pyridine\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.1}],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.87},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.71}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.32},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.16},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.16}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.05},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.58}],\"name\":\"triethylamine\"}]},\n    {\"solvent\":\"D2O\",\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":4.79}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.08}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.22}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.06}],\"name\":\"acetonitrile\"},{\"shifts\":[],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.24}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.21},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.22}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[],\"name\":\"BHTb\"},{\"shifts\":[],\"name\":\"chloroform\"},{\"shifts\":[],\"name\":\"cyclohexane\"},{\"shifts\":[],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.17},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.56}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.67},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.61},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.37}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.37},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.6}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.08},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.06},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.9}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.92},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.01},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.85}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.71}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.75}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.17},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.65}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.07},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.14},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.24}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.19},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.18},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.26}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.65}],\"name\":\"ethylene_glycol\"},{\"shifts\":[],\"name\":\"grease^f\"},{\"shifts\":[],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.61}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.34}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.4}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.9}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.17},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":4.02}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.52},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.45},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.87}],\"name\":\"pyridine\"},{\"shifts\":[],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.88},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.74}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.99},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.57}],\"name\":\"triethylamine\"}]}];\n\nvar look4 = \"solvent_residual_peak\"+\"H2O\"+\"TMS\";\nvar pascalTriangle = [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]];\nvar patterns = [\"s\",\"d\",\"t\",\"q\",\"quint\",\"h\",\"sept\",\"o\",\"n\"];\n\nfunction removeSignal(peak, noiseSignal){\n\n}\n\nfunction checkImpurity(peakList, impurity){\n    var error = 0.025,i;\n    var found = false;\n    var indexes = new Array(impurity.length);\n    for(i=0;i<impurity.length;i++){\n        found=false;\n        for(var j=0;j<peakList.length;j++){\n            if(Math.abs(impurity[i].shift-peakList[j].delta1)<\n                (error+Math.abs(peakList[j].startX-peakList[j].stopX)/2)&&\n                (impurity[i].multiplicity===\"\"||\n                (impurity[i].multiplicity.indexOf(peakList[j].multiplicity)>=0&&!peakList[j].asymmetric))){\n                found = true;\n                indexes[i]=j;\n                break;\n            }\n        }\n        if(!found)\n            break;\n    }\n\n    var toRemove = [];\n    if(found){\n        for(i=0;i<impurity.length;i++){\n            toRemove.push(indexes[i]);\n        }\n    }\n    else\n        return 0;\n    for(i=0;i<toRemove.length;i++){\n        peakList[toRemove[i]].integralData.value = 0;\n    }\n    return 1;\n}\n\nfunction removeImpurities(peakList, solvent, nH){\n    var impurities = null, i;\n    for(i=0;i<impuritiesList.length;i++){\n        if(impuritiesList[i].solvent.indexOf(solvent)>=0){\n            impurities = impuritiesList[i].impurities;\n            break;\n        }\n    }\n    impurities.push({\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":0.0}],\"name\":\"TMS\"});\n    var nCols = peakList.length;\n    var nRows = impurities.length;\n    var scores = new Array(nRows);\n    for(i=0;i<nRows;i++){\n        if( look4.indexOf(impurities[i].name)>=0){\n            scores[i]=checkImpurity(peakList, impurities[i].shifts);\n        }\n    }\n    //Recompute the integrals\n    var sumObserved=0;\n    for(i=0;i<peakList.length;i++){\n        sumObserved+=peakList[i].integralData.value;\n    }\n    if(sumObserved!=nH){\n        sumObserved=nH/sumObserved;\n        for(i=0;i<peakList.length;i++){\n            peakList[i].integralData.value*=sumObserved;\n        }\n    }\n}\n\nmodule.exports = removeImpurities;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/spectra-data/src/ImpurityRemover.js\n ** module id = 40\n ** module chunks = 0\n **/","'use strict';\n\nexports.FFTUtils = require(\"./FFTUtils\");\nexports.FFT = require('./fftlib');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-fft/src/index.js\n ** module id = 41\n ** module chunks = 0\n **/","var FFT = require('./fftlib');\n\nvar FFTUtils= {\n    DEBUG : false,\n\n    /**\n     * Calculates the inverse of a 2D Fourier transform\n     *\n     * @param ft\n     * @param ftRows\n     * @param ftCols\n     * @return\n     */\n    ifft2DArray : function(ft, ftRows, ftCols){\n        var tempTransform = new Array(ftRows * ftCols);\n        var nRows = ftRows / 2;\n        var nCols = (ftCols - 1) * 2;\n        // reverse transform columns\n        FFT.init(nRows);\n        var tmpCols = {re: new Array(nRows), im: new Array(nRows)};\n        for (var iCol = 0; iCol < ftCols; iCol++) {\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                tmpCols.re[iRow] = ft[(iRow * 2) * ftCols + iCol];\n                tmpCols.im[iRow] = ft[(iRow * 2 + 1) * ftCols + iCol];\n            }\n            //Unnormalized inverse transform\n            FFT.bt(tmpCols.re, tmpCols.im);\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                tempTransform[(iRow * 2) * ftCols + iCol] = tmpCols.re[iRow];\n                tempTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n            }\n        }\n\n        // reverse row transform\n        var finalTransform = new Array(nRows * nCols);\n        FFT.init(nCols);\n        var tmpRows = {re: new Array(nCols), im: new Array(nCols)};\n        var scale = nCols * nRows;\n        for (var iRow = 0; iRow < ftRows; iRow += 2) {\n            tmpRows.re[0] = tempTransform[iRow * ftCols];\n            tmpRows.im[0] = tempTransform[(iRow + 1) * ftCols];\n            for (var iCol = 1; iCol < ftCols; iCol++) {\n                tmpRows.re[iCol] = tempTransform[iRow * ftCols + iCol];\n                tmpRows.im[iCol] = tempTransform[(iRow + 1) * ftCols + iCol];\n                tmpRows.re[nCols - iCol] = tempTransform[iRow * ftCols + iCol];\n                tmpRows.im[nCols - iCol] = -tempTransform[(iRow + 1) * ftCols + iCol];\n            }\n            //Unnormalized inverse transform\n            FFT.bt(tmpRows.re, tmpRows.im);\n\n            var indexB = (iRow / 2) * nCols;\n            for (var iCol = nCols - 1; iCol >= 0; iCol--) {\n                finalTransform[indexB + iCol] = tmpRows.re[iCol] / scale;\n            }\n        }\n        return finalTransform;\n    },\n    /**\n     * Calculates the fourier transform of a matrix of size (nRows,nCols) It is\n     * assumed that both nRows and nCols are a power of two\n     *\n     * On exit the matrix has dimensions (nRows * 2, nCols / 2 + 1) where the\n     * even rows contain the real part and the odd rows the imaginary part of the\n     * transform\n     * @param data\n     * @param nRows\n     * @param nCols\n     * @return\n     */\n    fft2DArray:function(data, nRows, nCols) {\n        var ftCols = (nCols / 2 + 1);\n        var ftRows = nRows * 2;\n        var tempTransform = new Array(ftRows * ftCols);\n        FFT.init(nCols);\n        // transform rows\n        var tmpRows = {re: new Array(nCols), im: new Array(nCols)};\n        var row1 = {re: new Array(nCols), im: new Array(nCols)}\n        var row2 = {re: new Array(nCols), im: new Array(nCols)}\n        var index, iRow0, iRow1, iRow2, iRow3;\n        for (var iRow = 0; iRow < nRows / 2; iRow++) {\n            index = (iRow * 2) * nCols;\n            tmpRows.re = data.slice(index, index + nCols);\n\n            index = (iRow * 2 + 1) * nCols;\n            tmpRows.im = data.slice(index, index + nCols);\n\n            FFT.fft1d(tmpRows.re, tmpRows.im);\n\n            this.reconstructTwoRealFFT(tmpRows, row1, row2);\n            //Now lets put back the result into the output array\n            iRow0 = (iRow * 4) * ftCols;\n            iRow1 = (iRow * 4 + 1) * ftCols;\n            iRow2 = (iRow * 4 + 2) * ftCols;\n            iRow3 = (iRow * 4 + 3) * ftCols;\n            for (var k = ftCols - 1; k >= 0; k--) {\n                tempTransform[iRow0 + k] = row1.re[k];\n                tempTransform[iRow1 + k] = row1.im[k];\n                tempTransform[iRow2 + k] = row2.re[k];\n                tempTransform[iRow3 + k] = row2.im[k];\n            }\n        }\n\n        //console.log(tempTransform);\n        row1 = null;\n        row2 = null;\n        // transform columns\n        var finalTransform = new Array(ftRows * ftCols);\n        FFT.init(nRows);\n        var tmpCols = {re: new Array(nRows), im: new Array(nRows)};\n        for (var iCol = ftCols - 1; iCol >= 0; iCol--) {\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                tmpCols.re[iRow] = tempTransform[(iRow * 2) * ftCols + iCol];\n                tmpCols.im[iRow] = tempTransform[(iRow * 2 + 1) * ftCols + iCol];\n            }\n            FFT.fft1d(tmpCols.re, tmpCols.im);\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                finalTransform[(iRow * 2) * ftCols + iCol] = tmpCols.re[iRow];\n                finalTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n            }\n        }\n\n        //console.log(finalTransform);\n        return finalTransform;\n\n    },\n    /**\n     *\n     * @param fourierTransform\n     * @param realTransform1\n     * @param realTransform2\n     *\n     * Reconstructs the individual Fourier transforms of two simultaneously\n     * transformed series. Based on the Symmetry relationships (the asterisk\n     * denotes the complex conjugate)\n     *\n     * F_{N-n} = F_n^{*} for a purely real f transformed to F\n     *\n     * G_{N-n} = G_n^{*} for a purely imaginary g transformed to G\n     *\n     */\n    reconstructTwoRealFFT:function(fourierTransform, realTransform1, realTransform2) {\n        var length = fourierTransform.re.length;\n\n        // the components n=0 are trivial\n        realTransform1.re[0] = fourierTransform.re[0];\n        realTransform1.im[0] = 0.0;\n        realTransform2.re[0] = fourierTransform.im[0];\n        realTransform2.im[0] = 0.0;\n        var rm, rp, im, ip, j;\n        for (var i = length / 2; i > 0; i--) {\n            j = length - i;\n            rm = 0.5 * (fourierTransform.re[i] - fourierTransform.re[j]);\n            rp = 0.5 * (fourierTransform.re[i] + fourierTransform.re[j]);\n            im = 0.5 * (fourierTransform.im[i] - fourierTransform.im[j]);\n            ip = 0.5 * (fourierTransform.im[i] + fourierTransform.im[j]);\n            realTransform1.re[i] = rp;\n            realTransform1.im[i] = im;\n            realTransform1.re[j] = rp;\n            realTransform1.im[j] = -im;\n            realTransform2.re[i] = ip;\n            realTransform2.im[i] = -rm;\n            realTransform2.re[j] = ip;\n            realTransform2.im[j] = rm;\n        }\n    },\n\n    /**\n     * In place version of convolute 2D\n     *\n     * @param ftSignal\n     * @param ftFilter\n     * @param ftRows\n     * @param ftCols\n     * @return\n     */\n    convolute2DI:function(ftSignal, ftFilter, ftRows, ftCols) {\n        var re, im;\n        for (var iRow = 0; iRow < ftRows / 2; iRow++) {\n            for (var iCol = 0; iCol < ftCols; iCol++) {\n                //\n                re = ftSignal[(iRow * 2) * ftCols + iCol]\n                * ftFilter[(iRow * 2) * ftCols + iCol]\n                - ftSignal[(iRow * 2 + 1) * ftCols + iCol]\n                * ftFilter[(iRow * 2 + 1) * ftCols + iCol];\n                im = ftSignal[(iRow * 2) * ftCols + iCol]\n                * ftFilter[(iRow * 2 + 1) * ftCols + iCol]\n                + ftSignal[(iRow * 2 + 1) * ftCols + iCol]\n                * ftFilter[(iRow * 2) * ftCols + iCol];\n                //\n                ftSignal[(iRow * 2) * ftCols + iCol] = re;\n                ftSignal[(iRow * 2 + 1) * ftCols + iCol] = im;\n            }\n        }\n    },\n    /**\n     *\n     * @param data\n     * @param kernel\n     * @param nRows\n     * @param nCols\n     * @returns {*}\n     */\n    convolute:function(data, kernel, nRows, nCols){\n        var ftSpectrum = new Array(nCols * nRows);\n        for (var i = 0; i<nRows * nCols; i++){\n            ftSpectrum[i] = data[i];\n        }\n\n        ftSpectrum = this.fft2DArray(ftSpectrum, nRows, nCols);\n\n        var dim = kernel.length;\n        var ftFilterData = new Array(nCols * nRows);\n        for(var i=0;i<nCols * nRows;i++){\n            ftFilterData[i]=0;\n        }\n\n        var iRow, iCol;\n        var shift = (dim - 1) / 2;\n        //console.log(dim);\n        for (var ir = 0; ir < dim; ir++) {\n            iRow = (ir - shift + nRows) % nRows;\n            for (var ic = 0; ic < dim; ic++) {\n                iCol = (ic - shift + nCols) % nCols;\n                ftFilterData[iRow * nCols + iCol] = kernel[ir][ic];\n            }\n        }\n\n        ftFilterData = this.fft2DArray(ftFilterData, nRows, nCols);\n\n        var ftRows = nRows * 2;\n        var ftCols = nCols / 2 + 1;\n        this.convolute2DI(ftSpectrum, ftFilterData, ftRows, ftCols);\n\n        return  this.ifft2DArray(ftSpectrum, ftRows, ftCols);\n    }\n}\n\nmodule.exports = FFTUtils;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-fft/src/FFTUtils.js\n ** module id = 42\n ** module chunks = 0\n **/","/**\n * Fast Fourier Transform module\n * 1D-FFT/IFFT, 2D-FFT/IFFT (radix-2)\n */\nvar FFT = (function(){\n  var FFT;  \n  \n  if(typeof exports !== 'undefined') {\n    FFT = exports;   // for CommonJS\n  } else {\n    FFT = {};\n  }\n  \n  var version = {\n    release: '0.3.0',\n    date: '2013-03'\n  };\n  FFT.toString = function() {\n    return \"version \" + version.release + \", released \" + version.date;\n  };\n\n  // core operations\n  var _n = 0,          // order\n      _bitrev = null,  // bit reversal table\n      _cstb = null;    // sin/cos table\n\n  var core = {\n    init : function(n) {\n      if(n !== 0 && (n & (n - 1)) === 0) {\n        _n = n;\n        core._initArray();\n        core._makeBitReversalTable();\n        core._makeCosSinTable();\n      } else {\n        throw new Error(\"init: radix-2 required\");\n      }\n    },\n    // 1D-FFT\n    fft1d : function(re, im) {\n      core.fft(re, im, 1);\n    },\n    // 1D-IFFT\n    ifft1d : function(re, im) {\n      var n = 1/_n;\n      core.fft(re, im, -1);\n      for(var i=0; i<_n; i++) {\n        re[i] *= n;\n        im[i] *= n;\n      }\n    },\n     // 1D-IFFT\n    bt1d : function(re, im) {\n      core.fft(re, im, -1);\n    },\n    // 2D-FFT Not very useful if the number of rows have to be equal to cols\n    fft2d : function(re, im) {\n      var tre = [],\n          tim = [],\n          i = 0;\n      // x-axis\n      for(var y=0; y<_n; y++) {\n        i = y*_n;\n        for(var x1=0; x1<_n; x1++) {\n          tre[x1] = re[x1 + i];\n          tim[x1] = im[x1 + i];\n        }\n        core.fft1d(tre, tim);\n        for(var x2=0; x2<_n; x2++) {\n          re[x2 + i] = tre[x2];\n          im[x2 + i] = tim[x2];\n        }\n      }\n      // y-axis\n      for(var x=0; x<_n; x++) {\n        for(var y1=0; y1<_n; y1++) {\n          i = x + y1*_n;\n          tre[y1] = re[i];\n          tim[y1] = im[i];\n        }\n        core.fft1d(tre, tim);\n        for(var y2=0; y2<_n; y2++) {\n          i = x + y2*_n;\n          re[i] = tre[y2];\n          im[i] = tim[y2];\n        }\n      }\n    },\n    // 2D-IFFT\n    ifft2d : function(re, im) {\n      var tre = [],\n          tim = [],\n          i = 0;\n      // x-axis\n      for(var y=0; y<_n; y++) {\n        i = y*_n;\n        for(var x1=0; x1<_n; x1++) {\n          tre[x1] = re[x1 + i];\n          tim[x1] = im[x1 + i];\n        }\n        core.ifft1d(tre, tim);\n        for(var x2=0; x2<_n; x2++) {\n          re[x2 + i] = tre[x2];\n          im[x2 + i] = tim[x2];\n        }\n      }\n      // y-axis\n      for(var x=0; x<_n; x++) {\n        for(var y1=0; y1<_n; y1++) {\n          i = x + y1*_n;\n          tre[y1] = re[i];\n          tim[y1] = im[i];\n        }\n        core.ifft1d(tre, tim);\n        for(var y2=0; y2<_n; y2++) {\n          i = x + y2*_n;\n          re[i] = tre[y2];\n          im[i] = tim[y2];\n        }\n      }\n    },\n    // core operation of FFT\n    fft : function(re, im, inv) {\n      var d, h, ik, m, tmp, wr, wi, xr, xi,\n          n4 = _n >> 2;\n      // bit reversal\n      for(var l=0; l<_n; l++) {\n        m = _bitrev[l];\n        if(l < m) {\n          tmp = re[l];\n          re[l] = re[m];\n          re[m] = tmp;\n          tmp = im[l];\n          im[l] = im[m];\n          im[m] = tmp;\n        }\n      }\n      // butterfly operation\n      for(var k=1; k<_n; k<<=1) {\n        h = 0;\n        d = _n/(k << 1);\n        for(var j=0; j<k; j++) {\n          wr = _cstb[h + n4];\n          wi = inv*_cstb[h];\n          for(var i=j; i<_n; i+=(k<<1)) {\n            ik = i + k;\n            xr = wr*re[ik] + wi*im[ik];\n            xi = wr*im[ik] - wi*re[ik];\n            re[ik] = re[i] - xr;\n            re[i] += xr;\n            im[ik] = im[i] - xi;\n            im[i] += xi;\n          }\n          h += d;\n        }\n      }\n    },\n    // initialize the array (supports TypedArray)\n    _initArray : function() {\n      if(typeof Uint32Array !== 'undefined') {\n        _bitrev = new Uint32Array(_n);\n      } else {\n        _bitrev = [];\n      }\n      if(typeof Float64Array !== 'undefined') {\n        _cstb = new Float64Array(_n*1.25);\n      } else {\n        _cstb = [];\n      }\n    },\n    // zero padding\n    _paddingZero : function() {\n      // TODO\n    },\n    // makes bit reversal table\n    _makeBitReversalTable : function() {\n      var i = 0,\n          j = 0,\n          k = 0;\n      _bitrev[0] = 0;\n      while(++i < _n) {\n        k = _n >> 1;\n        while(k <= j) {\n          j -= k;\n          k >>= 1;\n        }\n        j += k;\n        _bitrev[i] = j;\n      }\n    },\n    // makes trigonometiric function table\n    _makeCosSinTable : function() {\n      var n2 = _n >> 1,\n          n4 = _n >> 2,\n          n8 = _n >> 3,\n          n2p4 = n2 + n4,\n          t = Math.sin(Math.PI/_n),\n          dc = 2*t*t,\n          ds = Math.sqrt(dc*(2 - dc)),\n          c = _cstb[n4] = 1,\n          s = _cstb[0] = 0;\n      t = 2*dc;\n      for(var i=1; i<n8; i++) {\n        c -= dc;\n        dc += t*c;\n        s += ds;\n        ds -= t*s;\n        _cstb[i] = s;\n        _cstb[n4 - i] = c;\n      }\n      if(n8 !== 0) {\n        _cstb[n8] = Math.sqrt(0.5);\n      }\n      for(var j=0; j<n4; j++) {\n        _cstb[n2 - j]  = _cstb[j];\n      }\n      for(var k=0; k<n2p4; k++) {\n        _cstb[k + n2] = -_cstb[k];\n      }\n    }\n  };\n  // aliases (public APIs)\n  var apis = ['init', 'fft1d', 'ifft1d', 'fft2d', 'ifft2d'];\n  for(var i=0; i<apis.length; i++) {\n    FFT[apis[i]] = core[apis[i]];\n  }\n  FFT.bt = core.bt1d;\n  FFT.fft = core.fft1d;\n  FFT.ifft = core.ifft1d;\n  \n  return FFT;\n}).call(this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-fft/src/fftlib.js\n ** module id = 43\n ** module chunks = 0\n **/","'use strict';\n/**\n * Created by abol on 4/20/16.\n */\nmodule.exports.fourierTransform = require(\"./fourierTransform\");\nmodule.exports.zeroFilling = require(\"./zeroFilling\");\nmodule.exports.apodization = require(\"./apodization\");\nmodule.exports.phaseCorrection = require(\"./phaseCorrection\");\nmodule.exports.digitalFilter = require(\"./digitalFilter\");\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/spectra-data/src/filters/Filters.js\n ** module id = 44\n ** module chunks = 0\n **/","'use strict';\n/**\n * Created by abol on 4/20/16.\n */\nvar fft = require(\"ml-fft\");\n\nfunction fourierTransform(spectraData){\n    //console.log(spectraData);\n\n    var nbPoints = spectraData.getNbPoints();\n    var nSubSpectra = spectraData.getNbSubSpectra() / 2;\n    var spectraType = \"NMR SPECTRUM\";//spectraData.TYPE_NMR_SPECTRUM;\n    var FFT = fft.FFT;\n    if (nSubSpectra > 1)\n        spectraType = \"nD NMR SPECTRUM\";//spectraData.TYPE_2DNMR_SPECTRUM;\n\n    FFT.init(nbPoints);\n\n\n    var fcor = spectraData.getParamDouble(\"$FCOR\", 0.0);\n    //var tempArray = new Array(nbPoints / 2);\n    for (var iSubSpectra = 0; iSubSpectra < nSubSpectra; iSubSpectra++)\n    {\n        var re = spectraData.getYData(2 * iSubSpectra);\n        var im = spectraData.getYData(2 * iSubSpectra + 1);\n        if (false) {\n            console.log(\"firstPoint: (\" + re[0] + \",\" + im[0] + \")\");\n            console.log(\"fcor: \" + fcor);\n        }\n        re[0] *= fcor;\n        im[0] *= fcor;\n\n        FFT.fft(re, im);\n        re = re.concat(re.slice(0,(nbPoints+1)/2));\n        re.splice(0, (nbPoints+1)/2);\n        im = im.concat(im.slice(0,(nbPoints+1)/2));\n        im.splice(0, (nbPoints+1)/2);\n\n        spectraData.setActiveElement(2 * iSubSpectra);\n        updateSpectra(spectraData, spectraType);\n\n        spectraData.setActiveElement(2 * iSubSpectra + 1);\n        updateSpectra(spectraData, spectraType);\n    }\n    //TODO For Alejandro\n    //Now we can try to apply the FFt on the second dimension\n    if(spectraData.is2D()){\n        var mode = spectraData.getParam(\".ACQUISITION SCHEME\");\n        switch(mode){\n            case 1://\"State-TPP\"\n                break;\n            case 2://State\n                break;\n            case 3://Echo-Antiecho\n                break;\n            defaut:\n                //QF\n                //Does not transform in the indirect dimension\n            break;\n\n        }\n    }\n    spectraData.setActiveElement(0);\n    return spectraData;\n}\n\nfunction updateSpectra(spectraData, spectraType){\n    var baseFrequency = spectraData.getParamDouble(\"$BF1\", NaN);\n    var spectralFrequency = spectraData.getParamDouble(\"$SFO1\", NaN);\n    var spectralWidth = spectraData.getParamDouble(\"$SW\", NaN);\n    var xMiddle = ((spectralFrequency - baseFrequency) / baseFrequency )* 1e6;\n    var dx = 0.5 * spectralWidth * spectralFrequency / baseFrequency;\n\n    spectraData.setDataType(spectraType);\n    spectraData.setFirstX(xMiddle + dx);\n    spectraData.setLastX(xMiddle - dx);\n    spectraData.setXUnits(\"PPM\");\n\n    var x = spectraData.getXData();\n    var tmp = xMiddle + dx;\n    dx = -2*dx/(x.length-1);\n    for(var i=0;i< x.length;i++){\n        x[i]= tmp;\n        tmp+=dx;\n    }\n\n    //TODO update minmax in Y axis\n}\n\nmodule.exports = fourierTransform;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/spectra-data/src/filters/fourierTransform.js\n ** module id = 45\n ** module chunks = 0\n **/","'use strict';\n/**\n * Created by abol on 4/20/16.\n */\n\nfunction zeroFilling(spectraData, zeroFillingX, zeroFillingY){\n    var nbSubSpectra = spectraData.getNbSubSpectra();\n    //var zeroPadding = spectraData.getParamDouble(\"$$ZEROPADDING\", 0);\n    var nbXPoints, lastX, deltaX, k, x, y;\n    if (zeroFillingX != 0){\n        for (var iSubSpectra = 0 ; iSubSpectra < nbSubSpectra; iSubSpectra++){\n            spectraData.setActiveElement(iSubSpectra);\n            nbXPoints = spectraData.getNbPoints();\n            y = spectraData.getYData();\n            x = spectraData.getXData();\n            lastX = spectraData.getLastX();\n            deltaX = (lastX-x[0])/(nbXPoints-1);\n            for (k = nbXPoints; k < zeroFillingX; k++){\n                y.push(0);\n                x.push(lastX+deltaX);\n            }\n            if (zeroFillingX < nbXPoints){\n                y.splice(zeroFillingX, y.length-1);\n                x.splice(zeroFillingX, x.length-1);\n            }\n            spectraData.setFirstX(x[0]);\n            spectraData.setLastX(x[x.length-1]);\n        }\n    }\n    spectraData.setActiveElement(0);\n    return spectraData;\n    // @TODO implement zeroFillingY\n}\nmodule.exports = zeroFilling;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/spectra-data/src/filters/zeroFilling.js\n ** module id = 46\n ** module chunks = 0\n **/","'use strict';\n/**\n * Created by acastillo on 4/26/16.\n */\n\nfunction apodization(spectraData, parameters){\n    //org.cheminfo.hook.nemo.filters.ApodizationFilter\n\n    /*public String toString() {\n     switch (this) {\n     case NONE:\n     return \"None\";\n     case EXPONENTIAL:\n     return \"Exponential\";\n     case GAUSSIAN:\n     return \"Gaussian\";\n     case TRAF:\n     return \"TRAF\";\n     case SINE_BELL:\n     return \"Sine Bell\";\n     case SINE_BELL_SQUARED:\n     return \"Sine Bell Squared\";\n     default:\n     return \"\";\n     }\n     }*/\n}\n\nmodule.exports = apodization;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/spectra-data/src/filters/apodization.js\n ** module id = 47\n ** module chunks = 0\n **/","'use strict';\n/**\n * Created by acastillo on 4/26/16.\n */\nfunction phaseCorrection(spectraData, phi0, phi1){\n    //System.out.println(spectraData.toString());\n    var nbPoints = spectraData.getNbPoints();\n    var reData = spectraData.getYData(0);\n    var imData = spectraData.getYData(1);\n    //var corrections = spectraData.getParam(\"corrections\");\n\n    //for(var k=0;k<corrections.length;k++){\n    //    Point2D phi = corrections.elementAt(k);\n\n        //double phi0 = phi.getX();\n        //double phi1 = phi.getY();\n\n    if(false) System.out.println(\" ph0 = \"+phi0);\n    if(false) System.out.println(\" ph1 = \"+phi1);\n\n    var delta = phi1 / nbPoints;\n    var alpha = 2 * Math.pow(Math.sin(delta / 2), 2);\n    var beta = Math.sin(delta);\n    var cosTheta = Math.cos(phi0);\n    var sinTheta = Math.sin(phi0);\n    var cosThetaNew, sinThetaNew;\n\n    var reTmp, imTmp;\n    var index;\n        for (var i = 0; i < nbPoints; i++) {\n            index = nbPoints - i - 1;\n            index = i;\n            reTmp = reData[index] * cosTheta - imData[index] * sinTheta;\n            imTmp = reData[index] * sinTheta + imData[index] * cosTheta;\n            reData[index] = reTmp;\n            imData[index] = imTmp;\n            // calculate angles i+1 from i\n            cosThetaNew = cosTheta - (alpha * cosTheta + beta * sinTheta);\n            sinThetaNew = sinTheta - (alpha * sinTheta - beta * cosTheta);\n            cosTheta = cosThetaNew;\n            sinTheta = sinThetaNew;\n        }\n        //toApply--;\n    //}\n\n    spectraData.resetMinMax();\n    //spectraData.updateDefaults();\n    //spectraData.updateY();\n    spectraData.putParam(\"PHC0\", phi0);\n    spectraData.putParam(\"PHC1\", phi1);\n}\n\nmodule.exports = phaseCorrection;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/spectra-data/src/filters/phaseCorrection.js\n ** module id = 48\n ** module chunks = 0\n **/","'use strict';\n/**\n * Created by acastillo on 4/26/16.\n */\nvar rotate = require(\"./rotate\");\n\nfunction digitalFilter(spectraData, options){\n    var nbPoints = 0;\n    if(options.nbPoints){\n        nbPoints = options.nbPoints;\n    }\n    else{\n        if(options.brukerFilter){\n            //TODO Determine the number of points to shift, or the ph1 correction\n            //based on DECIM and DSPSVF parameters\n            nbPoints = 0;\n        }\n    }\n\n    var nbSubSpectra = spectraData.getNbSubSpectra();\n    if (nbPoints != 0){\n        for (var iSubSpectra = 0 ; iSubSpectra < nbSubSpectra; iSubSpectra++){\n            spectraData.setActiveElement(iSubSpectra);\n            rotate(spectraData.getYData(),nbPoints);\n            if(options.rotateX){\n                rotate(spectraData.getXData(),nbPoints);\n                spectraData.setFirstX(spectraData.getX(0));\n                spectraData.setLastX(spectraData.getX(spectraData.getNbPoints()-1));\n            }\n        }\n    }\n    spectraData.setActiveElement(0);\n    return spectraData;\n}\n\nmodule.exports = digitalFilter;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/spectra-data/src/filters/digitalFilter.js\n ** module id = 49\n ** module chunks = 0\n **/","'use strict';\n/**\n * Created by acastillo on 4/26/16.\n */\n/**\n * This function performs a circular shift of the input object without realocating memory.\n * Positive values of shifts will shift to the right and negative values will do to the left\n * @example rotate([1,2,3,4],1) -> [4,1,2,3]\n * @example rotate([1,2,3,4],-1) -> [2,3,4,1]\n * @param array\n */\nfunction rotate(array,shift){\n    var nbPoints = array.length;\n    //Lets calculate the lest amount of points to shift.\n    //It decreases the amount of validations in the loop\n    shift = shift%nbPoints;\n\n    if(Math.abs(shift)>nbPoints/2){\n        shift = shift>0?shift-nbPoints:shift+nbPoints;\n    }\n\n    if(shift!=0){\n        var currentIndex=0, nextIndex=shift;\n        var toMove = nbPoints;\n        var current = array[currentIndex], next;\n        var lastFirstIndex = shift;\n        var direction = shift>0?1:-1;\n\n        while(toMove>0){\n            nextIndex = putInRange(nextIndex,nbPoints);\n            next = array[nextIndex];\n            array[nextIndex] = current;\n            nextIndex+=shift;\n            current = next;\n            toMove--;\n\n            if(nextIndex==lastFirstIndex){\n                nextIndex = putInRange(nextIndex+direction,nbPoints);\n                lastFirstIndex = nextIndex;\n                currentIndex = putInRange(nextIndex-shift,nbPoints);\n                current = array[currentIndex];\n            }\n        }\n    }\n}\n\nfunction putInRange(value, nbPoints){\n    if(value<0)\n        value+=nbPoints;\n    if(value>=nbPoints)\n        value-=nbPoints;\n    return value;\n}\n\nmodule.exports = rotate;\n\n\n/*var foo = [1,2,3,4,5,6];\nrotate(foo,-4);\nconsole.log(foo);*/\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/spectra-data/src/filters/rotate.js\n ** module id = 50\n ** module chunks = 0\n **/","'use strict';\n\nvar SD = require('./SD');\nvar PeakPicking2D = require('./PeakPicking2D');\nvar PeakOptimizer = require(\"./PeakOptimizer\");\nvar JcampConverter=require(\"jcampconverter\");\nvar stat = require(\"ml-stat\");\n\n/**\n * Construct the object from the given sd object(output of the jcampconverter or brukerconverter filter)\n * @param sd\n * @constructor\n */\nfunction NMR2D(sd) {\n    SD.call(this, sd); // Héritage\n}\n\nNMR2D.prototype = Object.create(SD.prototype);\nNMR2D.prototype.constructor = NMR2D;\n\n/**\n * @function fromJcamp(jcamp,options)\n * Construct the object from the given jcamp.\n * @param jcamp\n * @param options\n * @option xy\n * @option keepSpectra\n * @option keepRecordsRegExp\n * @returns {NMR2D}\n */\nNMR2D.fromJcamp = function(jcamp,options) {\n    options = options || {xy:true,keepSpectra:true,keepRecordsRegExp:/^.+$/};\n    var spectrum= JcampConverter.convert(jcamp,options);\n    return new NMR2D(spectrum);\n}\n\n/**\n * @function isHomoNuclear()\n * Returns true if the it is an homo-nuclear experiment\n * @returns {boolean}\n */\nNMR2D.prototype.isHomoNuclear=function(){\n    return this.sd.xType==this.sd.yType;\n}\n\n/**\n * @function observeFrequencyX()\n * Returns the observe frequency in the direct dimension\n * @returns {*}\n */\nNMR2D.prototype.observeFrequencyX=function(){\n    return this.sd.spectra[0].observeFrequency;\n}\n/**\n * @function observeFrequencyY()\n * Returns the observe frequency in the indirect dimension\n * @returns {*}\n */\nNMR2D.prototype.observeFrequencyY=function(){\n    return this.sd.indirectFrequency;\n}\n\n/**\n * @function getSolventName()\n * Returns the solvent name.\n * @returns {string|XML}\n */\nNMR2D.prototype.getSolventName=function(){\n    return (this.sd.info[\".SOLVENTNAME\"]||this.sd.info[\"$SOLVENT\"]).replace(\"<\",\"\").replace(\">\",\"\");\n}\n\n/**\n * @function getXUnits()\n * This function returns the units of the direct dimension. It overrides the SD getXUnits function\n * @returns {ntuples.units|*|b.units}\n */\nNMR2D.prototype.getXUnits = function(){\n    return this.sd.ntuples[1].units;\n}\n/**\n * @function getYUnits()\n * This function returns the units of the indirect dimension. It overrides the SD getYUnits function\n * @returns {ntuples.units|*|b.units}\n */\nNMR2D.prototype.getYUnits = function(){\n    return this.sd.ntuples[0].units;\n}\n/**\n * @function getZUnits()\n * Returns the units of the dependent variable\n * @returns {ntuples.units|*|b.units}\n */\nNMR2D.prototype.getZUnits = function(){\n    return this.sd.ntuples[2].units;\n}\n/**\n * @function getLastY()\n * Returns the min value in the indirect dimension.\n * @returns {sd.minMax.maxY}\n */\nNMR2D.prototype.getLastY = function(){\n    return this.sd.minMax.maxY;\n}\n/**\n * @function getFirstY()\n * Returns the min value in the indirect dimension.\n * @returns {sd.minMax.minY}\n */\nNMR2D.prototype.getFirstY = function(){\n    return this.sd.minMax.minY;\n}\n/**\n * @function getDeltaY()\n * Returns the separation between 2 consecutive points in the indirect domain\n * @returns {number}\n */\nNMR2D.prototype.getDeltaY=function(){\n    return ( this.getLastY()-this.getFirstY()) / (this.getNbSubSpectra()-1);\n}\n\n/**\n * @function nmrPeakDetection2D(options)\n * This function process the given spectraData and tries to determine the NMR signals. \n + Returns an NMRSignal2D array containing all the detected 2D-NMR Signals\n * @param\toptions:+Object\t\t\tObject containing the options\n * @option\tthresholdFactor:number\tA factor to scale the automatically determined noise threshold.\n * @returns [*]\tset of NMRSignal2D\n */\nNMR2D.prototype.nmrPeakDetection2D=function(options){\n    options = options||{};\n    if(!options.thresholdFactor)\n        options.thresholdFactor=1;\n    var id = Math.round(Math.random()*255);\n    if(options.idPrefix){\n        id=options.idPrefix;\n    }\n    var peakList = PeakPicking2D.findPeaks2D(this, options.thresholdFactor);\n\n    //lets add an unique ID for each peak.\n    for(var i=0;i<peakList.length;i++){\n        peakList[i]._highlight=[id+\"_\"+i];\n        peakList[i].signalID = id+\"_\"+i;\n    }\n    if(options.references)\n        PeakOptimizer.alignDimensions(peakList,options.references);\n\n    if(options.format===\"new\"){\n        var newSignals = new Array(peakList.length);\n        var minMax1, minMax2;\n        for(var k=peakList.length-1;k>=0;k--){\n            var signal = peakList[k];\n            newSignals[k]={\n                fromTo:signal.fromTo,\n                integral:signal.intensity||1,\n                remark:\"\",\n                signal:[{\n                    peak:signal.peaks,\n                    delta:[signal.shiftX, signal.shiftY]\n                }],\n                _highlight:signal._highlight,\n                signalID:signal.signalID,\n            };\n        }\n        peakList = newSignals;\n    }\n\n\n    return peakList;\n}\n\n/**\n * @function getNMRPeakThreshold(nucleus)\n * Returns the noise factor depending on the nucleus.\n * @param nucleus\n * @returns {number}\n */\nNMR2D.prototype.getNMRPeakThreshold=function(nucleus) {\n    if (nucleus == \"1H\")\n        return 3.0;\n    if (nucleus ==\"13C\")\n        return 5.0;\n    return 1.0;\n}\n\n/**\n * @function getNucleus(dim)\n * Returns the observed nucleus in the specified dimension\n * @param dim\n * @returns {string}\n */\nNMR2D.prototype.getNucleus=function(dim){\n    if(dim==1)\n        return this.sd.xType;\n    if(dim==2)\n        return this.sd.yType;\n    return this.sd.xType;\n}\n\n\n/**\n * @function zeroFilling(nPointsX [,nPointsY])\n * This function increase the size of the spectrum, filling the new positions with zero values. Doing it one\n * could increase artificially the spectral resolution.\n * @param nPointsX Number of new zero points in the direct dimension\n * @param nPointsY Number of new zero points in the indirect dimension\n * @returns this object\n */\nNMR2D.prototype.zeroFilling=function(nPointsX, nPointsY) {\n    return Filters.zeroFilling(this,nPointsX, nPointsY);\n}\n\n/**\n * @function brukerFilter()\n * This filter applies a circular shift(phase 1 correction in the time domain) to an NMR FID spectrum that\n * have been obtained on spectrometers using the Bruker digital filters. The amount of shift depends on the\n * parameters DECIM and DSPFVS. This spectraData have to be of type NMR_FID\n * @returns this object\n */\nNMR2D.prototype.brukerFilter=function() {\n    return Filters.digitalFilter(this, {\"brukerFilter\":true});\n}\n\n/**\n * @function digitalFilter(options)\n * This filter applies a circular shift(phase 1 correction in the time domain) to an NMR FID spectrum that\n * have been obtained on spectrometers using the Bruker digital filters. The amount of shift depends on the\n * parameters DECIM and DSPFVS. This spectraData have to be of type NMR_FID\n * @option nbPoints: The number of points to shift. Positive values will shift the values to the rigth\n * and negative values will do to the left.\n * @option brukerSpectra\n * @returns this object\n */\nNMR2D.prototype.digitalFilter=function(options) {\n    return Filters.digitalFilter(this, options);\n}\n\n\n/**\n * @function fourierTransform()\n * Fourier transforms the given spectraData (Note. no 2D handling yet) this spectraData have to be of type NMR_FID or 2DNMR_FID\n * @returns this object\n */\nNMR2D.prototype.fourierTransform=function( ) {\n    return Filters.fourierTransform(this);\n}\n\n/**\n * @function postFourierTransform(ph1corr)\n * This filter makes an phase 1 correction that corrects the problem of the spectra that has been obtained\n * on spectrometers using the Bruker digital filters. This method is used in cases when the BrukerSpectra\n * filter could not find the correct number of points to perform a circular shift.\n * The actual problem is that not all of the spectra has the necessary parameters for use only one method for\n * correcting the problem of the Bruker digital filters.\n * @param spectraData A fourier transformed spectraData.\n * @param ph1corr Phase 1 correction value in radians.\n * @returns this object\n */\nNMR2D.prototype.postFourierTransform=function(ph1corr) {\n    return Filters.phaseCorrection(0,ph1corr);\n}\n\nmodule.exports = NMR2D;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/spectra-data/src/NMR2D.js\n ** module id = 51\n ** module chunks = 0\n **/","'use strict';\n\nvar lib = require(\"ml-fft\");\nvar PeakOptimizer = require(\"./PeakOptimizer\");\nvar SimpleClustering =  require(\"./SimpleClustering\");\nvar StatArray = require('ml-stat/array');\nvar FFTUtils = lib.FFTUtils;\n\nvar PeakPicking2D= {\n    DEBUG : false,\n    smallFilter : [\n        [0, 0, 1, 2, 2, 2, 1, 0, 0],\n        [0, 1, 4, 7, 7, 7, 4, 1, 0],\n        [1, 4, 5, 3, 0, 3, 5, 4, 1],\n        [2, 7, 3, -12, -23, -12, 3, 7, 2],\n        [2, 7, 0, -23, -40, -23, 0, 7, 2],\n        [2, 7, 3, -12, -23, -12, 3, 7, 2],\n        [1, 4, 5, 3, 0, 3, 5, 4, 1],\n        [0, 1, 3, 7, 7, 7, 3, 1, 0],\n        [0, 0, 1, 2, 2, 2, 1, 0, 0]],\n\n\n    //How noisy is the spectrum depending on the kind of experiment.\n    getLoGnStdDevNMR : function(spectraData) {\n    if (spectraData.isHomoNuclear())\n        return 1.5\n    else\n        return 3;\n    },\n\n    findPeaks2D : function(spectraData, thresholdFactor){\n        if(thresholdFactor==0)\n            thresholdFactor=1;\n        if(thresholdFactor<0)\n            thresholdFactor=-thresholdFactor;\n        var nbPoints = spectraData.getNbPoints();\n        var nbSubSpectra = spectraData.getNbSubSpectra();\n\n        var data = new Array(nbPoints * nbSubSpectra);\n        //var data = new Array(nbPoints * nbSubSpectra/2);\n\n        var isHomonuclear = spectraData.isHomoNuclear();\n\n        //var sum = new Array(nbPoints);\n\n        for (var iSubSpectra = 0; iSubSpectra < nbSubSpectra; iSubSpectra++) {\n            var spectrum = spectraData.getYData(iSubSpectra);\n            for (var iCol = 0; iCol < nbPoints; iCol++) {\n                if(isHomonuclear){\n                    data[iSubSpectra * nbPoints + iCol] =(spectrum[iCol]>0?spectrum[iCol]:0);\n                }\n                else{\n                    data[iSubSpectra * nbPoints + iCol] =Math.abs(spectrum[iCol]);\n                }\n            }\n        }\n\n        var nStdDev = this.getLoGnStdDevNMR(spectraData);\n        if(isHomonuclear){\n            var convolutedSpectrum = this.convoluteWithLoG(data, nbSubSpectra, nbPoints);\n            var peaksMC1 = this.findPeaks2DLoG(data, convolutedSpectrum, nbSubSpectra, nbPoints, nStdDev*thresholdFactor);//)1.5);\n            var peaksMax1 = this.findPeaks2DMax(data, convolutedSpectrum, nbSubSpectra, nbPoints, (nStdDev+0.5)*thresholdFactor);//2.0);\n            for(var i=0;i<peaksMC1.length;i++)\n                peaksMax1.push(peaksMC1[i]);\n            //console.log(peaksMax1);\n            return PeakOptimizer.enhanceSymmetry(this.createSignals2D(peaksMax1,spectraData,24));\n\n        }\n        else{\n            var convolutedSpectrum = this.convoluteWithLoG(data, nbSubSpectra, nbPoints);\n            var peaksMC1 = this.findPeaks2DLoG(data, convolutedSpectrum, nbSubSpectra, nbPoints, nStdDev*thresholdFactor);\n            //Peak2D[] peaksMC1 = PeakPicking2D.findPeaks2DMax(data, nbSubSpectra, nbPoints, (nStdDev+0.5)*thresholdFactor);\n            //Remove peaks with less than 3% of the intensity of the highest peak\n            return this.createSignals2D(PeakOptimizer.clean(peaksMC1, 0.05), spectraData,24);\n        }\n\n    },\n    /**\n     Calculates the 1st derivative of the 2D matrix, using the LoG kernel approximation\n     */\n    convoluteWithLoG : function(inputSpectrum, nRows, nCols){\n        var ftSpectrum = new Array(nCols * nRows);\n        for (var i = nRows * nCols-1; i >=0; i--){\n            ftSpectrum[i] = inputSpectrum[i];\n        }\n\n        ftSpectrum = FFTUtils.fft2DArray(ftSpectrum, nRows, nCols);\n\n        var dim = this.smallFilter.length;\n        var ftFilterData = new Array(nCols * nRows);\n        for(var i=nCols * nRows-1;i>=0;i--){\n            ftFilterData[i]=0;\n        }\n\n        var iRow, iCol;\n        var shift = (dim - 1) / 2;\n        //console.log(dim);\n        for (var ir = 0; ir < dim; ir++) {\n            iRow = (ir - shift + nRows) % nRows;\n            for (var ic = 0; ic < dim; ic++) {\n                iCol = (ic - shift + nCols) % nCols;\n                ftFilterData[iRow * nCols + iCol] = this.smallFilter[ir][ic];\n            }\n        }\n\n        ftFilterData = FFTUtils.fft2DArray(ftFilterData, nRows, nCols);\n\n        var ftRows = nRows * 2;\n        var ftCols = nCols / 2 + 1;\n        FFTUtils.convolute2DI(ftSpectrum, ftFilterData, ftRows, ftCols);\n\n        return  FFTUtils.ifft2DArray(ftSpectrum, ftRows, ftCols);\n    },\n    /**\n     Detects all the 2D-peaks in the given spectrum based on center of mass logic.\n     */\n    findPeaks2DLoG : function(inputSpectrum, convolutedSpectrum, nRows, nCols, nStdDev) {\n        var threshold = 0;\n        for(var i=nCols*nRows-2;i>=0;i--)\n            threshold+=Math.pow(convolutedSpectrum[i]-convolutedSpectrum[i+1],2);\n        threshold=-Math.sqrt(threshold);\n        threshold*=nStdDev/nRows;\n\n        var bitmask = new Array(nCols * nRows);\n        for(var i=nCols * nRows-1;i>=0;i--){\n            bitmask[i]=0;\n        }\n        var nbDetectedPoints = 0;\n        var lasti=-1;\n        for (var i = convolutedSpectrum.length-1; i >=0 ; i--) {\n            if (convolutedSpectrum[i] < threshold) {\n                bitmask[i] = 1;\n                nbDetectedPoints++;\n            }\n        }\n        var iStart = 0;\n        //int ranges = 0;\n        var peakList = [];\n\n        while (nbDetectedPoints != 0) {\n            for (iStart; iStart < bitmask.length && bitmask[iStart]==0; iStart++){};\n            //\n            if (iStart == bitmask.length)\n                break;\n\n            nbDetectedPoints -= this.extractArea(inputSpectrum, convolutedSpectrum,\n                bitmask, iStart, nRows, nCols, peakList, threshold);\n        }\n\n        if (peakList.length > 0&&this.DEBUG) {\n            console.log(\"No peak found\");\n        }\n        return peakList;\n    },\n    /**\n     Detects all the 2D-peaks in the given spectrum based on the Max logic.\n     */\n    findPeaks2DMax : function(inputSpectrum, cs, nRows, nCols, nStdDev) {\n        var threshold = 0;\n        for(var i=nCols*nRows-2;i>=0;i--)\n            threshold+=Math.pow(cs[i]-cs[i+1],2);\n        threshold=-Math.sqrt(threshold);\n        threshold*=nStdDev/nRows;\n\n        var rowI,colI;\n        var peakListMax = [];\n        var tmpIndex = 0;\n        for (var i = 0; i < cs.length; i++) {\n            if (cs[i] < threshold) {\n                //It is a peak?\n                rowI=Math.floor(i/nCols);\n                colI=i%nCols;\n                //Verifies if this point is a peak;\n                if(rowI>0&&rowI+1<nRows&&colI+1<nCols&&colI>0){\n                    //It is the minimum in the same row\n                    if(cs[i]<cs[i+1]&&cs[i]<cs[i-1]){\n                        //It is the minimum in the previous row\n                        tmpIndex=(rowI-1)*nCols+colI;\n                        if(cs[i]<cs[tmpIndex-1]&&cs[i]<cs[tmpIndex]&&cs[i]<cs[tmpIndex+1]){\n                            //It is the minimum in the next row\n                            tmpIndex=(rowI+1)*nCols+colI;\n                            if(cs[i]<cs[tmpIndex-1]&&cs[i]<cs[tmpIndex]&&cs[i]<cs[tmpIndex+1]){\n                                peakListMax.push({x:colI,y:rowI,z:inputSpectrum[i]});\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return peakListMax;\n    },\n    /*\n     This function detects the peaks\n     */\n    extractArea : function(spectrum, convolutedSpectrum, bitmask, iStart,\n                                                   nRows, nCols, peakList, threshold) {\n        var iRow = Math.floor(iStart / nCols);\n        var iCol = iStart % nCols;\n        var peakPoints =[];\n        //console.log(iStart+\" \"+iRow+\" \"+iCol);\n        // scanBitmask(bitmask, convolutedSpectrum, nRows, nCols, iRow, iCol,\n        // peakPoints);\n        this.scanBitmask(bitmask, nRows, nCols, iRow, iCol, peakPoints);\n        //console.log(\"extractArea.lng \"+peakPoints.length);\n        var x = new Array(peakPoints.length);\n        var y = new Array(peakPoints.length);\n        var z = new Array(peakPoints.length);\n        var nValues = peakPoints.length;\n        var xAverage = 0.0;\n        var yAverage = 0.0;\n        var zSum = 0.0;\n        if (nValues >= 9) {\n            if (this.DEBUG)\n                console.log(\"nValues=\" + nValues);\n            var maxValue = Number.NEGATIVE_INFINITY;\n            var maxIndex = -1;\n            for (var i = 0; i < nValues; i++) {\n                var pt = (peakPoints.splice(0,1))[0];\n                x[i] = pt[0];\n                y[i] = pt[1];\n                z[i] = spectrum[pt[1] * nCols + pt[0]];\n                xAverage += x[i] * z[i];\n                yAverage += y[i] * z[i];\n                zSum += z[i];\n                if (z[i] > maxValue) {\n                    maxValue = z[i];\n                    maxIndex = i;\n                }\n            }\n            if (maxIndex != -1) {\n                xAverage /= zSum;\n                yAverage /= zSum;\n                var newPeak = {x:xAverage, y:yAverage, z:zSum};\n                var minmax;\n                minmax =StatArray.minMax(x);\n                newPeak.minX=minmax.min;\n                newPeak.maxX=minmax.max;\n                minmax = StatArray.minMax(y);\n                newPeak.minY=minmax.min;\n                newPeak.maxY=minmax.max;\n                peakList.push(newPeak);\n            }\n        }\n        return nValues;\n    },\n    /*\n     Return all the peaks(x,y points) that composes a signal.\n     */\n    scanBitmask : function(bitmask, nRows, nCols, iRow, iCol, peakPoints) {\n        //console.log(nRows+\" \"+iRow+\" \"+nCols+\" \"+iCol);\n        if (iRow < 0 || iCol < 0 || iCol == nCols || iRow == nRows)\n            return;\n        if (bitmask[iRow * nCols + iCol]) {\n            bitmask[iRow * nCols + iCol] = 0;\n            peakPoints.push([iCol, iRow]);\n            this.scanBitmask(bitmask, nRows, nCols, iRow + 1, iCol, peakPoints);\n            this.scanBitmask(bitmask, nRows, nCols, iRow - 1, iCol, peakPoints);\n            this.scanBitmask(bitmask, nRows, nCols, iRow, iCol + 1, peakPoints);\n            this.scanBitmask(bitmask, nRows, nCols, iRow, iCol - 1, peakPoints);\n        }\n    },\n    /**\n     This function converts a set of 2D-peaks in 2D-signals. Each signal could be composed\n     of many 2D-peaks, and it has some additional information related to the NMR spectrum.\n     */\n    createSignals2D : function(peaks, spectraData, tolerance){\n        //console.log(peaks.length);\n        var signals=[];\n        var nbSubSpectra = spectraData.getNbSubSpectra();\n\n        var bf1=spectraData.observeFrequencyX();\n        var bf2=spectraData.observeFrequencyY();\n\n        var firstY = spectraData.getFirstY();\n        var lastY = spectraData.getLastY();\n        var dy = spectraData.getDeltaY();\n\n        //console.log(firstY+\" \"+lastY+\" \"+dy+\" \"+nbSubSpectra);\n        //spectraData.setActiveElement(0);\n        var noValid=0;\n        for (var i = peaks.length-1; i >=0 ; i--) {\n            //console.log(peaks[i].x+\" \"+spectraData.arrayPointToUnits(peaks[i].x));\n            //console.log(peaks[i].y+\" \"+(firstY + dy * (peaks[i].y)));\n            peaks[i].x=(spectraData.arrayPointToUnits(peaks[i].x));\n            peaks[i].y=(firstY + dy * (peaks[i].y));\n\n            //console.log(peaks[i])\n            //Still having problems to correctly detect peaks on those areas. So I'm removing everything there.\n            if(peaks[i].y<-1||peaks[i].y>=210){\n                peaks.splice(i,1);\n            }\n        }\n        //console.log(peaks);\n        //The connectivity matrix is an square and symmetric matrix, so we'll only store the upper diagonal in an\n        //array like form\n        var connectivity = [];\n        var tmp=0;\n        tolerance*=tolerance;\n        //console.log(tolerance);\n        for (var i = 0; i < peaks.length; i++) {\n            for (var j = i; j < peaks.length; j++) {\n                tmp=Math.pow((peaks[i].x-peaks[j].x)*bf1,2)+Math.pow((peaks[i].y-peaks[j].y)*bf2,2);\n                //Console.log(peaks[i].getX()+\" \"+peaks[j].getX()+\" \"+tmp);\n                if(tmp<tolerance){//30*30Hz We cannot distinguish peaks with less than 20 Hz of separation\n                    connectivity.push(1);\n                }\n                else{\n                    connectivity.push(0);\n                }\n            }\n        }\n\n        //console.log(connectivity);\n\n        var clusters = SimpleClustering.fullClusterGenerator(connectivity);\n\n        //console.log(clusters)\n\n        var signals = [];\n        if (peaks != null) {\n            var xValue, yValue;\n            for (var iCluster = 0; iCluster < clusters.length; iCluster++) {\n                var signal={nucleusX:spectraData.getNucleus(1),nucleusY:spectraData.getNucleus(2)};\n                signal.resolutionX=( spectraData.getLastX()-spectraData.getFirstX()) / spectraData.getNbPoints();\n                signal.resolutionY=dy;\n                var peaks2D = [];\n                signal.shiftX = 0;\n                signal.shiftY = 0;\n                var minMax1 = [Number.MAX_VALUE,0];\n                var minMax2 = [Number.MAX_VALUE,0];\n                var sumZ = 0;\n                for(var jPeak = clusters[iCluster].length-1;jPeak>=0;jPeak--){\n                    if(clusters[iCluster][jPeak]==1){\n                        peaks2D.push({\n                            x: peaks[jPeak].x,\n                            y: peaks[jPeak].y,\n                            z: peaks[jPeak].z\n\n                        }  );\n                        signal.shiftX+=peaks[jPeak].x*peaks[jPeak].z;\n                        signal.shiftY+=peaks[jPeak].y*peaks[jPeak].z;\n                        sumZ+=peaks[jPeak].z;\n                        if(peaks[jPeak].x<minMax1[0]){\n                            minMax1[0]=peaks[jPeak].x;\n                        }\n                        if(peaks[jPeak].x>minMax1[1]){\n                            minMax1[1]=peaks[jPeak].x;\n                        }\n                        if(peaks[jPeak].y<minMax2[0]){\n                            minMax2[0]=peaks[jPeak].y\n                        }\n                        if(peaks[jPeak].y>minMax2[1]){\n                            minMax2[1]=peaks[jPeak].y;\n                        }\n\n                    }\n                }\n                signal.fromTo = [{from:minMax1[0],to:minMax1[1]},\n                                {from:minMax2[0],to:minMax2[1]}];\n                signal.shiftX/=sumZ;\n                signal.shiftY/=sumZ;\n                signal.peaks = peaks2D;\n                signals.push(signal);\n            }\n        }\n        //console.log(signals);\n        return signals;\n    }\n}\n\nmodule.exports = PeakPicking2D;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/spectra-data/src/PeakPicking2D.js\n ** module id = 52\n ** module chunks = 0\n **/","'use strict';\n\nvar PeakOptimizer={\n\tdiagonalError:0.05,\n\ttolerance:0.05,\n\tDEBUG:false,\n    toleranceX : 0.025,\n    toleranceY : 0.5,\n\n    clean: function(peaks, threshold){\n        var max = Number.NEGATIVE_INFINITY;\n        var i,peak;\n        //double min = Double.MAX_VALUE;\n        for(i=peaks.length-1;i>=0;i--){\n            if(Math.abs(peaks[i].z)>max)\n                max=Math.abs(peaks[i].z);\n        }\n        max*=threshold;\n        for(i=peaks.length-1;i>=0;i--){\n            if(Math.abs(peaks[i].z)<max)\n                peaks.splice(i,1);\n        }\n        return peaks;\n    },\n\t\n\tenhanceSymmetry: function(signals){\n\t\t\n\t\tvar properties = this.initializeProperties(signals);\n\t\tvar output = signals;\n\n\t\tif(this.DEBUG)\n\t\t\tconsole.log(\"Before optimization size: \"+output.size());\n\t\t\n\t\t//First step of the optimization: Symmetry validation\n\t\tvar i,hits,index;\n\t\tvar signal;\n\t\tfor(i=output.length-1;i>=0;i--){\n\t\t\tsignal = output[i];\n\t\t\tif(signal.peaks.length>1)\n\t\t\t\tproperties[i][1]++;\n\t\t\tif(properties[i][0]==1){\n\t\t\t\tindex = this.exist(output, properties, signal,-1,true);\n\t\t\t\tif(index>=0){\n\t\t\t\t\tproperties[i][1]+=2;\n\t\t\t\t\tproperties[index][1]+=2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//Second step of the optimization: Diagonal image existence\n\t\tfor(i=output.length-1;i>=0;i--){\n\t\t\tsignal = output[i];\n\t\t\tif(properties[i][0]==0){\n\t\t\t\thits = this.checkCrossPeaks(output, properties, signal, true);\n\t\t\t\tproperties[i][1]+=hits;\n\t\t\t\t//checkCrossPeaks(output, properties, signal, false);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Now, each peak have a score between 0 and 4, we can complete the patterns which\n\t\t//contains peaks with high scores, and finally, we can remove peaks with scores 0 and 1\n\t\tvar count = 0;\n\t\tfor(i=output.length-1;i>=0;i--){\n\t\t\tif(properties[i][0]!==0&&properties[i][1]>2){\n\t\t\t\tcount++;\n\t\t\t\tcount+=this.completeMissingIfNeeded(output,properties,output[i],properties[i]);\n\t\t\t}\n\t\t\tif(properties[i][1]>=2&&properties[i][0]===0)\n\t\t\t\tcount++;\n\t\t}\n\t\t\n\t\tif(this.DEBUG)\n\t\t\tconsole.log(\"After optimization size: \"+count);\n\t\tvar  toReturn = new Array(count);\n\t\tcount--;\n\t\tfor(i=output.length-1;i>=0;i--){\n\t\t\tif(properties[i][0]!==0&&properties[i][1]>2\n\t\t\t\t\t||properties[i][0]===0&&properties[i][1]>1){\n\t\t\t\ttoReturn[count--]=output[i];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tconsole.log(\"Removed \"+i+\" \"+output[i].peaks.length);\n\t\t\t}\n\t\t\t//if(properties.get(i)[1]>=2)\n\t\t\t//\ttoReturn[count--]=output.get(i);\n\t\t}\n\t\treturn toReturn;\n\t},\n\t\n\tcompleteMissingIfNeeded: function(output, properties, thisSignal, thisProp) {\n\t\t//Check for symmetry\n\t\tvar index = this.exist(output, properties, thisSignal,-thisProp[0],true);\n\t\tvar addedPeaks=0;\n\t\tvar newSignal = null, tmpProp=null;\n\t\tif(index<0){//If this signal have no a symmetry image, we have to include it\n\t\t\tnewSignal = {nucleusX:thisSignal.nucleusX,nucleusY:thisSignal.nucleusY};\n\t\t\tnewSignal.resolutionX=thisSignal.resolutionX;\n\t\t\tnewSignal.resolutionY=thisSignal.resolutionY;\n\t\t\tnewSignal.shiftX=thisSignal.shiftY;\n\t\t\tnewSignal.shiftY=thisSignal.shiftX;\n\t\t\tnewSignal.peaks = [{x:thisSignal.shiftY,y:thisSignal.shiftX,z:1}];\n\t\t\toutput.push(newSignal);\n\t\t\ttmpProp = [-thisProp[0],thisProp[1]];\n\t\t\tproperties.push(tmpProp);\n\t\t\taddedPeaks++;\n\t\t}\n\t\t//Check for diagonal peaks\n\t\tvar j=0;\n\t\tvar diagX=false, diagY=false;\n\t\tvar signal;\n\t\tfor(j=output.length-1;j>=0;j--){\n\t\t\tsignal = output[j];\n\t\t\tif(properties[j][0]===0){\n\t\t\t\tif(Math.abs(signal.shiftX-thisSignal.shiftX)<this.diagonalError)\n\t\t\t\t\tdiagX=true;\n\t\t\t\tif(Math.abs(signal.shiftY-thisSignal.shiftY)<this.diagonalError)\n\t\t\t\t\tdiagY=true;\n\t\t\t}\n\t\t}\n\t\tif(diagX===false){\n\t\t\tnewSignal = {nucleusX:thisSignal.nucleusX,nucleusY:thisSignal.nucleusY};\n\t\t\tnewSignal.resolutionX=thisSignal.resolutionX;\n\t\t\tnewSignal.resolutionY=thisSignal.resolutionY;\n\t\t\tnewSignal.shiftX=thisSignal.shiftX;\n\t\t\tnewSignal.shiftY=thisSignal.shiftX;\n\t\t\tnewSignal.peaks = [{x:thisSignal.shiftX,y:thisSignal.shiftX,z:1}];\n\t\t\toutput.push(newSignal);\n\t\t\ttmpProp = [0,thisProp[1]];\n\t\t\tproperties.push(tmpProp);\n\t\t\taddedPeaks++;\n\t\t}\n\t\tif(diagY===false){\n\t\t\tnewSignal = {nucleusX:thisSignal.nucleusX,nucleusY:thisSignal.nucleusY};\n\t\t\tnewSignal.resolutionX=thisSignal.resolutionX;\n\t\t\tnewSignal.resolutionY=thisSignal.resolutionY;\n\t\t\tnewSignal.shiftX=thisSignal.shiftY;\n\t\t\tnewSignal.shiftY=thisSignal.shiftY;\n\t\t\tnewSignal.peaks = [{x:thisSignal.shiftY,y:thisSignal.shiftY,z:1}];\n\t\t\toutput.push(newSignal);\n\t\t\ttmpProp = [0,thisProp[1]];\n\t\t\tproperties.push(tmpProp);\n\t\t\taddedPeaks++;\n\t\t}\n\t\treturn addedPeaks;\n\t\t\n\t},\n\t\n\t//Check for any diagonal peak that match this cross peak\n\tcheckCrossPeaks: function(output, properties, signal, updateProperties) {\n\t\tvar hits = 0, i=0, shift=signal.shiftX*4;\n\t\tvar crossPeaksX = [],crossPeaksY = [];\n\t\tvar cross;\n\t\tfor(i=output.length-1;i>=0;i--){\n\t\t\tcross = output[i];\n\t\t\tif(properties[i][0]!==0){\n\t\t\t\tif(Math.abs(cross.shiftX-signal.shiftX)<this.diagonalError){\n\t\t\t\t\thits++;\n\t\t\t\t\tif(updateProperties)\n\t\t\t\t\t\tproperties[i][1]++;\n\t\t\t\t\tcrossPeaksX.push(i);\n\t\t\t\t\tshift+=cross.shiftX;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(Math.abs(cross.shiftY-signal.shiftY)<this.diagonalError){\n\t\t\t\t\t\thits++;\n\t\t\t\t\t\tif(updateProperties)\n\t\t\t\t\t\t\tproperties[i][1]++;\n\t\t\t\t\t\tcrossPeaksY.push(i);\n\t\t\t\t\t\tshift+=cross.shiftY;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//Update found crossPeaks and diagonal peak\n\t\tshift/=(crossPeaksX.length+crossPeaksY.length+4);\n\t\tif(crossPeaksX.length>0){\n\t\t\tfor( i=crossPeaksX.length-1;i>=0;i--){\n\t\t\t\toutput[crossPeaksX[i]].shiftX=shift;\n\t\t\t}\n\t\t}\n\t\tif(crossPeaksY.length>0){\n\t\t\tfor( i=crossPeaksY.length-1;i>=0;i--){\n\t\t\t\toutput[crossPeaksY[i]].shiftY=shift;\n\t\t\t}\n\t\t}\n\t\tsignal.shiftX=shift;\n\t\tsignal.shiftY=shift;\n\t\treturn hits;\n\t},\n\n\texist: function(output, properties, signal, type, symmetricSearch) {\n\t\tfor(var i=output.length-1;i>=0;i--){\n\t\t\tif(properties[i][0]==type){\n\t\t\t\tif(this.distanceTo(signal, output[i], symmetricSearch)<this.tolerance){\n\t\t\t\t\tif(!symmetricSearch){\n\t\t\t\t\t\tvar shiftX=(output[i].shiftX+signal.shiftX)/2.0;\n\t\t\t\t\t\tvar shiftY=(output[i].shiftY+signal.shiftY)/2.0;\n\t\t\t\t\t\toutput[i].shiftX=shiftX;\n\t\t\t\t\t\toutput[i].shiftY=shiftY;\n\t\t\t\t\t\tsignal.shiftX=shiftX;\n\t\t\t\t\t\tsignal.shiftY=shiftY;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tvar shiftX=signal.shiftX;\n\t\t\t\t\t\tvar shiftY=output[i].shiftX;\n\t\t\t\t\t\toutput[i].shiftY=shiftX;\n\t\t\t\t\t\tsignal.shiftY=shiftY;\n\t\t\t\t\t}\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\t/**\n\t * We try to determine the position of each signal within the spectrum matrix.\n\t * Peaks could be of 3 types: upper diagonal, diagonal or under diagonal 1,0,-1\n\t * respectively.\n\t * @param Signals\n\t * @return A matrix containing the properties of each signal\n\t */\n\tinitializeProperties: function(signals){\n\t\tvar signalsProperties = new Array(signals.length);\n\t\tfor(var i=signals.length-1;i>=0;i--){\n\t\t\tsignalsProperties[i]=[0,0];\n\t\t\t//We check if it is a diagonal peak\n\t\t\tif(Math.abs(signals[i].shiftX-signals[i].shiftY)<=this.diagonalError){\n\t\t\t\tsignalsProperties[i][1]=1;\n\t\t\t\t//We adjust the x and y value to be symmetric.\n\t\t\t\t//In general chemical shift in the direct dimension is better than in the other one,\n\t\t\t\t//so, we believe more to the shiftX than to the shiftY.\n\t\t\t\tvar shift = (signals[i].shiftX*2+signals[i].shiftY)/3.0;\n\t\t\t\tsignals[i].shiftX=shift;\n\t\t\t\tsignals[i].shiftY=shift;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(signals[i].shiftX-signals[i].shiftY>0)\n\t\t\t\t\tsignalsProperties[i][0]=1;\n\t\t\t\telse\n\t\t\t\t\tsignalsProperties[i][0]=-1;\n\t\t\t}\n\t\t}\n\t\treturn signalsProperties;\n\t},\n\t\n\t/**\n\t * This function calculates the distance between 2 nmr signals . If toImage is true, \n\t * it will interchange x by y in the distance calculation for the second signal.\n\t */\n\tdistanceTo: function(a, b, toImage){\n\t\tif(!toImage){\n\t\t\treturn Math.sqrt(Math.pow(a.shiftX-b.shiftX, 2)\n\t\t\t\t\t+Math.pow(a.shiftY-b.shiftY, 2));\n\t\t}\n\t\telse{\n\t\t\treturn Math.sqrt(Math.pow(a.shiftX-b.shiftY, 2)\n\t\t\t\t\t+Math.pow(a.shiftY-b.shiftX, 2));\n\t\t}\n\t},\n\n\t/**\n\t * This function maps the corresponding 2D signals to the given set of 1D signals\n\t */\n\talignDimensions:function(signals2D,references){\n\t\t//For each reference dimension\n\t\tfor(var i=0;i<references.length;i++){\n\t\t\tvar ref = references[i];\n\t\t\tif(ref)\n\t\t\t\tthis._alignSingleDimension(signals2D,ref);\n\t\t}\n\t},\n\n\t_alignSingleDimension: function(signals2D, references){\n\t\t//For each 2D signal\n\t\tvar center = 0, width = 0, i, j;\n\t\tfor(i=0;i<signals2D.length;i++){\n\t\t\tvar signal2D = signals2D[i];\n\t\t\t//For each reference 1D signal\n\t\t\tfor(j=0;j<references.length;j++){\n\t\t\t\tcenter = (references[j].startX+references[j].stopX)/2;\n\t\t\t\twidth = Math.abs(references[j].startX-references[j].stopX)/2;\n\t\t\t\tif(signal2D.nucleusX==references[j].nucleus){\n\t\t\t\t\t//The 2D peak overlaps with the 1D signal\n\t\t\t\t\tif(Math.abs(signal2D.shiftX-center)<=width){\n\t\t\t\t\t\tsignal2D._highlight.push(references[j]._highlight[0]);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif(signal2D.nucleusY==references[j].nucleus){\n\t\t\t\t\tif(Math.abs(signal2D.shiftY-center)<=width){\n\t\t\t\t\t\tsignal2D._highlight.push(references[j]._highlight[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n};\n\nmodule.exports = PeakOptimizer;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/spectra-data/src/PeakOptimizer.js\n ** module id = 53\n ** module chunks = 0\n **/","'use strict';\n\nvar SimpleClustering={\n\n\t/*This function returns the cluster list for a given connectivity matrix.\n\t*To improve the performance, the connectivity(square and symmetric) matrix \n\t*is given as a single vector containing  the upper diagonal of the matrix\n\t*Note: This algorithm is O(n*n) complexity. I wonder if there is something better. \n\t*acastillo\n\t*/\n\tfullClusterGenerator:function(conn){\n\t\tvar nRows = Math.sqrt(conn.length*2+0.25)-0.5;\n\t\t//console.log(\"nRows: \"+nRows+\" - \"+conn.length);\n\t\tvar clusterList = [];\n\t\tvar available = new Array(nRows);\n\t\tvar remaining = nRows, i=0;\n\t\tvar cluster = [];\n\t\t//Mark all the elements as available\n\t\tfor(i=nRows-1;i>=0;i--){\n\t\t\tavailable[i]=1;\n\t\t}\n\t\tvar nextAv=-1;\n\t\tvar toInclude = [];\n\t\twhile(remaining>0){\n\t\t\tif(toInclude.length===0){\n\t\t\t\t//If there is no more elements to include. Start a new cluster\n\t\t\t\tcluster = new Array(nRows);\n\t\t\t\tfor(i=nRows-1;i>=0;i--)\n\t\t\t\t\tcluster[i]=0;\n\t\t\t\tclusterList.push(cluster);\n\t\t    \tfor(nextAv = nRows-1;available[nextAv]==0;nextAv--){};\n\t\t    }\n\t\t    else{\n\t\t    \tnextAv=toInclude.splice(0,1);\n\t\t    }\n\t\t    //console.log(\"row: \"+nextAv);\n\t\t    cluster[nextAv]=1;\n\t\t    available[nextAv]=0;\n\t\t    remaining--;\n\t\t    //Copy the next available row\n\t\t    var row = new Array(nRows);\n\t\t\tfor(i=nRows-1;i>=0;i--){\n\t\t\t\tvar c=Math.max(nextAv,i);\n\t\t\t\tvar r=Math.min(nextAv,i);\n\t\t\t\t//The element in the conn matrix\n\t\t\t\t//console.log(\"index: \"+r*(2*nRows-r-1)/2+c)\n\t\t\t\trow[i]=conn[r*(2*nRows-r-1)/2+c];\n\t\t\t\t//console.log(\"col: \"+i+\":\"+row[i]);\n\t\t\t\t//There is new elements to include in this row?\n\t\t\t\t//Then, include it to the current cluster\n\t\t\t\tif(row[i]==1&&available[i]==1&&cluster[i]==0){\n\t\t\t\t\ttoInclude.push(i);\n\t\t\t\t\tcluster[i]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn clusterList;\n\t}\n}\n\nmodule.exports = SimpleClustering;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/spectra-data/src/SimpleClustering.js\n ** module id = 54\n ** module chunks = 0\n **/","'use strict';\n/**\n * This library formats a set of nmr1D signals to the ACS format.\n * Created by acastillo on 3/11/15. p\n */\nvar ACS=ACS || {};\nACS.formater =(function() {\n    var acsString=\"\";\n    var parenthesis=\"\";\n    var spectro=\"\";\n    var rangeForMultiplet=false;\n\n    function fromNMRSignal1D2ACS(spectrum, options){\n        acsString=\"\";\n        parenthesis=\"\";\n        spectro=\"\";\n        var solvent = null;\n        if(options&&options.solvent)\n            solvent = options.solvent;\n        //options.rangeForMultiplet=false;\n        if(options&&options.rangeForMultiplet!=undefined)\n            rangeForMultiplet = options.rangeForMultiplet;\n\n        if(options&&options.ascending){\n            spectrum.sort(function(a,b){\n                return b.delta1- a.delta1\n            });\n        }\n        else{\n            spectrum.sort(function(a,b){\n                return a.delta1- b.delta1\n            });\n        }\n\n        //console.log(\"Range1: \"+options.rangeForMultiplet);\n\n        spectrum.type=\"NMR SPEC\";\n        if (spectrum[0][\"nucleus\"]==\"1H\") {\n            formatAcs_default(spectrum, false, 2, 1, solvent);\n        } else if (spectrum[0][\"nucleus\"]==\"13C\") {\n            formatAcs_default(spectrum, false, 1, 0, solvent);\n        }\n\n        if (acsString.length>0) acsString+=\".\";\n\n        return acsString;\n    }\n\n    /*function formatAcs_default_IR(spectra, ascending, decimalValue, smw) {\n     appendSeparator();\n     appendSpectroInformation(spectra);\n     if (spectra[\"peakLabels\"]) {\n     var numberPeakLabels=spectra[\"peakLabels\"].length;\n     var minIntensity= 9999999;\n     var maxIntensity=-9999999;\n     for (var i=0; i<numberPeakLabels; i++) {\n     if (spectra[\"peakLabels\"][i].intensity<minIntensity) minIntensity=spectra[\"peakLabels\"][i].intensity;\n     if (spectra[\"peakLabels\"][i].intensity>maxIntensity) maxIntensity=spectra[\"peakLabels\"][i].intensity;\n     }\n     for (var i=0; i<numberPeakLabels; i++) {\n     if (ascending) {\n     var peakLabel=spectra[\"peakLabels\"][i];\n     } else {\n     var peakLabel=spectra[\"peakLabels\"][numberPeakLabels-i-1];\n     }\n     if (peakLabel) {\n     appendSeparator();\n     appendValue(peakLabel,decimalValue);\n     if (smw) { // we need to add small / medium / strong\n     if (peakLabel.intensity<((maxIntensity-minIntensity)/3+minIntensity)) acsString+=\" (s)\";\n     else if (peakLabel.intensity>(maxIntensity-(maxIntensity-minIntensity)/3)) acsString+=\" (w)\";\n     else acsString+=\" (m)\";\n     }\n     }\n     }\n     }\n     }*/\n\n    function formatAcs_default(spectra, ascending, decimalValue, decimalJ, solvent) {\n        appendSeparator();\n        appendSpectroInformation(spectra, solvent);\n        var numberSmartPeakLabels=spectra.length;\n        //console.log(\"SP \"+spectra);\n        //console.log(\"# \"+numberSmartPeakLabels);\n        for (var i=0; i<numberSmartPeakLabels; i++) {\n            if (ascending) {\n                var signal=spectra[i];\n            } else {\n                var signal=spectra[numberSmartPeakLabels-i-1];\n            }\n            if (signal) {\n                //console.log(\"X2X\"+i+JSON.stringify(signal));\n                appendSeparator();\n                appendDelta(signal,decimalValue);\n                appendParenthesis(signal,decimalJ);\n                //console.log(\"S2S\"+i);\n            }\n        }\n    }\n\n    function appendSpectroInformation(spectrum, solvent) {\n        if (spectrum.type==\"NMR SPEC\") {\n            if (spectrum[0].nucleus) {\n                acsString+=formatNucleus(spectrum[0].nucleus);\n            }\n            acsString+=\" NMR\";\n            if ((solvent) || (spectrum[0].observe)) {\n                acsString+=\" (\";\n                if (spectrum[0].observe) {\n                    acsString+=(spectrum[0].observe*1).toFixed(0)+\" MHz\";\n                    if (solvent) acsString+=\", \";\n                }\n                if (solvent) {\n                    acsString+=formatMF(solvent);\n                }\n                acsString+=\")\";\n            }\n            acsString+=\" δ \";\n        } else if (spectrum.type==\"IR\") {\n            acsString+=\" IR \";\n        } else if (spectrum.type==\"MASS\") {\n            acsString+=\" MASS \";\n        }\n    }\n\n    function appendDelta(line, nbDecimal) {\n        //console.log(\"appendDelta1\");\n        var startX = 0,stopX=0,delta1=0;\n        if(line.startX){\n            if((typeof line.startX)==\"string\"){\n                startX=parseFloat(line.startX);\n            }\n            else\n                startX=line.startX;\n        }\n        if(line.stopX){\n            if((typeof line.stopX)==\"string\"){\n                stopX=parseFloat(line.stopX);\n            }\n            else\n                stopX=line.stopX;\n        }\n        if(line.delta1){\n            if((typeof line.delta1)==\"string\"){\n                delta1=parseFloat(line.delta1);\n            }\n            else\n                delta1=line.delta1;\n\n        }\n        //console.log(\"Range2: \"+rangeForMultiplet+\" \"+line.multiplicity);\n        if (line.asymmetric===true||(line.multiplicity==\"m\"&&rangeForMultiplet===true)) {//Is it massive??\n            if (line.startX&&line.stopX) {\n                if (startX<stopX) {\n                    acsString+=startX.toFixed(nbDecimal)+\"-\"+stopX.toFixed(nbDecimal);\n                } else {\n                    acsString+=stopX.toFixed(nbDecimal)+\"-\"+startX.toFixed(nbDecimal);\n                }\n            } else {\n                if(line.delta1)\n                    acsString+=delta1.toFixed(nbDecimal);\n            }\n        }\n        else{\n            if(line.delta1)\n                acsString+=delta1.toFixed(nbDecimal);\n            else{\n                if(line.startX&&line.stopX){\n                    acsString+=((startX+stopX)/2).toFixed(nbDecimal);\n                }\n            }\n        }\n    }\n\n    function appendValue(line, nbDecimal) {\n        if (line.xPosition) {\n            acsString+=line.xPosition.toFixed(nbDecimal);\n        }\n    }\n\n    function appendParenthesis(line, nbDecimal) {\n        //console.log(\"appendParenthesis1\");\n        // need to add assignment - coupling - integration\n        parenthesis=\"\";\n        appendMultiplicity(line);\n        appendIntegration(line);\n        appendCoupling(line,nbDecimal);\n        appendAssignment(line);\n\n\n        if (parenthesis.length>0) {\n            acsString+=\" (\"+parenthesis+\")\";\n        }\n        //console.log(\"appendParenthesis2\");\n    }\n\n    function appendIntegration(line) {\n        if (line.pubIntegration) {\n            appendParenthesisSeparator();\n            parenthesis+=line.pubIntegration;\n        } else if (line.integralData) {\n            appendParenthesisSeparator();\n            parenthesis+=line.integralData.value.toFixed(0)+\" H\";\n        }\n    }\n\n    function appendAssignment(line) {\n        if (line.pubAssignment) {\n            appendParenthesisSeparator();\n            parenthesis+=formatAssignment(line.pubAssignment);\n        }\n        else{\n            if (line.assignment) {\n                appendParenthesisSeparator();\n                parenthesis+=formatAssignment(line.assignment);\n            }\n        }\n    }\n\n    function appendMultiplicity(line) {\n        if (line.pubMultiplicity) {\n            appendParenthesisSeparator();\n            parenthesis+=line.pubMultiplicity;\n        } else if (line.multiplicity) {\n            appendParenthesisSeparator();\n            parenthesis+=line.multiplicity;\n        }\n    }\n\n    function appendCoupling(line, nbDecimal) {\n        if (line.nmrJs) {\n            var j=\"<i>J</i> = \";\n            for (var i=0; i<line.nmrJs.length; i++) {\n                var coupling=line.nmrJs[i].coupling;\n                if (j.length>11) j+=\", \";\n                j+=coupling.toFixed(nbDecimal);\n            }\n            appendParenthesisSeparator();\n            parenthesis+=j+\" Hz\";\n        }\n\n    }\n\n    function formatAssignment(assignment) {\n        assignment=assignment.replace(/([0-9])/g,\"<sub>$1</sub>\");\n        assignment=assignment.replace(/\\\"([^\\\"]*)\\\"/g,\"<i>$1</i>\");\n        return assignment;\n    }\n\n    function formatMF(mf) {\n        mf=mf.replace(/([0-9])/g,\"<sub>$1</sub>\");\n        return mf;\n    }\n\n    function formatNucleus(nucleus) {\n        nucleus=nucleus.replace(/([0-9])/g,\"<sup>$1</sup>\");\n        return nucleus;\n    }\n\n    function appendSeparator() {\n        if ((acsString.length>0) && (! acsString.match(/ $/))) {\n            acsString+=\", \";\n        }\n    }\n\n    function appendParenthesisSeparator() {\n        if ((parenthesis.length>0) && (! parenthesis.match(\", $\"))) parenthesis+=\", \";\n    }\n\n    function fromACS2NMRSignal1D(acsString){\n        return JSON.parse(SDAPI.AcsParserAsJSONString(acsString));\n    }\n\n    return {\n        toACS:fromNMRSignal1D2ACS,\n        toNMRSignal:fromACS2NMRSignal1D\n    }\n})();\n\nmodule.exports=ACS;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/spectra-data/src/AcsParser.js\n ** module id = 55\n ** module chunks = 0\n **/"],"sourceRoot":""}